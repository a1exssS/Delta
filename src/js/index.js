(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const s of r) if (s.type === "childList") for (const a of s.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && i(a) }).observe(document, { childList: !0, subtree: !0 }); function t(r) { const s = {}; return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function i(r) { if (r.ep) return; r.ep = !0; const s = t(r); fetch(r.href, s) } })(); function di(n) { if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return n } function No(n, e) { n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e }/*!
 * GSAP 3.12.4
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Lt = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, Dr = { duration: .5, overwrite: !1, delay: 0 }, Ta, Qe, ve, $t = 1e8, le = 1 / $t, Kn = Math.PI * 2, Cd = Kn / 4, Pd = 0, Yo = Math.sqrt, Ad = Math.cos, Ld = Math.sin, He = function (e) { return typeof e == "string" }, _e = function (e) { return typeof e == "function" }, mi = function (e) { return typeof e == "number" }, Ea = function (e) { return typeof e > "u" }, ai = function (e) { return typeof e == "object" }, gt = function (e) { return e !== !1 }, Ma = function () { return typeof window < "u" }, Os = function (e) { return _e(e) || He(e) }, Ho = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function () { }, Je = Array.isArray, Zn = /(?:-?\.?\d|\.)+/gi, Vo = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Tr = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Pn = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Go = /[+-]=-?[.\d]+/, Xo = /[^,'"\[\]\s]+/gi, kd = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, me, It, Qn, Ca, kt = {}, sn = {}, Wo, jo = function (e) { return (sn = lr(e, kt)) && wt }, Pa = function (e, t) { return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()") }, _s = function (e, t) { return !t && console.warn(e) }, Uo = function (e, t) { return e && (kt[e] = t) && sn && (sn[e] = t) || kt }, ys = function () { return 0 }, Od = { suppressEvents: !0, isStart: !0, kill: !1 }, Gs = { suppressEvents: !0, kill: !1 }, Id = { suppressEvents: !0 }, Aa = {}, Pi = [], Jn = {}, Ko, Tt = {}, An = {}, Qa = 30, Xs = [], La = "", ka = function (e) { var t = e[0], i, r; if (ai(t) || _e(t) || (e = [e]), !(i = (t._gsap || {}).harness)) { for (r = Xs.length; r-- && !Xs[r].targetTest(t);); i = Xs[r] } for (r = e.length; r--;)e[r] && (e[r]._gsap || (e[r]._gsap = new wl(e[r], i))) || e.splice(r, 1); return e }, Ji = function (e) { return e._gsap || ka(Bt(e))[0]._gsap }, Zo = function (e, t, i) { return (i = e[t]) && _e(i) ? e[t]() : Ea(i) && e.getAttribute && e.getAttribute(t) || i }, vt = function (e, t) { return (e = e.split(",")).forEach(t) || e }, Se = function (e) { return Math.round(e * 1e5) / 1e5 || 0 }, Ye = function (e) { return Math.round(e * 1e7) / 1e7 || 0 }, Pr = function (e, t) { var i = t.charAt(0), r = parseFloat(t.substr(2)); return e = parseFloat(e), i === "+" ? e + r : i === "-" ? e - r : i === "*" ? e * r : e / r }, Dd = function (e, t) { for (var i = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < i;); return r < i }, nn = function () { var e = Pi.length, t = Pi.slice(0), i, r; for (Jn = {}, Pi.length = 0, i = 0; i < e; i++)r = t[i], r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0) }, Qo = function (e, t, i, r) { Pi.length && !Qe && nn(), e.render(t, i, r || Qe && t < 0 && (e._initted || e._startAt)), Pi.length && !Qe && nn() }, Jo = function (e) { var t = parseFloat(e); return (t || t === 0) && (e + "").match(Xo).length < 2 ? t : He(e) ? e.trim() : e }, el = function (e) { return e }, Ft = function (e, t) { for (var i in t) i in e || (e[i] = t[i]); return e }, zd = function (e) { return function (t, i) { for (var r in i) r in t || r === "duration" && e || r === "ease" || (t[r] = i[r]) } }, lr = function (e, t) { for (var i in t) e[i] = t[i]; return e }, Ja = function n(e, t) { for (var i in t) i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = ai(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]); return e }, an = function (e, t) { var i = {}, r; for (r in e) r in t || (i[r] = e[r]); return i }, ss = function (e) { var t = e.parent || me, i = e.keyframes ? zd(Je(e.keyframes)) : Ft; if (gt(e.inherit)) for (; t;)i(e, t.vars.defaults), t = t.parent || t._dp; return e }, Rd = function (e, t) { for (var i = e.length, r = i === t.length; r && i-- && e[i] === t[i];); return i < 0 }, tl = function (e, t, i, r, s) { i === void 0 && (i = "_first"), r === void 0 && (r = "_last"); var a = e[r], o; if (s) for (o = t[s]; a && a[s] > o;)a = a._prev; return a ? (t._next = a._next, a._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[r] = t, t._prev = a, t.parent = t._dp = e, t }, bn = function (e, t, i, r) { i === void 0 && (i = "_first"), r === void 0 && (r = "_last"); var s = t._prev, a = t._next; s ? s._next = a : e[i] === t && (e[i] = a), a ? a._prev = s : e[r] === t && (e[r] = s), t._next = t._prev = t.parent = null }, ki = function (e, t) { e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0 }, er = function (e, t) { if (e && (!t || t._end > e._dur || t._start < 0)) for (var i = e; i;)i._dirty = 1, i = i.parent; return e }, $d = function (e) { for (var t = e.parent; t && t.parent;)t._dirty = 1, t.totalDuration(), t = t.parent; return e }, ea = function (e, t, i, r) { return e._startAt && (Qe ? e._startAt.revert(Gs) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, r)) }, Bd = function n(e) { return !e || e._ts && n(e.parent) }, eo = function (e) { return e._repeat ? zr(e._tTime, e = e.duration() + e._rDelay) * e : 0 }, zr = function (e, t) { var i = Math.floor(e /= t); return e && i === e ? i - 1 : i }, on = function (e, t) { return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur) }, Sn = function (e) { return e._end = Ye(e._start + (e._tDur / Math.abs(e._ts || e._rts || le) || 0)) }, xn = function (e, t) { var i = e._dp; return i && i.smoothChildTiming && e._ts && (e._start = Ye(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Sn(e), i._dirty || er(i, e)), e }, il = function (e, t) { var i; if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = on(e.rawTime(), t), (!t._dur || Ps(0, t.totalDuration(), i) - t._tTime > le) && t.render(i, !0)), er(e, t)._dp && e._initted && e._time >= e._dur && e._ts) { if (e._dur < e.duration()) for (i = e; i._dp;)i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp; e._zTime = -le } }, ti = function (e, t, i, r) { return t.parent && ki(t), t._start = Ye((mi(i) ? i : i || e !== me ? Ot(e, i, t) : e._time) + t._delay), t._end = Ye(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), tl(e, t, "_first", "_last", e._sort ? "_start" : 0), ta(t) || (e._recent = t), r || il(e, t), e._ts < 0 && xn(e, e._tTime), e }, rl = function (e, t) { return (kt.ScrollTrigger || Pa("scrollTrigger", t)) && kt.ScrollTrigger.create(t, e) }, sl = function (e, t, i, r, s) { if (Ia(e, t, s), !e._initted) return 1; if (!i && e._pt && !Qe && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && Ko !== Mt.frame) return Pi.push(e), e._lazy = [s, r], 1 }, qd = function n(e) { var t = e.parent; return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t)) }, ta = function (e) { var t = e.data; return t === "isFromStart" || t === "isStart" }, Fd = function (e, t, i, r) { var s = e.ratio, a = t < 0 || !t && (!e._start && qd(e) && !(!e._initted && ta(e)) || (e._ts < 0 || e._dp._ts < 0) && !ta(e)) ? 0 : 1, o = e._rDelay, l = 0, d, c, u; if (o && e._repeat && (l = Ps(0, e._tDur, t), c = zr(l, o), e._yoyo && c & 1 && (a = 1 - a), c !== zr(e._tTime, o) && (s = 1 - a, e.vars.repeatRefresh && e._initted && e.invalidate())), a !== s || Qe || r || e._zTime === le || !t && e._zTime) { if (!e._initted && sl(e, t, r, i, l)) return; for (u = e._zTime, e._zTime = t || (i ? le : 0), i || (i = t && !u), e.ratio = a, e._from && (a = 1 - a), e._time = 0, e._tTime = l, d = e._pt; d;)d.r(a, d.d), d = d._next; t < 0 && ea(e, t, i, !0), e._onUpdate && !i && Pt(e, "onUpdate"), l && e._repeat && !i && e.parent && Pt(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === a && (a && ki(e, 1), !i && !Qe && (Pt(e, a ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom())) } else e._zTime || (e._zTime = t) }, Nd = function (e, t, i) { var r; if (i > t) for (r = e._first; r && r._start <= i;) { if (r.data === "isPause" && r._start > t) return r; r = r._next } else for (r = e._last; r && r._start >= i;) { if (r.data === "isPause" && r._start < t) return r; r = r._prev } }, Rr = function (e, t, i, r) { var s = e._repeat, a = Ye(t) || 0, o = e._tTime / e._tDur; return o && !r && (e._time *= a / e._dur), e._dur = a, e._tDur = s ? s < 0 ? 1e10 : Ye(a * (s + 1) + e._rDelay * s) : a, o > 0 && !r && xn(e, e._tTime = e._tDur * o), e.parent && Sn(e), i || er(e.parent, e), e }, to = function (e) { return e instanceof dt ? er(e) : Rr(e, e._dur) }, Yd = { _start: 0, endTime: ys, totalDuration: ys }, Ot = function n(e, t, i) { var r = e.labels, s = e._recent || Yd, a = e.duration() >= $t ? s.endTime(!1) : e._dur, o, l, d; return He(t) && (isNaN(t) || t in r) ? (l = t.charAt(0), d = t.substr(-1) === "%", o = t.indexOf("="), l === "<" || l === ">" ? (o >= 0 && (t = t.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (d ? (o < 0 ? s : i).totalDuration() / 100 : 1)) : o < 0 ? (t in r || (r[t] = a), r[t]) : (l = parseFloat(t.charAt(o - 1) + t.substr(o + 1)), d && i && (l = l / 100 * (Je(i) ? i[0] : i).totalDuration()), o > 1 ? n(e, t.substr(0, o - 1), i) + l : a + l)) : t == null ? a : +t }, ns = function (e, t, i) { var r = mi(t[1]), s = (r ? 2 : 1) + (e < 2 ? 0 : 1), a = t[s], o, l; if (r && (a.duration = t[1]), a.parent = i, e) { for (o = a, l = i; l && !("immediateRender" in o);)o = l.vars.defaults || {}, l = gt(l.vars.inherit) && l.parent; a.immediateRender = gt(o.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[s - 1] } return new Me(t[0], a, t[s + 1]) }, zi = function (e, t) { return e || e === 0 ? t(e) : t }, Ps = function (e, t, i) { return i < e ? e : i > t ? t : i }, Ze = function (e, t) { return !He(e) || !(t = kd.exec(e)) ? "" : t[1] }, Hd = function (e, t, i) { return zi(i, function (r) { return Ps(e, t, r) }) }, ia = [].slice, nl = function (e, t) { return e && ai(e) && "length" in e && (!t && !e.length || e.length - 1 in e && ai(e[0])) && !e.nodeType && e !== It }, Vd = function (e, t, i) { return i === void 0 && (i = []), e.forEach(function (r) { var s; return He(r) && !t || nl(r, 1) ? (s = i).push.apply(s, Bt(r)) : i.push(r) }) || i }, Bt = function (e, t, i) { return ve && !t && ve.selector ? ve.selector(e) : He(e) && !i && (Qn || !$r()) ? ia.call((t || Ca).querySelectorAll(e), 0) : Je(e) ? Vd(e, i) : nl(e) ? ia.call(e, 0) : e ? [e] : [] }, ra = function (e) { return e = Bt(e)[0] || _s("Invalid scope") || {}, function (t) { var i = e.current || e.nativeElement || e; return Bt(t, i.querySelectorAll ? i : i === e ? _s("Invalid scope") || Ca.createElement("div") : e) } }, al = function (e) { return e.sort(function () { return .5 - Math.random() }) }, ol = function (e) { if (_e(e)) return e; var t = ai(e) ? e : { each: e }, i = tr(t.ease), r = t.from || 0, s = parseFloat(t.base) || 0, a = {}, o = r > 0 && r < 1, l = isNaN(r) || o, d = t.axis, c = r, u = r; return He(r) ? c = u = { center: .5, edges: .5, end: 1 }[r] || 0 : !o && l && (c = r[0], u = r[1]), function (f, p, m) { var h = (m || t).length, g = a[h], y, v, _, w, S, x, P, L, M; if (!g) { if (M = t.grid === "auto" ? 0 : (t.grid || [1, $t])[1], !M) { for (P = -$t; P < (P = m[M++].getBoundingClientRect().left) && M < h;); M < h && M-- } for (g = a[h] = [], y = l ? Math.min(M, h) * c - .5 : r % M, v = M === $t ? 0 : l ? h * u / M - .5 : r / M | 0, P = 0, L = $t, x = 0; x < h; x++)_ = x % M - y, w = v - (x / M | 0), g[x] = S = d ? Math.abs(d === "y" ? w : _) : Yo(_ * _ + w * w), S > P && (P = S), S < L && (L = S); r === "random" && al(g), g.max = P - L, g.min = L, g.v = h = (parseFloat(t.amount) || parseFloat(t.each) * (M > h ? h - 1 : d ? d === "y" ? h / M : M : Math.max(M, h / M)) || 0) * (r === "edges" ? -1 : 1), g.b = h < 0 ? s - h : s, g.u = Ze(t.amount || t.each) || 0, i = i && h < 0 ? vl(i) : i } return h = (g[f] - g.min) / g.max || 0, Ye(g.b + (i ? i(h) : h) * g.v) + g.u } }, sa = function (e) { var t = Math.pow(10, ((e + "").split(".")[1] || "").length); return function (i) { var r = Ye(Math.round(parseFloat(i) / e) * e * t); return (r - r % 1) / t + (mi(i) ? 0 : Ze(i)) } }, ll = function (e, t) { var i = Je(e), r, s; return !i && ai(e) && (r = i = e.radius || $t, e.values ? (e = Bt(e.values), (s = !mi(e[0])) && (r *= r)) : e = sa(e.increment)), zi(t, i ? _e(e) ? function (a) { return s = e(a), Math.abs(s - a) <= r ? s : a } : function (a) { for (var o = parseFloat(s ? a.x : a), l = parseFloat(s ? a.y : 0), d = $t, c = 0, u = e.length, f, p; u--;)s ? (f = e[u].x - o, p = e[u].y - l, f = f * f + p * p) : f = Math.abs(e[u] - o), f < d && (d = f, c = u); return c = !r || d <= r ? e[c] : a, s || c === a || mi(a) ? c : c + Ze(a) } : sa(e)) }, dl = function (e, t, i, r) { return zi(Je(e) ? !t : i === !0 ? !!(i = 0) : !r, function () { return Je(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * .99)) / i) * i * r) / r }) }, Gd = function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; return function (r) { return t.reduce(function (s, a) { return a(s) }, r) } }, Xd = function (e, t) { return function (i) { return e(parseFloat(i)) + (t || Ze(i)) } }, Wd = function (e, t, i) { return ul(e, t, 0, 1, i) }, cl = function (e, t, i) { return zi(i, function (r) { return e[~~t(r)] }) }, jd = function n(e, t, i) { var r = t - e; return Je(e) ? cl(e, n(0, e.length), t) : zi(i, function (s) { return (r + (s - e) % r) % r + e }) }, Ud = function n(e, t, i) { var r = t - e, s = r * 2; return Je(e) ? cl(e, n(0, e.length - 1), t) : zi(i, function (a) { return a = (s + (a - e) % s) % s || 0, e + (a > r ? s - a : a) }) }, ws = function (e) { for (var t = 0, i = "", r, s, a, o; ~(r = e.indexOf("random(", t));)a = e.indexOf(")", r), o = e.charAt(r + 7) === "[", s = e.substr(r + 7, a - r - 7).match(o ? Xo : Zn), i += e.substr(t, r - t) + dl(o ? s : +s[0], o ? 0 : +s[1], +s[2] || 1e-5), t = a + 1; return i + e.substr(t, e.length - t) }, ul = function (e, t, i, r, s) { var a = t - e, o = r - i; return zi(s, function (l) { return i + ((l - e) / a * o || 0) }) }, Kd = function n(e, t, i, r) { var s = isNaN(e + t) ? 0 : function (p) { return (1 - p) * e + p * t }; if (!s) { var a = He(e), o = {}, l, d, c, u, f; if (i === !0 && (r = 1) && (i = null), a) e = { p: e }, t = { p: t }; else if (Je(e) && !Je(t)) { for (c = [], u = e.length, f = u - 2, d = 1; d < u; d++)c.push(n(e[d - 1], e[d])); u--, s = function (m) { m *= u; var h = Math.min(f, ~~m); return c[h](m - h) }, i = t } else r || (e = lr(Je(e) ? [] : {}, e)); if (!c) { for (l in t) Oa.call(o, e, l, "get", t[l]); s = function (m) { return Ra(m, o) || (a ? e.p : e) } } } return zi(i, s) }, io = function (e, t, i) { var r = e.labels, s = $t, a, o, l; for (a in r) o = r[a] - t, o < 0 == !!i && o && s > (o = Math.abs(o)) && (l = a, s = o); return l }, Pt = function (e, t, i) { var r = e.vars, s = r[t], a = ve, o = e._ctx, l, d, c; if (s) return l = r[t + "Params"], d = r.callbackScope || e, i && Pi.length && nn(), o && (ve = o), c = l ? s.apply(d, l) : s.call(d), ve = a, c }, Ur = function (e) { return ki(e), e.scrollTrigger && e.scrollTrigger.kill(!!Qe), e.progress() < 1 && Pt(e, "onInterrupt"), e }, Er, fl = [], pl = function (e) { if (Ma() && e) { e = !e.name && e.default || e; var t = e.name, i = _e(e), r = t && !i && e.init ? function () { this._props = [] } : e, s = { init: ys, render: Ra, add: Oa, kill: fc, modifier: uc, rawVars: 0 }, a = { targetTest: 0, get: 0, getSetter: za, aliases: {}, register: 0 }; if ($r(), e !== r) { if (Tt[t]) return; Ft(r, Ft(an(e, s), a)), lr(r.prototype, lr(s, an(e, a))), Tt[r.prop = t] = r, e.targetTest && (Xs.push(r), Aa[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin" } Uo(t, r), e.register && e.register(wt, r, _t) } else e && fl.push(e) }, oe = 255, Kr = { aqua: [0, oe, oe], lime: [0, oe, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, oe], navy: [0, 0, 128], white: [oe, oe, oe], olive: [128, 128, 0], yellow: [oe, oe, 0], orange: [oe, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [oe, 0, 0], pink: [oe, 192, 203], cyan: [0, oe, oe], transparent: [oe, oe, oe, 0] }, Ln = function (e, t, i) { return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (i - t) * e * 6 : e < .5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * oe + .5 | 0 }, hl = function (e, t, i) { var r = e ? mi(e) ? [e >> 16, e >> 8 & oe, e & oe] : 0 : Kr.black, s, a, o, l, d, c, u, f, p, m; if (!r) { if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Kr[e]) r = Kr[e]; else if (e.charAt(0) === "#") { if (e.length < 6 && (s = e.charAt(1), a = e.charAt(2), o = e.charAt(3), e = "#" + s + s + a + a + o + o + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return r = parseInt(e.substr(1, 6), 16), [r >> 16, r >> 8 & oe, r & oe, parseInt(e.substr(7), 16) / 255]; e = parseInt(e.substr(1), 16), r = [e >> 16, e >> 8 & oe, e & oe] } else if (e.substr(0, 3) === "hsl") { if (r = m = e.match(Zn), !t) l = +r[0] % 360 / 360, d = +r[1] / 100, c = +r[2] / 100, a = c <= .5 ? c * (d + 1) : c + d - c * d, s = c * 2 - a, r.length > 3 && (r[3] *= 1), r[0] = Ln(l + 1 / 3, s, a), r[1] = Ln(l, s, a), r[2] = Ln(l - 1 / 3, s, a); else if (~e.indexOf("=")) return r = e.match(Vo), i && r.length < 4 && (r[3] = 1), r } else r = e.match(Zn) || Kr.transparent; r = r.map(Number) } return t && !m && (s = r[0] / oe, a = r[1] / oe, o = r[2] / oe, u = Math.max(s, a, o), f = Math.min(s, a, o), c = (u + f) / 2, u === f ? l = d = 0 : (p = u - f, d = c > .5 ? p / (2 - u - f) : p / (u + f), l = u === s ? (a - o) / p + (a < o ? 6 : 0) : u === a ? (o - s) / p + 2 : (s - a) / p + 4, l *= 60), r[0] = ~~(l + .5), r[1] = ~~(d * 100 + .5), r[2] = ~~(c * 100 + .5)), i && r.length < 4 && (r[3] = 1), r }, ml = function (e) { var t = [], i = [], r = -1; return e.split(Ai).forEach(function (s) { var a = s.match(Tr) || []; t.push.apply(t, a), i.push(r += a.length + 1) }), t.c = i, t }, ro = function (e, t, i) { var r = "", s = (e + r).match(Ai), a = t ? "hsla(" : "rgba(", o = 0, l, d, c, u; if (!s) return e; if (s = s.map(function (f) { return (f = hl(f, t, 1)) && a + (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) + ")" }), i && (c = ml(e), l = i.c, l.join(r) !== c.c.join(r))) for (d = e.replace(Ai, "1").split(Tr), u = d.length - 1; o < u; o++)r += d[o] + (~l.indexOf(o) ? s.shift() || a + "0,0,0,0)" : (c.length ? c : s.length ? s : i).shift()); if (!d) for (d = e.split(Ai), u = d.length - 1; o < u; o++)r += d[o] + s[o]; return r + d[u] }, Ai = function () { var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e; for (e in Kr) n += "|" + e + "\\b"; return new RegExp(n + ")", "gi") }(), Zd = /hsl[a]?\(/, gl = function (e) { var t = e.join(" "), i; if (Ai.lastIndex = 0, Ai.test(t)) return i = Zd.test(t), e[1] = ro(e[1], i), e[0] = ro(e[0], i, ml(e[1])), !0 }, bs, Mt = function () { var n = Date.now, e = 500, t = 33, i = n(), r = i, s = 1e3 / 240, a = s, o = [], l, d, c, u, f, p, m = function h(g) { var y = n() - r, v = g === !0, _, w, S, x; if (y > e && (i += y - t), r += y, S = r - i, _ = S - a, (_ > 0 || v) && (x = ++u.frame, f = S - u.time * 1e3, u.time = S = S / 1e3, a += _ + (_ >= s ? 4 : s - _), w = 1), v || (l = d(h)), w) for (p = 0; p < o.length; p++)o[p](S, f, x, g) }; return u = { time: 0, frame: 0, tick: function () { m(!0) }, deltaRatio: function (g) { return f / (1e3 / (g || 60)) }, wake: function () { Wo && (!Qn && Ma() && (It = Qn = window, Ca = It.document || {}, kt.gsap = wt, (It.gsapVersions || (It.gsapVersions = [])).push(wt.version), jo(sn || It.GreenSockGlobals || !It.gsap && It || {}), c = It.requestAnimationFrame, fl.forEach(pl)), l && u.sleep(), d = c || function (g) { return setTimeout(g, a - u.time * 1e3 + 1 | 0) }, bs = 1, m(2)) }, sleep: function () { (c ? It.cancelAnimationFrame : clearTimeout)(l), bs = 0, d = ys }, lagSmoothing: function (g, y) { e = g || 1 / 0, t = Math.min(y || 33, e) }, fps: function (g) { s = 1e3 / (g || 240), a = u.time * 1e3 + s }, add: function (g, y, v) { var _ = y ? function (w, S, x, P) { g(w, S, x, P), u.remove(_) } : g; return u.remove(g), o[v ? "unshift" : "push"](_), $r(), _ }, remove: function (g, y) { ~(y = o.indexOf(g)) && o.splice(y, 1) && p >= y && p-- }, _listeners: o }, u }(), $r = function () { return !bs && Mt.wake() }, J = {}, Qd = /^[\d.\-M][\d.\-,\s]/, Jd = /["']/g, ec = function (e) { for (var t = {}, i = e.substr(1, e.length - 3).split(":"), r = i[0], s = 1, a = i.length, o, l, d; s < a; s++)l = i[s], o = s !== a - 1 ? l.lastIndexOf(",") : l.length, d = l.substr(0, o), t[r] = isNaN(d) ? d.replace(Jd, "").trim() : +d, r = l.substr(o + 1).trim(); return t }, tc = function (e) { var t = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", t); return e.substring(t, ~r && r < i ? e.indexOf(")", i + 1) : i) }, ic = function (e) { var t = (e + "").split("("), i = J[t[0]]; return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [ec(t[1])] : tc(e).split(",").map(Jo)) : J._CE && Qd.test(e) ? J._CE("", e) : i }, vl = function (e) { return function (t) { return 1 - e(1 - t) } }, _l = function n(e, t) { for (var i = e._first, r; i;)i instanceof dt ? n(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? n(i.timeline, t) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = t)), i = i._next }, tr = function (e, t) { return e && (_e(e) ? e : J[e] || ic(e)) || t }, hr = function (e, t, i, r) { i === void 0 && (i = function (l) { return 1 - t(1 - l) }), r === void 0 && (r = function (l) { return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2 }); var s = { easeIn: t, easeOut: i, easeInOut: r }, a; return vt(e, function (o) { J[o] = kt[o] = s, J[a = o.toLowerCase()] = i; for (var l in s) J[a + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = J[o + "." + l] = s[l] }), s }, yl = function (e) { return function (t) { return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2 } }, kn = function n(e, t, i) { var r = t >= 1 ? t : 1, s = (i || (e ? .3 : .45)) / (t < 1 ? t : 1), a = s / Kn * (Math.asin(1 / r) || 0), o = function (c) { return c === 1 ? 1 : r * Math.pow(2, -10 * c) * Ld((c - a) * s) + 1 }, l = e === "out" ? o : e === "in" ? function (d) { return 1 - o(1 - d) } : yl(o); return s = Kn / s, l.config = function (d, c) { return n(e, d, c) }, l }, On = function n(e, t) { t === void 0 && (t = 1.70158); var i = function (a) { return a ? --a * a * ((t + 1) * a + t) + 1 : 0 }, r = e === "out" ? i : e === "in" ? function (s) { return 1 - i(1 - s) } : yl(i); return r.config = function (s) { return n(e, s) }, r }; vt("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) { var t = e < 5 ? e + 1 : e; hr(n + ",Power" + (t - 1), e ? function (i) { return Math.pow(i, t) } : function (i) { return i }, function (i) { return 1 - Math.pow(1 - i, t) }, function (i) { return i < .5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2 }) }); J.Linear.easeNone = J.none = J.Linear.easeIn; hr("Elastic", kn("in"), kn("out"), kn()); (function (n, e) { var t = 1 / e, i = 2 * t, r = 2.5 * t, s = function (o) { return o < t ? n * o * o : o < i ? n * Math.pow(o - 1.5 / e, 2) + .75 : o < r ? n * (o -= 2.25 / e) * o + .9375 : n * Math.pow(o - 2.625 / e, 2) + .984375 }; hr("Bounce", function (a) { return 1 - s(1 - a) }, s) })(7.5625, 2.75); hr("Expo", function (n) { return n ? Math.pow(2, 10 * (n - 1)) : 0 }); hr("Circ", function (n) { return -(Yo(1 - n * n) - 1) }); hr("Sine", function (n) { return n === 1 ? 1 : -Ad(n * Cd) + 1 }); hr("Back", On("in"), On("out"), On()); J.SteppedEase = J.steps = kt.SteppedEase = { config: function (e, t) { e === void 0 && (e = 1); var i = 1 / e, r = e + (t ? 0 : 1), s = t ? 1 : 0, a = 1 - le; return function (o) { return ((r * Ps(0, a, o) | 0) + s) * i } } }; Dr.ease = J["quad.out"]; vt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (n) { return La += n + "," + n + "Params," }); var wl = function (e, t) { this.id = Pd++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Zo, this.set = t ? t.getSetter : za }, Ss = function () { function n(t) { this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Rr(this, +t.duration, 1, 1), this.data = t.data, ve && (this._ctx = ve, ve.data.push(this)), bs || Mt.wake() } var e = n.prototype; return e.delay = function (i) { return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay), this._delay = i, this) : this._delay }, e.duration = function (i) { return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur }, e.totalDuration = function (i) { return arguments.length ? (this._dirty = 0, Rr(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, e.totalTime = function (i, r) { if ($r(), !arguments.length) return this._tTime; var s = this._dp; if (s && s.smoothChildTiming && this._ts) { for (xn(this, i), !s._dp || s.parent || il(s, this); s && s.parent;)s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0), s = s.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && ti(this._dp, this, this._start - this._delay) } return (this._tTime !== i || !this._dur && !r || this._initted && Math.abs(this._zTime) === le || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i), Qo(this, i, r)), this }, e.time = function (i, r) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + eo(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), r) : this._time }, e.totalProgress = function (i, r) { return arguments.length ? this.totalTime(this.totalDuration() * i, r) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0 }, e.progress = function (i, r) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + eo(this), r) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0 }, e.iteration = function (i, r) { var s = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (i - 1) * s, r) : this._repeat ? zr(this._tTime, s) + 1 : 1 }, e.timeScale = function (i, r) { if (!arguments.length) return this._rts === -le ? 0 : this._rts; if (this._rts === i) return this; var s = this.parent && this._ts ? on(this.parent._time, this) : this._tTime; return this._rts = +i || 0, this._ts = this._ps || i === -le ? 0 : this._rts, this.totalTime(Ps(-Math.abs(this._delay), this._tDur, s), r !== !1), Sn(this), $d(this) }, e.paused = function (i) { return arguments.length ? (this._ps !== i && (this._ps = i, i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : ($r(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== le && (this._tTime -= le)))), this) : this._ps }, e.startTime = function (i) { if (arguments.length) { this._start = i; var r = this.parent || this._dp; return r && (r._sort || !this.parent) && ti(r, this, i - this._delay), this } return this._start }, e.endTime = function (i) { return this._start + (gt(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, e.rawTime = function (i) { var r = this.parent || this._dp; return r ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? on(r.rawTime(i), this) : this._tTime : this._tTime }, e.revert = function (i) { i === void 0 && (i = Id); var r = Qe; return Qe = i, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i), this.totalTime(-.01, i.suppressEvents)), this.data !== "nested" && i.kill !== !1 && this.kill(), Qe = r, this }, e.globalTime = function (i) { for (var r = this, s = arguments.length ? i : r.rawTime(); r;)s = r._start + s / (Math.abs(r._ts) || 1), r = r._dp; return !this.parent && this._sat ? this._sat.globalTime(i) : s }, e.repeat = function (i) { return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i, to(this)) : this._repeat === -2 ? 1 / 0 : this._repeat }, e.repeatDelay = function (i) { if (arguments.length) { var r = this._time; return this._rDelay = i, to(this), r ? this.time(r) : this } return this._rDelay }, e.yoyo = function (i) { return arguments.length ? (this._yoyo = i, this) : this._yoyo }, e.seek = function (i, r) { return this.totalTime(Ot(this, i), gt(r)) }, e.restart = function (i, r) { return this.play().totalTime(i ? -this._delay : 0, gt(r)) }, e.play = function (i, r) { return i != null && this.seek(i, r), this.reversed(!1).paused(!1) }, e.reverse = function (i, r) { return i != null && this.seek(i || this.totalDuration(), r), this.reversed(!0).paused(!1) }, e.pause = function (i, r) { return i != null && this.seek(i, r), this.paused(!0) }, e.resume = function () { return this.paused(!1) }, e.reversed = function (i) { return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -le : 0)), this) : this._rts < 0 }, e.invalidate = function () { return this._initted = this._act = 0, this._zTime = -le, this }, e.isActive = function () { var i = this.parent || this._dp, r = this._start, s; return !!(!i || this._ts && this._initted && i.isActive() && (s = i.rawTime(!0)) >= r && s < this.endTime(!0) - le) }, e.eventCallback = function (i, r, s) { var a = this.vars; return arguments.length > 1 ? (r ? (a[i] = r, s && (a[i + "Params"] = s), i === "onUpdate" && (this._onUpdate = r)) : delete a[i], this) : a[i] }, e.then = function (i) { var r = this; return new Promise(function (s) { var a = _e(i) ? i : el, o = function () { var d = r.then; r.then = null, _e(a) && (a = a(r)) && (a.then || a === r) && (r.then = d), s(a), r.then = d }; r._initted && r.totalProgress() === 1 && r._ts >= 0 || !r._tTime && r._ts < 0 ? o() : r._prom = o }) }, e.kill = function () { Ur(this) }, n }(); Ft(Ss.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -le, _prom: 0, _ps: !1, _rts: 1 }); var dt = function (n) { No(e, n); function e(i, r) { var s; return i === void 0 && (i = {}), s = n.call(this, i) || this, s.labels = {}, s.smoothChildTiming = !!i.smoothChildTiming, s.autoRemoveChildren = !!i.autoRemoveChildren, s._sort = gt(i.sortChildren), me && ti(i.parent || me, di(s), r), i.reversed && s.reverse(), i.paused && s.paused(!0), i.scrollTrigger && rl(di(s), i.scrollTrigger), s } var t = e.prototype; return t.to = function (r, s, a) { return ns(0, arguments, this), this }, t.from = function (r, s, a) { return ns(1, arguments, this), this }, t.fromTo = function (r, s, a, o) { return ns(2, arguments, this), this }, t.set = function (r, s, a) { return s.duration = 0, s.parent = this, ss(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new Me(r, s, Ot(this, a), 1), this }, t.call = function (r, s, a) { return ti(this, Me.delayedCall(0, r, s), a) }, t.staggerTo = function (r, s, a, o, l, d, c) { return a.duration = s, a.stagger = a.stagger || o, a.onComplete = d, a.onCompleteParams = c, a.parent = this, new Me(r, a, Ot(this, l)), this }, t.staggerFrom = function (r, s, a, o, l, d, c) { return a.runBackwards = 1, ss(a).immediateRender = gt(a.immediateRender), this.staggerTo(r, s, a, o, l, d, c) }, t.staggerFromTo = function (r, s, a, o, l, d, c, u) { return o.startAt = a, ss(o).immediateRender = gt(o.immediateRender), this.staggerTo(r, s, o, l, d, c, u) }, t.render = function (r, s, a) { var o = this._time, l = this._dirty ? this.totalDuration() : this._tDur, d = this._dur, c = r <= 0 ? 0 : Ye(r), u = this._zTime < 0 != r < 0 && (this._initted || !d), f, p, m, h, g, y, v, _, w, S, x, P; if (this !== me && c > l && r >= 0 && (c = l), c !== this._tTime || a || u) { if (o !== this._time && d && (c += this._time - o, r += this._time - o), f = c, w = this._start, _ = this._ts, y = !_, u && (d || (o = this._zTime), (r || !s) && (this._zTime = r)), this._repeat) { if (x = this._yoyo, g = d + this._rDelay, this._repeat < -1 && r < 0) return this.totalTime(g * 100 + r, s, a); if (f = Ye(c % g), c === l ? (h = this._repeat, f = d) : (h = ~~(c / g), h && h === c / g && (f = d, h--), f > d && (f = d)), S = zr(this._tTime, g), !o && this._tTime && S !== h && this._tTime - S * g - this._dur <= 0 && (S = h), x && h & 1 && (f = d - f, P = 1), h !== S && !this._lock) { var L = x && S & 1, M = L === (x && h & 1); if (h < S && (L = !L), o = L ? 0 : c % d ? d : c, this._lock = 1, this.render(o || (P ? 0 : Ye(h * g)), s, !d)._lock = 0, this._tTime = c, !s && this.parent && Pt(this, "onRepeat"), this.vars.repeatRefresh && !P && (this.invalidate()._lock = 1), o && o !== this._time || y !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (d = this._dur, l = this._tDur, M && (this._lock = 2, o = L ? d : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !P && this.invalidate()), this._lock = 0, !this._ts && !y) return this; _l(this, P) } } if (this._hasPause && !this._forcing && this._lock < 2 && (v = Nd(this, Ye(o), Ye(f)), v && (c -= f - (f = v._start))), this._tTime = c, this._time = f, this._act = !_, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = r, o = 0), !o && f && !s && !h && (Pt(this, "onStart"), this._tTime !== c)) return this; if (f >= o && r >= 0) for (p = this._first; p;) { if (m = p._next, (p._act || f >= p._start) && p._ts && v !== p) { if (p.parent !== this) return this.render(r, s, a); if (p.render(p._ts > 0 ? (f - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (f - p._start) * p._ts, s, a), f !== this._time || !this._ts && !y) { v = 0, m && (c += this._zTime = -le); break } } p = m } else { p = this._last; for (var E = r < 0 ? r : f; p;) { if (m = p._prev, (p._act || E <= p._end) && p._ts && v !== p) { if (p.parent !== this) return this.render(r, s, a); if (p.render(p._ts > 0 ? (E - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (E - p._start) * p._ts, s, a || Qe && (p._initted || p._startAt)), f !== this._time || !this._ts && !y) { v = 0, m && (c += this._zTime = E ? -le : le); break } } p = m } } if (v && !s && (this.pause(), v.render(f >= o ? 0 : -le)._zTime = f >= o ? 1 : -1, this._ts)) return this._start = w, Sn(this), this.render(r, s, a); this._onUpdate && !s && Pt(this, "onUpdate", !0), (c === l && this._tTime >= this.totalDuration() || !c && o) && (w === this._start || Math.abs(_) !== Math.abs(this._ts)) && (this._lock || ((r || !d) && (c === l && this._ts > 0 || !c && this._ts < 0) && ki(this, 1), !s && !(r < 0 && !o) && (c || o || !l) && (Pt(this, c === l && r >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(c < l && this.timeScale() > 0) && this._prom()))) } return this }, t.add = function (r, s) { var a = this; if (mi(s) || (s = Ot(this, s, r)), !(r instanceof Ss)) { if (Je(r)) return r.forEach(function (o) { return a.add(o, s) }), this; if (He(r)) return this.addLabel(r, s); if (_e(r)) r = Me.delayedCall(0, r); else return this } return this !== r ? ti(this, r, s) : this }, t.getChildren = function (r, s, a, o) { r === void 0 && (r = !0), s === void 0 && (s = !0), a === void 0 && (a = !0), o === void 0 && (o = -$t); for (var l = [], d = this._first; d;)d._start >= o && (d instanceof Me ? s && l.push(d) : (a && l.push(d), r && l.push.apply(l, d.getChildren(!0, s, a)))), d = d._next; return l }, t.getById = function (r) { for (var s = this.getChildren(1, 1, 1), a = s.length; a--;)if (s[a].vars.id === r) return s[a] }, t.remove = function (r) { return He(r) ? this.removeLabel(r) : _e(r) ? this.killTweensOf(r) : (bn(this, r), r === this._recent && (this._recent = this._last), er(this)) }, t.totalTime = function (r, s) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Ye(Mt.time - (this._ts > 0 ? r / this._ts : (this.totalDuration() - r) / -this._ts))), n.prototype.totalTime.call(this, r, s), this._forcing = 0, this) : this._tTime }, t.addLabel = function (r, s) { return this.labels[r] = Ot(this, s), this }, t.removeLabel = function (r) { return delete this.labels[r], this }, t.addPause = function (r, s, a) { var o = Me.delayedCall(0, s || ys, a); return o.data = "isPause", this._hasPause = 1, ti(this, o, Ot(this, r)) }, t.removePause = function (r) { var s = this._first; for (r = Ot(this, r); s;)s._start === r && s.data === "isPause" && ki(s), s = s._next }, t.killTweensOf = function (r, s, a) { for (var o = this.getTweensOf(r, a), l = o.length; l--;)Si !== o[l] && o[l].kill(r, s); return this }, t.getTweensOf = function (r, s) { for (var a = [], o = Bt(r), l = this._first, d = mi(s), c; l;)l instanceof Me ? Dd(l._targets, o) && (d ? (!Si || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && a.push(l) : (c = l.getTweensOf(o, s)).length && a.push.apply(a, c), l = l._next; return a }, t.tweenTo = function (r, s) { s = s || {}; var a = this, o = Ot(a, r), l = s, d = l.startAt, c = l.onStart, u = l.onStartParams, f = l.immediateRender, p, m = Me.to(a, Ft({ ease: s.ease || "none", lazy: !1, immediateRender: !1, time: o, overwrite: "auto", duration: s.duration || Math.abs((o - (d && "time" in d ? d.time : a._time)) / a.timeScale()) || le, onStart: function () { if (a.pause(), !p) { var g = s.duration || Math.abs((o - (d && "time" in d ? d.time : a._time)) / a.timeScale()); m._dur !== g && Rr(m, g, 0, 1).render(m._time, !0, !0), p = 1 } c && c.apply(m, u || []) } }, s)); return f ? m.render(0) : m }, t.tweenFromTo = function (r, s, a) { return this.tweenTo(s, Ft({ startAt: { time: Ot(this, r) } }, a)) }, t.recent = function () { return this._recent }, t.nextLabel = function (r) { return r === void 0 && (r = this._time), io(this, Ot(this, r)) }, t.previousLabel = function (r) { return r === void 0 && (r = this._time), io(this, Ot(this, r), 1) }, t.currentLabel = function (r) { return arguments.length ? this.seek(r, !0) : this.previousLabel(this._time + le) }, t.shiftChildren = function (r, s, a) { a === void 0 && (a = 0); for (var o = this._first, l = this.labels, d; o;)o._start >= a && (o._start += r, o._end += r), o = o._next; if (s) for (d in l) l[d] >= a && (l[d] += r); return er(this) }, t.invalidate = function (r) { var s = this._first; for (this._lock = 0; s;)s.invalidate(r), s = s._next; return n.prototype.invalidate.call(this, r) }, t.clear = function (r) { r === void 0 && (r = !0); for (var s = this._first, a; s;)a = s._next, this.remove(s), s = a; return this._dp && (this._time = this._tTime = this._pTime = 0), r && (this.labels = {}), er(this) }, t.totalDuration = function (r) { var s = 0, a = this, o = a._last, l = $t, d, c, u; if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -r : r)); if (a._dirty) { for (u = a.parent; o;)d = o._prev, o._dirty && o.totalDuration(), c = o._start, c > l && a._sort && o._ts && !a._lock ? (a._lock = 1, ti(a, o, c - o._delay, 1)._lock = 0) : l = c, c < 0 && o._ts && (s -= c, (!u && !a._dp || u && u.smoothChildTiming) && (a._start += c / a._ts, a._time -= c, a._tTime -= c), a.shiftChildren(-c, !1, -1 / 0), l = 0), o._end > s && o._ts && (s = o._end), o = d; Rr(a, a === me && a._time > s ? a._time : s, 1, 1), a._dirty = 0 } return a._tDur }, e.updateRoot = function (r) { if (me._ts && (Qo(me, on(r, me)), Ko = Mt.frame), Mt.frame >= Qa) { Qa += Lt.autoSleep || 120; var s = me._first; if ((!s || !s._ts) && Lt.autoSleep && Mt._listeners.length < 2) { for (; s && !s._ts;)s = s._next; s || Mt.sleep() } } }, e }(Ss); Ft(dt.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var rc = function (e, t, i, r, s, a, o) { var l = new _t(this._pt, e, t, 0, 1, Ml, null, s), d = 0, c = 0, u, f, p, m, h, g, y, v; for (l.b = i, l.e = r, i += "", r += "", (y = ~r.indexOf("random(")) && (r = ws(r)), a && (v = [i, r], a(v, e, t), i = v[0], r = v[1]), f = i.match(Pn) || []; u = Pn.exec(r);)m = u[0], h = r.substring(d, u.index), p ? p = (p + 1) % 5 : h.substr(-5) === "rgba(" && (p = 1), m !== f[c++] && (g = parseFloat(f[c - 1]) || 0, l._pt = { _next: l._pt, p: h || c === 1 ? h : ",", s: g, c: m.charAt(1) === "=" ? Pr(g, m) - g : parseFloat(m) - g, m: p && p < 4 ? Math.round : 0 }, d = Pn.lastIndex); return l.c = d < r.length ? r.substring(d, r.length) : "", l.fp = o, (Go.test(r) || y) && (l.e = 0), this._pt = l, l }, Oa = function (e, t, i, r, s, a, o, l, d, c) { _e(r) && (r = r(s || 0, e, a)); var u = e[t], f = i !== "get" ? i : _e(u) ? d ? e[t.indexOf("set") || !_e(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](d) : e[t]() : u, p = _e(u) ? d ? lc : Tl : Da, m; if (He(r) && (~r.indexOf("random(") && (r = ws(r)), r.charAt(1) === "=" && (m = Pr(f, r) + (Ze(f) || 0), (m || m === 0) && (r = m))), !c || f !== r || na) return !isNaN(f * r) && r !== "" ? (m = new _t(this._pt, e, t, +f || 0, r - (f || 0), typeof u == "boolean" ? cc : El, 0, p), d && (m.fp = d), o && m.modifier(o, this, e), this._pt = m) : (!u && !(t in e) && Pa(t, r), rc.call(this, e, t, f, r, p, l || Lt.stringFilter, d)) }, sc = function (e, t, i, r, s) { if (_e(e) && (e = as(e, s, t, i, r)), !ai(e) || e.style && e.nodeType || Je(e) || Ho(e)) return He(e) ? as(e, s, t, i, r) : e; var a = {}, o; for (o in e) a[o] = as(e[o], s, t, i, r); return a }, bl = function (e, t, i, r, s, a) { var o, l, d, c; if (Tt[e] && (o = new Tt[e]).init(s, o.rawVars ? t[e] : sc(t[e], r, s, a, i), i, r, a) !== !1 && (i._pt = l = new _t(i._pt, s, e, 0, 1, o.render, o, 0, o.priority), i !== Er)) for (d = i._ptLookup[i._targets.indexOf(s)], c = o._props.length; c--;)d[o._props[c]] = l; return o }, Si, na, Ia = function n(e, t, i) { var r = e.vars, s = r.ease, a = r.startAt, o = r.immediateRender, l = r.lazy, d = r.onUpdate, c = r.runBackwards, u = r.yoyoEase, f = r.keyframes, p = r.autoRevert, m = e._dur, h = e._startAt, g = e._targets, y = e.parent, v = y && y.data === "nested" ? y.vars.targets : g, _ = e._overwrite === "auto" && !Ta, w = e.timeline, S, x, P, L, M, E, O, C, k, b, A, z, I; if (w && (!f || !s) && (s = "none"), e._ease = tr(s, Dr.ease), e._yEase = u ? vl(tr(u === !0 ? s : u, Dr.ease)) : 0, u && e._yoyo && !e._repeat && (u = e._yEase, e._yEase = e._ease, e._ease = u), e._from = !w && !!r.runBackwards, !w || f && !r.stagger) { if (C = g[0] ? Ji(g[0]).harness : 0, z = C && r[C.prop], S = an(r, Aa), h && (h._zTime < 0 && h.progress(1), t < 0 && c && o && !p ? h.render(-1, !0) : h.revert(c && m ? Gs : Od), h._lazy = 0), a) { if (ki(e._startAt = Me.set(g, Ft({ data: "isStart", overwrite: !1, parent: y, immediateRender: !0, lazy: !h && gt(l), startAt: null, delay: 0, onUpdate: d && function () { return Pt(e, "onUpdate") }, stagger: 0 }, a))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Qe || !o && !p) && e._startAt.revert(Gs), o && m && t <= 0 && i <= 0) { t && (e._zTime = t); return } } else if (c && m && !h) { if (t && (o = !1), P = Ft({ overwrite: !1, data: "isFromStart", lazy: o && !h && gt(l), immediateRender: o, stagger: 0, parent: y }, S), z && (P[C.prop] = z), ki(e._startAt = Me.set(g, P)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Qe ? e._startAt.revert(Gs) : e._startAt.render(-1, !0)), e._zTime = t, !o) n(e._startAt, le, le); else if (!t) return } for (e._pt = e._ptCache = 0, l = m && gt(l) || l && !m, x = 0; x < g.length; x++) { if (M = g[x], O = M._gsap || ka(g)[x]._gsap, e._ptLookup[x] = b = {}, Jn[O.id] && Pi.length && nn(), A = v === g ? x : v.indexOf(M), C && (k = new C).init(M, z || S, e, A, v) !== !1 && (e._pt = L = new _t(e._pt, M, k.name, 0, 1, k.render, k, 0, k.priority), k._props.forEach(function (D) { b[D] = L }), k.priority && (E = 1)), !C || z) for (P in S) Tt[P] && (k = bl(P, S, e, A, M, v)) ? k.priority && (E = 1) : b[P] = L = Oa.call(e, M, P, "get", S[P], A, v, 0, r.stringFilter); e._op && e._op[x] && e.kill(M, e._op[x]), _ && e._pt && (Si = e, me.killTweensOf(M, b, e.globalTime(t)), I = !e.parent, Si = 0), e._pt && l && (Jn[O.id] = 1) } E && Cl(e), e._onInit && e._onInit(e) } e._onUpdate = d, e._initted = (!e._op || e._pt) && !I, f && t <= 0 && w.render($t, !0, !0) }, nc = function (e, t, i, r, s, a, o, l) { var d = (e._pt && e._ptCache || (e._ptCache = {}))[t], c, u, f, p; if (!d) for (d = e._ptCache[t] = [], f = e._ptLookup, p = e._targets.length; p--;) { if (c = f[p][t], c && c.d && c.d._pt) for (c = c.d._pt; c && c.p !== t && c.fp !== t;)c = c._next; if (!c) return na = 1, e.vars[t] = "+=0", Ia(e, o), na = 0, l ? _s(t + " not eligible for reset") : 1; d.push(c) } for (p = d.length; p--;)u = d[p], c = u._pt || u, c.s = (r || r === 0) && !s ? r : c.s + (r || 0) + a * c.c, c.c = i - c.s, u.e && (u.e = Se(i) + Ze(u.e)), u.b && (u.b = c.s + Ze(u.b)) }, ac = function (e, t) { var i = e[0] ? Ji(e[0]).harness : 0, r = i && i.aliases, s, a, o, l; if (!r) return t; s = lr({}, t); for (a in r) if (a in s) for (l = r[a].split(","), o = l.length; o--;)s[l[o]] = s[a]; return s }, oc = function (e, t, i, r) { var s = t.ease || r || "power1.inOut", a, o; if (Je(t)) o = i[e] || (i[e] = []), t.forEach(function (l, d) { return o.push({ t: d / (t.length - 1) * 100, v: l, e: s }) }); else for (a in t) o = i[a] || (i[a] = []), a === "ease" || o.push({ t: parseFloat(e), v: t[a], e: s }) }, as = function (e, t, i, r, s) { return _e(e) ? e.call(t, i, r, s) : He(e) && ~e.indexOf("random(") ? ws(e) : e }, Sl = La + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", xl = {}; vt(Sl + ",id,stagger,delay,duration,paused,scrollTrigger", function (n) { return xl[n] = 1 }); var Me = function (n) { No(e, n); function e(i, r, s, a) { var o; typeof r == "number" && (s.duration = r, r = s, s = null), o = n.call(this, a ? r : ss(r)) || this; var l = o.vars, d = l.duration, c = l.delay, u = l.immediateRender, f = l.stagger, p = l.overwrite, m = l.keyframes, h = l.defaults, g = l.scrollTrigger, y = l.yoyoEase, v = r.parent || me, _ = (Je(i) || Ho(i) ? mi(i[0]) : "length" in r) ? [i] : Bt(i), w, S, x, P, L, M, E, O; if (o._targets = _.length ? ka(_) : _s("GSAP target " + i + " not found. https://gsap.com", !Lt.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = p, m || f || Os(d) || Os(c)) { if (r = o.vars, w = o.timeline = new dt({ data: "nested", defaults: h || {}, targets: v && v.data === "nested" ? v.vars.targets : _ }), w.kill(), w.parent = w._dp = di(o), w._start = 0, f || Os(d) || Os(c)) { if (P = _.length, E = f && ol(f), ai(f)) for (L in f) ~Sl.indexOf(L) && (O || (O = {}), O[L] = f[L]); for (S = 0; S < P; S++)x = an(r, xl), x.stagger = 0, y && (x.yoyoEase = y), O && lr(x, O), M = _[S], x.duration = +as(d, di(o), S, M, _), x.delay = (+as(c, di(o), S, M, _) || 0) - o._delay, !f && P === 1 && x.delay && (o._delay = c = x.delay, o._start += c, x.delay = 0), w.to(M, x, E ? E(S, M, _) : 0), w._ease = J.none; w.duration() ? d = c = 0 : o.timeline = 0 } else if (m) { ss(Ft(w.vars.defaults, { ease: "none" })), w._ease = tr(m.ease || r.ease || "none"); var C = 0, k, b, A; if (Je(m)) m.forEach(function (z) { return w.to(_, z, ">") }), w.duration(); else { x = {}; for (L in m) L === "ease" || L === "easeEach" || oc(L, m[L], x, m.easeEach); for (L in x) for (k = x[L].sort(function (z, I) { return z.t - I.t }), C = 0, S = 0; S < k.length; S++)b = k[S], A = { ease: b.e, duration: (b.t - (S ? k[S - 1].t : 0)) / 100 * d }, A[L] = b.v, w.to(_, A, C), C += A.duration; w.duration() < d && w.to({}, { duration: d - w.duration() }) } } d || o.duration(d = w.duration()) } else o.timeline = 0; return p === !0 && !Ta && (Si = di(o), me.killTweensOf(_), Si = 0), ti(v, di(o), s), r.reversed && o.reverse(), r.paused && o.paused(!0), (u || !d && !m && o._start === Ye(v._time) && gt(u) && Bd(di(o)) && v.data !== "nested") && (o._tTime = -le, o.render(Math.max(0, -c) || 0)), g && rl(di(o), g), o } var t = e.prototype; return t.render = function (r, s, a) { var o = this._time, l = this._tDur, d = this._dur, c = r < 0, u = r > l - le && !c ? l : r < le ? 0 : r, f, p, m, h, g, y, v, _, w; if (!d) Fd(this, r, s, a); else if (u !== this._tTime || !r || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== c) { if (f = u, _ = this.timeline, this._repeat) { if (h = d + this._rDelay, this._repeat < -1 && c) return this.totalTime(h * 100 + r, s, a); if (f = Ye(u % h), u === l ? (m = this._repeat, f = d) : (m = ~~(u / h), m && m === Ye(u / h) && (f = d, m--), f > d && (f = d)), y = this._yoyo && m & 1, y && (w = this._yEase, f = d - f), g = zr(this._tTime, h), f === o && !a && this._initted && m === g) return this._tTime = u, this; m !== g && (_ && this._yEase && _l(_, y), this.vars.repeatRefresh && !y && !this._lock && this._time !== d && this._initted && (this._lock = a = 1, this.render(Ye(h * m), !0).invalidate()._lock = 0)) } if (!this._initted) { if (sl(this, c ? r : f, a, s, u)) return this._tTime = 0, this; if (o !== this._time && !(a && this.vars.repeatRefresh && m !== g)) return this; if (d !== this._dur) return this.render(r, s, a) } if (this._tTime = u, this._time = f, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = v = (w || this._ease)(f / d), this._from && (this.ratio = v = 1 - v), f && !o && !s && !m && (Pt(this, "onStart"), this._tTime !== u)) return this; for (p = this._pt; p;)p.r(v, p.d), p = p._next; _ && _.render(r < 0 ? r : !f && y ? -le : _._dur * _._ease(f / this._dur), s, a) || this._startAt && (this._zTime = r), this._onUpdate && !s && (c && ea(this, r, s, a), Pt(this, "onUpdate")), this._repeat && m !== g && this.vars.onRepeat && !s && this.parent && Pt(this, "onRepeat"), (u === this._tDur || !u) && this._tTime === u && (c && !this._onUpdate && ea(this, r, !0, !0), (r || !d) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && ki(this, 1), !s && !(c && !o) && (u || o || y) && (Pt(this, u === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom())) } return this }, t.targets = function () { return this._targets }, t.invalidate = function (r) { return (!r || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(r), n.prototype.invalidate.call(this, r) }, t.resetTo = function (r, s, a, o, l) { bs || Mt.wake(), this._ts || this.play(); var d = Math.min(this._dur, (this._dp._time - this._start) * this._ts), c; return this._initted || Ia(this, d), c = this._ease(d / this._dur), nc(this, r, s, a, o, c, d, l) ? this.resetTo(r, s, a, o, 1) : (xn(this, 0), this.parent || tl(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, t.kill = function (r, s) { if (s === void 0 && (s = "all"), !r && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? Ur(this) : this; if (this.timeline) { var a = this.timeline.totalDuration(); return this.timeline.killTweensOf(r, s, Si && Si.vars.overwrite !== !0)._first || Ur(this), this.parent && a !== this.timeline.totalDuration() && Rr(this, this._dur * this.timeline._tDur / a, 0, 1), this } var o = this._targets, l = r ? Bt(r) : o, d = this._ptLookup, c = this._pt, u, f, p, m, h, g, y; if ((!s || s === "all") && Rd(o, l)) return s === "all" && (this._pt = 0), Ur(this); for (u = this._op = this._op || [], s !== "all" && (He(s) && (h = {}, vt(s, function (v) { return h[v] = 1 }), s = h), s = ac(o, s)), y = o.length; y--;)if (~l.indexOf(o[y])) { f = d[y], s === "all" ? (u[y] = s, m = f, p = {}) : (p = u[y] = u[y] || {}, m = s); for (h in m) g = f && f[h], g && ((!("kill" in g.d) || g.d.kill(h) === !0) && bn(this, g, "_pt"), delete f[h]), p !== "all" && (p[h] = 1) } return this._initted && !this._pt && c && Ur(this), this }, e.to = function (r, s) { return new e(r, s, arguments[2]) }, e.from = function (r, s) { return ns(1, arguments) }, e.delayedCall = function (r, s, a, o) { return new e(s, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: r, onComplete: s, onReverseComplete: s, onCompleteParams: a, onReverseCompleteParams: a, callbackScope: o }) }, e.fromTo = function (r, s, a) { return ns(2, arguments) }, e.set = function (r, s) { return s.duration = 0, s.repeatDelay || (s.repeat = 0), new e(r, s) }, e.killTweensOf = function (r, s, a) { return me.killTweensOf(r, s, a) }, e }(Ss); Ft(Me.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }); vt("staggerTo,staggerFrom,staggerFromTo", function (n) { Me[n] = function () { var e = new dt, t = ia.call(arguments, 0); return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t) } }); var Da = function (e, t, i) { return e[t] = i }, Tl = function (e, t, i) { return e[t](i) }, lc = function (e, t, i, r) { return e[t](r.fp, i) }, dc = function (e, t, i) { return e.setAttribute(t, i) }, za = function (e, t) { return _e(e[t]) ? Tl : Ea(e[t]) && e.setAttribute ? dc : Da }, El = function (e, t) { return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t) }, cc = function (e, t) { return t.set(t.t, t.p, !!(t.s + t.c * e), t) }, Ml = function (e, t) { var i = t._pt, r = ""; if (!e && t.b) r = t.b; else if (e === 1 && t.e) r = t.e; else { for (; i;)r = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + r, i = i._next; r += t.c } t.set(t.t, t.p, r, t) }, Ra = function (e, t) { for (var i = t._pt; i;)i.r(e, i.d), i = i._next }, uc = function (e, t, i, r) { for (var s = this._pt, a; s;)a = s._next, s.p === r && s.modifier(e, t, i), s = a }, fc = function (e) { for (var t = this._pt, i, r; t;)r = t._next, t.p === e && !t.op || t.op === e ? bn(this, t, "_pt") : t.dep || (i = 1), t = r; return !i }, pc = function (e, t, i, r) { r.mSet(e, t, r.m.call(r.tween, i, r.mt), r) }, Cl = function (e) { for (var t = e._pt, i, r, s, a; t;) { for (i = t._next, r = s; r && r.pr > t.pr;)r = r._next; (t._prev = r ? r._prev : a) ? t._prev._next = t : s = t, (t._next = r) ? r._prev = t : a = t, t = i } e._pt = s }, _t = function () { function n(t, i, r, s, a, o, l, d, c) { this.t = i, this.s = s, this.c = a, this.p = r, this.r = o || El, this.d = l || this, this.set = d || Da, this.pr = c || 0, this._next = t, t && (t._prev = this) } var e = n.prototype; return e.modifier = function (i, r, s) { this.mSet = this.mSet || this.set, this.set = pc, this.m = i, this.mt = s, this.tween = r }, n }(); vt(La + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (n) { return Aa[n] = 1 }); kt.TweenMax = kt.TweenLite = Me; kt.TimelineLite = kt.TimelineMax = dt; me = new dt({ sortChildren: !1, defaults: Dr, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }); Lt.stringFilter = gl; var ir = [], Ws = {}, hc = [], so = 0, mc = 0, In = function (e) { return (Ws[e] || hc).map(function (t) { return t() }) }, aa = function () { var e = Date.now(), t = []; e - so > 2 && (In("matchMediaInit"), ir.forEach(function (i) { var r = i.queries, s = i.conditions, a, o, l, d; for (o in r) a = It.matchMedia(r[o]).matches, a && (l = 1), a !== s[o] && (s[o] = a, d = 1); d && (i.revert(), l && t.push(i)) }), In("matchMediaRevert"), t.forEach(function (i) { return i.onMatch(i, function (r) { return i.add(null, r) }) }), so = e, In("matchMedia")) }, Pl = function () { function n(t, i) { this.selector = i && ra(i), this.data = [], this._r = [], this.isReverted = !1, this.id = mc++, t && this.add(t) } var e = n.prototype; return e.add = function (i, r, s) { _e(i) && (s = r, r = i, i = _e); var a = this, o = function () { var d = ve, c = a.selector, u; return d && d !== a && d.data.push(a), s && (a.selector = ra(s)), ve = a, u = r.apply(a, arguments), _e(u) && a._r.push(u), ve = d, a.selector = c, a.isReverted = !1, u }; return a.last = o, i === _e ? o(a, function (l) { return a.add(null, l) }) : i ? a[i] = o : o }, e.ignore = function (i) { var r = ve; ve = null, i(this), ve = r }, e.getTweens = function () { var i = []; return this.data.forEach(function (r) { return r instanceof n ? i.push.apply(i, r.getTweens()) : r instanceof Me && !(r.parent && r.parent.data === "nested") && i.push(r) }), i }, e.clear = function () { this._r.length = this.data.length = 0 }, e.kill = function (i, r) { var s = this; if (i ? function () { for (var o = s.getTweens(), l = s.data.length, d; l--;)d = s.data[l], d.data === "isFlip" && (d.revert(), d.getChildren(!0, !0, !1).forEach(function (c) { return o.splice(o.indexOf(c), 1) })); for (o.map(function (c) { return { g: c._dur || c._delay || c._sat && !c._sat.vars.immediateRender ? c.globalTime(0) : -1 / 0, t: c } }).sort(function (c, u) { return u.g - c.g || -1 / 0 }).forEach(function (c) { return c.t.revert(i) }), l = s.data.length; l--;)d = s.data[l], d instanceof dt ? d.data !== "nested" && (d.scrollTrigger && d.scrollTrigger.revert(), d.kill()) : !(d instanceof Me) && d.revert && d.revert(i); s._r.forEach(function (c) { return c(i, s) }), s.isReverted = !0 }() : this.data.forEach(function (o) { return o.kill && o.kill() }), this.clear(), r) for (var a = ir.length; a--;)ir[a].id === this.id && ir.splice(a, 1) }, e.revert = function (i) { this.kill(i || {}) }, n }(), gc = function () { function n(t) { this.contexts = [], this.scope = t } var e = n.prototype; return e.add = function (i, r, s) { ai(i) || (i = { matches: i }); var a = new Pl(0, s || this.scope), o = a.conditions = {}, l, d, c; ve && !a.selector && (a.selector = ve.selector), this.contexts.push(a), r = a.add("onMatch", r), a.queries = i; for (d in i) d === "all" ? c = 1 : (l = It.matchMedia(i[d]), l && (ir.indexOf(a) < 0 && ir.push(a), (o[d] = l.matches) && (c = 1), l.addListener ? l.addListener(aa) : l.addEventListener("change", aa))); return c && r(a, function (u) { return a.add(null, u) }), this }, e.revert = function (i) { this.kill(i || {}) }, e.kill = function (i) { this.contexts.forEach(function (r) { return r.kill(i, !0) }) }, n }(), ln = { registerPlugin: function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; t.forEach(function (r) { return pl(r) }) }, timeline: function (e) { return new dt(e) }, getTweensOf: function (e, t) { return me.getTweensOf(e, t) }, getProperty: function (e, t, i, r) { He(e) && (e = Bt(e)[0]); var s = Ji(e || {}).get, a = i ? el : Jo; return i === "native" && (i = ""), e && (t ? a((Tt[t] && Tt[t].get || s)(e, t, i, r)) : function (o, l, d) { return a((Tt[o] && Tt[o].get || s)(e, o, l, d)) }) }, quickSetter: function (e, t, i) { if (e = Bt(e), e.length > 1) { var r = e.map(function (c) { return wt.quickSetter(c, t, i) }), s = r.length; return function (c) { for (var u = s; u--;)r[u](c) } } e = e[0] || {}; var a = Tt[t], o = Ji(e), l = o.harness && (o.harness.aliases || {})[t] || t, d = a ? function (c) { var u = new a; Er._pt = 0, u.init(e, i ? c + i : c, Er, 0, [e]), u.render(1, u), Er._pt && Ra(1, Er) } : o.set(e, l); return a ? d : function (c) { return d(e, l, i ? c + i : c, o, 1) } }, quickTo: function (e, t, i) { var r, s = wt.to(e, lr((r = {}, r[t] = "+=0.1", r.paused = !0, r), i || {})), a = function (l, d, c) { return s.resetTo(t, l, d, c) }; return a.tween = s, a }, isTweening: function (e) { return me.getTweensOf(e, !0).length > 0 }, defaults: function (e) { return e && e.ease && (e.ease = tr(e.ease, Dr.ease)), Ja(Dr, e || {}) }, config: function (e) { return Ja(Lt, e || {}) }, registerEffect: function (e) { var t = e.name, i = e.effect, r = e.plugins, s = e.defaults, a = e.extendTimeline; (r || "").split(",").forEach(function (o) { return o && !Tt[o] && !kt[o] && _s(t + " effect requires " + o + " plugin.") }), An[t] = function (o, l, d) { return i(Bt(o), Ft(l || {}, s), d) }, a && (dt.prototype[t] = function (o, l, d) { return this.add(An[t](o, ai(l) ? l : (d = l) && {}, this), d) }) }, registerEase: function (e, t) { J[e] = tr(t) }, parseEase: function (e, t) { return arguments.length ? tr(e, t) : J }, getById: function (e) { return me.getById(e) }, exportRoot: function (e, t) { e === void 0 && (e = {}); var i = new dt(e), r, s; for (i.smoothChildTiming = gt(e.smoothChildTiming), me.remove(i), i._dp = 0, i._time = i._tTime = me._time, r = me._first; r;)s = r._next, (t || !(!r._dur && r instanceof Me && r.vars.onComplete === r._targets[0])) && ti(i, r, r._start - r._delay), r = s; return ti(me, i, 0), i }, context: function (e, t) { return e ? new Pl(e, t) : ve }, matchMedia: function (e) { return new gc(e) }, matchMediaRefresh: function () { return ir.forEach(function (e) { var t = e.conditions, i, r; for (r in t) t[r] && (t[r] = !1, i = 1); i && e.revert() }) || aa() }, addEventListener: function (e, t) { var i = Ws[e] || (Ws[e] = []); ~i.indexOf(t) || i.push(t) }, removeEventListener: function (e, t) { var i = Ws[e], r = i && i.indexOf(t); r >= 0 && i.splice(r, 1) }, utils: { wrap: jd, wrapYoyo: Ud, distribute: ol, random: dl, snap: ll, normalize: Wd, getUnit: Ze, clamp: Hd, splitColor: hl, toArray: Bt, selector: ra, mapRange: ul, pipe: Gd, unitize: Xd, interpolate: Kd, shuffle: al }, install: jo, effects: An, ticker: Mt, updateRoot: dt.updateRoot, plugins: Tt, globalTimeline: me, core: { PropTween: _t, globals: Uo, Tween: Me, Timeline: dt, Animation: Ss, getCache: Ji, _removeLinkedListItem: bn, reverting: function () { return Qe }, context: function (e) { return e && ve && (ve.data.push(e), e._ctx = ve), ve }, suppressOverwrites: function (e) { return Ta = e } } }; vt("to,from,fromTo,delayedCall,set,killTweensOf", function (n) { return ln[n] = Me[n] }); Mt.add(dt.updateRoot); Er = ln.to({}, { duration: 0 }); var vc = function (e, t) { for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t;)i = i._next; return i }, _c = function (e, t) { var i = e._targets, r, s, a; for (r in t) for (s = i.length; s--;)a = e._ptLookup[s][r], a && (a = a.d) && (a._pt && (a = vc(a, r)), a && a.modifier && a.modifier(t[r], e, i[s], r)) }, Dn = function (e, t) { return { name: e, rawVars: 1, init: function (r, s, a) { a._onInit = function (o) { var l, d; if (He(s) && (l = {}, vt(s, function (c) { return l[c] = 1 }), s = l), t) { l = {}; for (d in s) l[d] = t(s[d]); s = l } _c(o, s) } } } }, wt = ln.registerPlugin({ name: "attr", init: function (e, t, i, r, s) { var a, o, l; this.tween = i; for (a in t) l = e.getAttribute(a) || "", o = this.add(e, "setAttribute", (l || 0) + "", t[a], r, s, 0, 0, a), o.op = a, o.b = l, this._props.push(a) }, render: function (e, t) { for (var i = t._pt; i;)Qe ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next } }, { name: "endArray", init: function (e, t) { for (var i = t.length; i--;)this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1) } }, Dn("roundProps", sa), Dn("modifiers"), Dn("snap", ll)) || ln; Me.version = dt.version = wt.version = "3.12.4"; Wo = 1; Ma() && $r(); J.Power0; J.Power1; J.Power2; J.Power3; J.Power4; J.Linear; J.Quad; J.Cubic; J.Quart; J.Quint; J.Strong; J.Elastic; J.Back; J.SteppedEase; J.Bounce; J.Sine; J.Expo; J.Circ;/*!
 * CSSPlugin 3.12.4
 * https://gsap.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var no, xi, Ar, $a, Zi, ao, Ba, yc = function () { return typeof window < "u" }, gi = {}, Wi = 180 / Math.PI, Lr = Math.PI / 180, yr = Math.atan2, oo = 1e8, qa = /([A-Z])/g, wc = /(left|right|width|margin|padding|x)/i, bc = /[\s,\(]\S/, ii = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, oa = function (e, t) { return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t) }, Sc = function (e, t) { return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t) }, xc = function (e, t) { return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t) }, Tc = function (e, t) { var i = t.s + t.c * e; t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t) }, Al = function (e, t) { return t.set(t.t, t.p, e ? t.e : t.b, t) }, Ll = function (e, t) { return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t) }, Ec = function (e, t, i) { return e.style[t] = i }, Mc = function (e, t, i) { return e.style.setProperty(t, i) }, Cc = function (e, t, i) { return e._gsap[t] = i }, Pc = function (e, t, i) { return e._gsap.scaleX = e._gsap.scaleY = i }, Ac = function (e, t, i, r, s) { var a = e._gsap; a.scaleX = a.scaleY = i, a.renderTransform(s, a) }, Lc = function (e, t, i, r, s) { var a = e._gsap; a[t] = i, a.renderTransform(s, a) }, ge = "transform", yt = ge + "Origin", kc = function n(e, t) { var i = this, r = this.target, s = r.style, a = r._gsap; if (e in gi && s) { if (this.tfm = this.tfm || {}, e !== "transform") e = ii[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function (o) { return i.tfm[o] = ci(r, o) }) : this.tfm[e] = a.x ? a[e] : ci(r, e), e === yt && (this.tfm.zOrigin = a.zOrigin); else return ii.transform.split(",").forEach(function (o) { return n.call(i, o, t) }); if (this.props.indexOf(ge) >= 0) return; a.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(yt, t, "")), e = ge } (s || t) && this.props.push(e, t, s[e]) }, kl = function (e) { e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate")) }, Oc = function () { var e = this.props, t = this.target, i = t.style, r = t._gsap, s, a; for (s = 0; s < e.length; s += 3)e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? i[e[s]] = e[s + 2] : i.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(qa, "-$1").toLowerCase()); if (this.tfm) { for (a in this.tfm) r[a] = this.tfm[a]; r.svg && (r.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), s = Ba(), (!s || !s.isStart) && !i[ge] && (kl(i), r.zOrigin && i[yt] && (i[yt] += " " + r.zOrigin + "px", r.zOrigin = 0, r.renderTransform()), r.uncache = 1) } }, Ol = function (e, t) { var i = { target: e, props: [], revert: Oc, save: kc }; return e._gsap || wt.core.getCache(e), t && t.split(",").forEach(function (r) { return i.save(r) }), i }, Il, la = function (e, t) { var i = xi.createElementNS ? xi.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : xi.createElement(e); return i && i.style ? i : xi.createElement(e) }, si = function n(e, t, i) { var r = getComputedStyle(e); return r[t] || r.getPropertyValue(t.replace(qa, "-$1").toLowerCase()) || r.getPropertyValue(t) || !i && n(e, Br(t) || t, 1) || "" }, lo = "O,Moz,ms,Ms,Webkit".split(","), Br = function (e, t, i) { var r = t || Zi, s = r.style, a = 5; if (e in s && !i) return e; for (e = e.charAt(0).toUpperCase() + e.substr(1); a-- && !(lo[a] + e in s);); return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? lo[a] : "") + e }, da = function () { yc() && window.document && (no = window, xi = no.document, Ar = xi.documentElement, Zi = la("div") || { style: {} }, la("div"), ge = Br(ge), yt = ge + "Origin", Zi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Il = !!Br("perspective"), Ba = wt.core.reverting, $a = 1) }, zn = function n(e) { var t = la("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, r = this.nextSibling, s = this.style.cssText, a; if (Ar.appendChild(t), t.appendChild(this), this.style.display = "block", e) try { a = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = n } catch { } else this._gsapBBox && (a = this._gsapBBox()); return i && (r ? i.insertBefore(this, r) : i.appendChild(this)), Ar.removeChild(t), this.style.cssText = s, a }, co = function (e, t) { for (var i = t.length; i--;)if (e.hasAttribute(t[i])) return e.getAttribute(t[i]) }, Dl = function (e) { var t; try { t = e.getBBox() } catch { t = zn.call(e, !0) } return t && (t.width || t.height) || e.getBBox === zn || (t = zn.call(e, !0)), t && !t.width && !t.x && !t.y ? { x: +co(e, ["x", "cx", "x1"]) || 0, y: +co(e, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } : t }, zl = function (e) { return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && Dl(e)) }, dr = function (e, t) { if (t) { var i = e.style, r; t in gi && t !== yt && (t = ge), i.removeProperty ? (r = t.substr(0, 2), (r === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), i.removeProperty(r === "--" ? t : t.replace(qa, "-$1").toLowerCase())) : i.removeAttribute(t) } }, Ti = function (e, t, i, r, s, a) { var o = new _t(e._pt, t, i, 0, 1, a ? Ll : Al); return e._pt = o, o.b = r, o.e = s, e._props.push(i), o }, uo = { deg: 1, rad: 1, turn: 1 }, Ic = { grid: 1, flex: 1 }, Oi = function n(e, t, i, r) { var s = parseFloat(i) || 0, a = (i + "").trim().substr((s + "").length) || "px", o = Zi.style, l = wc.test(t), d = e.tagName.toLowerCase() === "svg", c = (d ? "client" : "offset") + (l ? "Width" : "Height"), u = 100, f = r === "px", p = r === "%", m, h, g, y; if (r === a || !s || uo[r] || uo[a]) return s; if (a !== "px" && !f && (s = n(e, t, i, "px")), y = e.getCTM && zl(e), (p || a === "%") && (gi[t] || ~t.indexOf("adius"))) return m = y ? e.getBBox()[l ? "width" : "height"] : e[c], Se(p ? s / m * u : s / 100 * m); if (o[l ? "width" : "height"] = u + (f ? a : r), h = ~t.indexOf("adius") || r === "em" && e.appendChild && !d ? e : e.parentNode, y && (h = (e.ownerSVGElement || {}).parentNode), (!h || h === xi || !h.appendChild) && (h = xi.body), g = h._gsap, g && p && g.width && l && g.time === Mt.time && !g.uncache) return Se(s / g.width * u); if (p && (t === "height" || t === "width")) { var v = e.style[t]; e.style[t] = u + r, m = e[c], v ? e.style[t] = v : dr(e, t) } else (p || a === "%") && !Ic[si(h, "display")] && (o.position = si(e, "position")), h === e && (o.position = "static"), h.appendChild(Zi), m = Zi[c], h.removeChild(Zi), o.position = "absolute"; return l && p && (g = Ji(h), g.time = Mt.time, g.width = h[c]), Se(f ? m * s / u : m && s ? u / m * s : 0) }, ci = function (e, t, i, r) { var s; return $a || da(), t in ii && t !== "transform" && (t = ii[t], ~t.indexOf(",") && (t = t.split(",")[0])), gi[t] && t !== "transform" ? (s = Ts(e, r), s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : cn(si(e, yt)) + " " + s.zOrigin + "px") : (s = e.style[t], (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) && (s = dn[t] && dn[t](e, t, i) || si(e, t) || Zo(e, t) || (t === "opacity" ? 1 : 0))), i && !~(s + "").trim().indexOf(" ") ? Oi(e, t, s, i) + i : s }, Dc = function (e, t, i, r) { if (!i || i === "none") { var s = Br(t, e, 1), a = s && si(e, s, 1); a && a !== i ? (t = s, i = a) : t === "borderColor" && (i = si(e, "borderTopColor")) } var o = new _t(this._pt, e.style, t, 0, 1, Ml), l = 0, d = 0, c, u, f, p, m, h, g, y, v, _, w, S; if (o.b = i, o.e = r, i += "", r += "", r === "auto" && (h = e.style[t], e.style[t] = r, r = si(e, t) || r, h ? e.style[t] = h : dr(e, t)), c = [i, r], gl(c), i = c[0], r = c[1], f = i.match(Tr) || [], S = r.match(Tr) || [], S.length) { for (; u = Tr.exec(r);)g = u[0], v = r.substring(l, u.index), m ? m = (m + 1) % 5 : (v.substr(-5) === "rgba(" || v.substr(-5) === "hsla(") && (m = 1), g !== (h = f[d++] || "") && (p = parseFloat(h) || 0, w = h.substr((p + "").length), g.charAt(1) === "=" && (g = Pr(p, g) + w), y = parseFloat(g), _ = g.substr((y + "").length), l = Tr.lastIndex - _.length, _ || (_ = _ || Lt.units[t] || w, l === r.length && (r += _, o.e += _)), w !== _ && (p = Oi(e, t, h, _) || 0), o._pt = { _next: o._pt, p: v || d === 1 ? v : ",", s: p, c: y - p, m: m && m < 4 || t === "zIndex" ? Math.round : 0 }); o.c = l < r.length ? r.substring(l, r.length) : "" } else o.r = t === "display" && r === "none" ? Ll : Al; return Go.test(r) && (o.e = 0), this._pt = o, o }, fo = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, zc = function (e) { var t = e.split(" "), i = t[0], r = t[1] || "50%"; return (i === "top" || i === "bottom" || r === "left" || r === "right") && (e = i, i = r, r = e), t[0] = fo[i] || i, t[1] = fo[r] || r, t.join(" ") }, Rc = function (e, t) { if (t.tween && t.tween._time === t.tween._dur) { var i = t.t, r = i.style, s = t.u, a = i._gsap, o, l, d; if (s === "all" || s === !0) r.cssText = "", l = 1; else for (s = s.split(","), d = s.length; --d > -1;)o = s[d], gi[o] && (l = 1, o = o === "transformOrigin" ? yt : ge), dr(i, o); l && (dr(i, ge), a && (a.svg && i.removeAttribute("transform"), Ts(i, 1), a.uncache = 1, kl(r))) } }, dn = { clearProps: function (e, t, i, r, s) { if (s.data !== "isFromStart") { var a = e._pt = new _t(e._pt, t, i, 0, 0, Rc); return a.u = r, a.pr = -10, a.tween = s, e._props.push(i), 1 } } }, xs = [1, 0, 0, 1, 0, 0], Rl = {}, $l = function (e) { return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e }, po = function (e) { var t = si(e, ge); return $l(t) ? xs : t.substr(7).match(Vo).map(Se) }, Fa = function (e, t) { var i = e._gsap || Ji(e), r = e.style, s = po(e), a, o, l, d; return i.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, s = [l.a, l.b, l.c, l.d, l.e, l.f], s.join(",") === "1,0,0,1,0,0" ? xs : s) : (s === xs && !e.offsetParent && e !== Ar && !i.svg && (l = r.display, r.display = "block", a = e.parentNode, (!a || !e.offsetParent) && (d = 1, o = e.nextElementSibling, Ar.appendChild(e)), s = po(e), l ? r.display = l : dr(e, "display"), d && (o ? a.insertBefore(e, o) : a ? a.appendChild(e) : Ar.removeChild(e))), t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s) }, ca = function (e, t, i, r, s, a) { var o = e._gsap, l = s || Fa(e, !0), d = o.xOrigin || 0, c = o.yOrigin || 0, u = o.xOffset || 0, f = o.yOffset || 0, p = l[0], m = l[1], h = l[2], g = l[3], y = l[4], v = l[5], _ = t.split(" "), w = parseFloat(_[0]) || 0, S = parseFloat(_[1]) || 0, x, P, L, M; i ? l !== xs && (P = p * g - m * h) && (L = w * (g / P) + S * (-h / P) + (h * v - g * y) / P, M = w * (-m / P) + S * (p / P) - (p * v - m * y) / P, w = L, S = M) : (x = Dl(e), w = x.x + (~_[0].indexOf("%") ? w / 100 * x.width : w), S = x.y + (~(_[1] || _[0]).indexOf("%") ? S / 100 * x.height : S)), r || r !== !1 && o.smooth ? (y = w - d, v = S - c, o.xOffset = u + (y * p + v * h) - y, o.yOffset = f + (y * m + v * g) - v) : o.xOffset = o.yOffset = 0, o.xOrigin = w, o.yOrigin = S, o.smooth = !!r, o.origin = t, o.originIsAbsolute = !!i, e.style[yt] = "0px 0px", a && (Ti(a, o, "xOrigin", d, w), Ti(a, o, "yOrigin", c, S), Ti(a, o, "xOffset", u, o.xOffset), Ti(a, o, "yOffset", f, o.yOffset)), e.setAttribute("data-svg-origin", w + " " + S) }, Ts = function (e, t) { var i = e._gsap || new wl(e); if ("x" in i && !t && !i.uncache) return i; var r = e.style, s = i.scaleX < 0, a = "px", o = "deg", l = getComputedStyle(e), d = si(e, yt) || "0", c, u, f, p, m, h, g, y, v, _, w, S, x, P, L, M, E, O, C, k, b, A, z, I, D, R, T, N, ie, F, Y, se; return c = u = f = h = g = y = v = _ = w = 0, p = m = 1, i.svg = !!(e.getCTM && zl(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (r[ge] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[ge] !== "none" ? l[ge] : "")), r.scale = r.rotate = r.translate = "none"), P = Fa(e, i.svg), i.svg && (i.uncache ? (D = e.getBBox(), d = i.xOrigin - D.x + "px " + (i.yOrigin - D.y) + "px", I = "") : I = !t && e.getAttribute("data-svg-origin"), ca(e, I || d, !!I || i.originIsAbsolute, i.smooth !== !1, P)), S = i.xOrigin || 0, x = i.yOrigin || 0, P !== xs && (O = P[0], C = P[1], k = P[2], b = P[3], c = A = P[4], u = z = P[5], P.length === 6 ? (p = Math.sqrt(O * O + C * C), m = Math.sqrt(b * b + k * k), h = O || C ? yr(C, O) * Wi : 0, v = k || b ? yr(k, b) * Wi + h : 0, v && (m *= Math.abs(Math.cos(v * Lr))), i.svg && (c -= S - (S * O + x * k), u -= x - (S * C + x * b))) : (se = P[6], F = P[7], T = P[8], N = P[9], ie = P[10], Y = P[11], c = P[12], u = P[13], f = P[14], L = yr(se, ie), g = L * Wi, L && (M = Math.cos(-L), E = Math.sin(-L), I = A * M + T * E, D = z * M + N * E, R = se * M + ie * E, T = A * -E + T * M, N = z * -E + N * M, ie = se * -E + ie * M, Y = F * -E + Y * M, A = I, z = D, se = R), L = yr(-k, ie), y = L * Wi, L && (M = Math.cos(-L), E = Math.sin(-L), I = O * M - T * E, D = C * M - N * E, R = k * M - ie * E, Y = b * E + Y * M, O = I, C = D, k = R), L = yr(C, O), h = L * Wi, L && (M = Math.cos(L), E = Math.sin(L), I = O * M + C * E, D = A * M + z * E, C = C * M - O * E, z = z * M - A * E, O = I, A = D), g && Math.abs(g) + Math.abs(h) > 359.9 && (g = h = 0, y = 180 - y), p = Se(Math.sqrt(O * O + C * C + k * k)), m = Se(Math.sqrt(z * z + se * se)), L = yr(A, z), v = Math.abs(L) > 2e-4 ? L * Wi : 0, w = Y ? 1 / (Y < 0 ? -Y : Y) : 0), i.svg && (I = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !$l(si(e, ge)), I && e.setAttribute("transform", I))), Math.abs(v) > 90 && Math.abs(v) < 270 && (s ? (p *= -1, v += h <= 0 ? 180 : -180, h += h <= 0 ? 180 : -180) : (m *= -1, v += v <= 0 ? 180 : -180)), t = t || i.uncache, i.x = c - ((i.xPercent = c && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-c) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + a, i.y = u - ((i.yPercent = u && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + a, i.z = f + a, i.scaleX = Se(p), i.scaleY = Se(m), i.rotation = Se(h) + o, i.rotationX = Se(g) + o, i.rotationY = Se(y) + o, i.skewX = v + o, i.skewY = _ + o, i.transformPerspective = w + a, (i.zOrigin = parseFloat(d.split(" ")[2]) || !t && i.zOrigin || 0) && (r[yt] = cn(d)), i.xOffset = i.yOffset = 0, i.force3D = Lt.force3D, i.renderTransform = i.svg ? Bc : Il ? Bl : $c, i.uncache = 0, i }, cn = function (e) { return (e = e.split(" "))[0] + " " + e[1] }, Rn = function (e, t, i) { var r = Ze(t); return Se(parseFloat(t) + parseFloat(Oi(e, "x", i + "px", r))) + r }, $c = function (e, t) { t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Bl(e, t) }, Gi = "0deg", Xr = "0px", Xi = ") ", Bl = function (e, t) { var i = t || this, r = i.xPercent, s = i.yPercent, a = i.x, o = i.y, l = i.z, d = i.rotation, c = i.rotationY, u = i.rotationX, f = i.skewX, p = i.skewY, m = i.scaleX, h = i.scaleY, g = i.transformPerspective, y = i.force3D, v = i.target, _ = i.zOrigin, w = "", S = y === "auto" && e && e !== 1 || y === !0; if (_ && (u !== Gi || c !== Gi)) { var x = parseFloat(c) * Lr, P = Math.sin(x), L = Math.cos(x), M; x = parseFloat(u) * Lr, M = Math.cos(x), a = Rn(v, a, P * M * -_), o = Rn(v, o, -Math.sin(x) * -_), l = Rn(v, l, L * M * -_ + _) } g !== Xr && (w += "perspective(" + g + Xi), (r || s) && (w += "translate(" + r + "%, " + s + "%) "), (S || a !== Xr || o !== Xr || l !== Xr) && (w += l !== Xr || S ? "translate3d(" + a + ", " + o + ", " + l + ") " : "translate(" + a + ", " + o + Xi), d !== Gi && (w += "rotate(" + d + Xi), c !== Gi && (w += "rotateY(" + c + Xi), u !== Gi && (w += "rotateX(" + u + Xi), (f !== Gi || p !== Gi) && (w += "skew(" + f + ", " + p + Xi), (m !== 1 || h !== 1) && (w += "scale(" + m + ", " + h + Xi), v.style[ge] = w || "translate(0, 0)" }, Bc = function (e, t) { var i = t || this, r = i.xPercent, s = i.yPercent, a = i.x, o = i.y, l = i.rotation, d = i.skewX, c = i.skewY, u = i.scaleX, f = i.scaleY, p = i.target, m = i.xOrigin, h = i.yOrigin, g = i.xOffset, y = i.yOffset, v = i.forceCSS, _ = parseFloat(a), w = parseFloat(o), S, x, P, L, M; l = parseFloat(l), d = parseFloat(d), c = parseFloat(c), c && (c = parseFloat(c), d += c, l += c), l || d ? (l *= Lr, d *= Lr, S = Math.cos(l) * u, x = Math.sin(l) * u, P = Math.sin(l - d) * -f, L = Math.cos(l - d) * f, d && (c *= Lr, M = Math.tan(d - c), M = Math.sqrt(1 + M * M), P *= M, L *= M, c && (M = Math.tan(c), M = Math.sqrt(1 + M * M), S *= M, x *= M)), S = Se(S), x = Se(x), P = Se(P), L = Se(L)) : (S = u, L = f, x = P = 0), (_ && !~(a + "").indexOf("px") || w && !~(o + "").indexOf("px")) && (_ = Oi(p, "x", a, "px"), w = Oi(p, "y", o, "px")), (m || h || g || y) && (_ = Se(_ + m - (m * S + h * P) + g), w = Se(w + h - (m * x + h * L) + y)), (r || s) && (M = p.getBBox(), _ = Se(_ + r / 100 * M.width), w = Se(w + s / 100 * M.height)), M = "matrix(" + S + "," + x + "," + P + "," + L + "," + _ + "," + w + ")", p.setAttribute("transform", M), v && (p.style[ge] = M) }, qc = function (e, t, i, r, s) { var a = 360, o = He(s), l = parseFloat(s) * (o && ~s.indexOf("rad") ? Wi : 1), d = l - r, c = r + d + "deg", u, f; return o && (u = s.split("_")[1], u === "short" && (d %= a, d !== d % (a / 2) && (d += d < 0 ? a : -a)), u === "cw" && d < 0 ? d = (d + a * oo) % a - ~~(d / a) * a : u === "ccw" && d > 0 && (d = (d - a * oo) % a - ~~(d / a) * a)), e._pt = f = new _t(e._pt, t, i, r, d, Sc), f.e = c, f.u = "deg", e._props.push(i), f }, ho = function (e, t) { for (var i in t) e[i] = t[i]; return e }, Fc = function (e, t, i) { var r = ho({}, i._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", a = i.style, o, l, d, c, u, f, p, m; r.svg ? (d = i.getAttribute("transform"), i.setAttribute("transform", ""), a[ge] = t, o = Ts(i, 1), dr(i, ge), i.setAttribute("transform", d)) : (d = getComputedStyle(i)[ge], a[ge] = t, o = Ts(i, 1), a[ge] = d); for (l in gi) d = r[l], c = o[l], d !== c && s.indexOf(l) < 0 && (p = Ze(d), m = Ze(c), u = p !== m ? Oi(i, l, d, m) : parseFloat(d), f = parseFloat(c), e._pt = new _t(e._pt, o, l, u, f - u, oa), e._pt.u = m || 0, e._props.push(l)); ho(o, r) }; vt("padding,margin,Width,Radius", function (n, e) { var t = "Top", i = "Right", r = "Bottom", s = "Left", a = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function (o) { return e < 2 ? n + o : "border" + o + n }); dn[e > 1 ? "border" + n : n] = function (o, l, d, c, u) { var f, p; if (arguments.length < 4) return f = a.map(function (m) { return ci(o, m, d) }), p = f.join(" "), p.split(f[0]).length === 5 ? f[0] : p; f = (c + "").split(" "), p = {}, a.forEach(function (m, h) { return p[m] = f[h] = f[h] || f[(h - 1) / 2 | 0] }), o.init(l, p, u) } }); var ql = { name: "css", register: da, targetTest: function (e) { return e.style && e.nodeType }, init: function (e, t, i, r, s) { var a = this._props, o = e.style, l = i.vars.startAt, d, c, u, f, p, m, h, g, y, v, _, w, S, x, P, L; $a || da(), this.styles = this.styles || Ol(e), L = this.styles.props, this.tween = i; for (h in t) if (h !== "autoRound" && (c = t[h], !(Tt[h] && bl(h, t, i, r, e, s)))) { if (p = typeof c, m = dn[h], p === "function" && (c = c.call(i, r, e, s), p = typeof c), p === "string" && ~c.indexOf("random(") && (c = ws(c)), m) m(this, e, h, c, i) && (P = 1); else if (h.substr(0, 2) === "--") d = (getComputedStyle(e).getPropertyValue(h) + "").trim(), c += "", Ai.lastIndex = 0, Ai.test(d) || (g = Ze(d), y = Ze(c)), y ? g !== y && (d = Oi(e, h, d, y) + y) : g && (c += g), this.add(o, "setProperty", d, c, r, s, 0, 0, h), a.push(h), L.push(h, 0, o[h]); else if (p !== "undefined") { if (l && h in l ? (d = typeof l[h] == "function" ? l[h].call(i, r, e, s) : l[h], He(d) && ~d.indexOf("random(") && (d = ws(d)), Ze(d + "") || d === "auto" || (d += Lt.units[h] || Ze(ci(e, h)) || ""), (d + "").charAt(1) === "=" && (d = ci(e, h))) : d = ci(e, h), f = parseFloat(d), v = p === "string" && c.charAt(1) === "=" && c.substr(0, 2), v && (c = c.substr(2)), u = parseFloat(c), h in ii && (h === "autoAlpha" && (f === 1 && ci(e, "visibility") === "hidden" && u && (f = 0), L.push("visibility", 0, o.visibility), Ti(this, o, "visibility", f ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), h !== "scale" && h !== "transform" && (h = ii[h], ~h.indexOf(",") && (h = h.split(",")[0]))), _ = h in gi, _) { if (this.styles.save(h), w || (S = e._gsap, S.renderTransform && !t.parseTransform || Ts(e, t.parseTransform), x = t.smoothOrigin !== !1 && S.smooth, w = this._pt = new _t(this._pt, o, ge, 0, 1, S.renderTransform, S, 0, -1), w.dep = 1), h === "scale") this._pt = new _t(this._pt, S, "scaleY", S.scaleY, (v ? Pr(S.scaleY, v + u) : u) - S.scaleY || 0, oa), this._pt.u = 0, a.push("scaleY", h), h += "X"; else if (h === "transformOrigin") { L.push(yt, 0, o[yt]), c = zc(c), S.svg ? ca(e, c, 0, x, 0, this) : (y = parseFloat(c.split(" ")[2]) || 0, y !== S.zOrigin && Ti(this, S, "zOrigin", S.zOrigin, y), Ti(this, o, h, cn(d), cn(c))); continue } else if (h === "svgOrigin") { ca(e, c, 1, x, 0, this); continue } else if (h in Rl) { qc(this, S, h, f, v ? Pr(f, v + c) : c); continue } else if (h === "smoothOrigin") { Ti(this, S, "smooth", S.smooth, c); continue } else if (h === "force3D") { S[h] = c; continue } else if (h === "transform") { Fc(this, c, e); continue } } else h in o || (h = Br(h) || h); if (_ || (u || u === 0) && (f || f === 0) && !bc.test(c) && h in o) g = (d + "").substr((f + "").length), u || (u = 0), y = Ze(c) || (h in Lt.units ? Lt.units[h] : g), g !== y && (f = Oi(e, h, d, y)), this._pt = new _t(this._pt, _ ? S : o, h, f, (v ? Pr(f, v + u) : u) - f, !_ && (y === "px" || h === "zIndex") && t.autoRound !== !1 ? Tc : oa), this._pt.u = y || 0, g !== y && y !== "%" && (this._pt.b = d, this._pt.r = xc); else if (h in o) Dc.call(this, e, h, d, v ? v + c : c); else if (h in e) this.add(e, h, d || e[h], v ? v + c : c, r, s); else if (h !== "parseTransform") { Pa(h, c); continue } _ || (h in o ? L.push(h, 0, o[h]) : L.push(h, 1, d || e[h])), a.push(h) } } P && Cl(this) }, render: function (e, t) { if (t.tween._time || !Ba()) for (var i = t._pt; i;)i.r(e, i.d), i = i._next; else t.styles.revert() }, get: ci, aliases: ii, getSetter: function (e, t, i) { var r = ii[t]; return r && r.indexOf(",") < 0 && (t = r), t in gi && t !== yt && (e._gsap.x || ci(e, "x")) ? i && ao === i ? t === "scale" ? Pc : Cc : (ao = i || {}) && (t === "scale" ? Ac : Lc) : e.style && !Ea(e.style[t]) ? Ec : ~t.indexOf("-") ? Mc : za(e, t) }, core: { _removeProperty: dr, _getMatrix: Fa } }; wt.utils.checkPrefix = Br; wt.core.getStyleSaver = Ol; (function (n, e, t, i) { var r = vt(n + "," + e + "," + t, function (s) { gi[s] = 1 }); vt(e, function (s) { Lt.units[s] = "deg", Rl[s] = 1 }), ii[r[13]] = n + "," + e, vt(i, function (s) { var a = s.split(":"); ii[a[1]] = r[a[0]] }) })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"); vt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (n) { Lt.units[n] = "px" }); wt.registerPlugin(ql); var Tn = wt.registerPlugin(ql) || wt; Tn.core.Tween; function mo(n, e) { for (var t = 0; t < e.length; t++) { var i = e[t]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, i.key, i) } } function Nc(n, e, t) { return e && mo(n.prototype, e), t && mo(n, t), n }/*!
 * Observer 3.12.4
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Xe, js, Ct, Ei, Mi, kr, Fl, ji, os, Nl, pi, jt, Yl, Hl = function () { return Xe || typeof window < "u" && (Xe = window.gsap) && Xe.registerPlugin && Xe }, Vl = 1, Mr = [], K = [], ni = [], ls = Date.now, ua = function (e, t) { return t }, Yc = function () { var e = os.core, t = e.bridge || {}, i = e._scrollers, r = e._proxies; i.push.apply(i, K), r.push.apply(r, ni), K = i, ni = r, ua = function (a, o) { return t[a](o) } }, Li = function (e, t) { return ~ni.indexOf(e) && ni[ni.indexOf(e) + 1][t] }, ds = function (e) { return !!~Nl.indexOf(e) }, st = function (e, t, i, r, s) { return e.addEventListener(t, i, { passive: !r, capture: !!s }) }, rt = function (e, t, i, r) { return e.removeEventListener(t, i, !!r) }, Is = "scrollLeft", Ds = "scrollTop", fa = function () { return pi && pi.isPressed || K.cache++ }, un = function (e, t) { var i = function r(s) { if (s || s === 0) { Vl && (Ct.history.scrollRestoration = "manual"); var a = pi && pi.isPressed; s = r.v = Math.round(s) || (pi && pi.iOS ? 1 : 0), e(s), r.cacheID = K.cache, a && ua("ss", s) } else (t || K.cache !== r.cacheID || ua("ref")) && (r.cacheID = K.cache, r.v = e()); return r.v + r.offset }; return i.offset = 0, e && i }, ct = { s: Is, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: un(function (n) { return arguments.length ? Ct.scrollTo(n, Oe.sc()) : Ct.pageXOffset || Ei[Is] || Mi[Is] || kr[Is] || 0 }) }, Oe = { s: Ds, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: ct, sc: un(function (n) { return arguments.length ? Ct.scrollTo(ct.sc(), n) : Ct.pageYOffset || Ei[Ds] || Mi[Ds] || kr[Ds] || 0 }) }, mt = function (e, t) { return (t && t._ctx && t._ctx.selector || Xe.utils.toArray)(e)[0] || (typeof e == "string" && Xe.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null) }, Ii = function (e, t) { var i = t.s, r = t.sc; ds(e) && (e = Ei.scrollingElement || Mi); var s = K.indexOf(e), a = r === Oe.sc ? 1 : 2; !~s && (s = K.push(e) - 1), K[s + a] || st(e, "scroll", fa); var o = K[s + a], l = o || (K[s + a] = un(Li(e, i), !0) || (ds(e) ? r : un(function (d) { return arguments.length ? e[i] = d : e[i] }))); return l.target = e, o || (l.smooth = Xe.getProperty(e, "scrollBehavior") === "smooth"), l }, pa = function (e, t, i) { var r = e, s = e, a = ls(), o = a, l = t || 50, d = Math.max(500, l * 3), c = function (m, h) { var g = ls(); h || g - a > l ? (s = r, r = m, o = a, a = g) : i ? r += m : r = s + (m - s) / (g - o) * (a - o) }, u = function () { s = r = i ? 0 : r, o = a = 0 }, f = function (m) { var h = o, g = s, y = ls(); return (m || m === 0) && m !== r && c(m), a === o || y - o > d ? 0 : (r + (i ? g : -g)) / ((i ? y : a) - h) * 1e3 }; return { update: c, reset: u, getVelocity: f } }, Wr = function (e, t) { return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e }, go = function (e) { var t = Math.max.apply(Math, e), i = Math.min.apply(Math, e); return Math.abs(t) >= Math.abs(i) ? t : i }, Gl = function () { os = Xe.core.globals().ScrollTrigger, os && os.core && Yc() }, Xl = function (e) { return Xe = e || Hl(), !js && Xe && typeof document < "u" && document.body && (Ct = window, Ei = document, Mi = Ei.documentElement, kr = Ei.body, Nl = [Ct, Ei, Mi, kr], Xe.utils.clamp, Yl = Xe.core.context || function () { }, ji = "onpointerenter" in kr ? "pointer" : "mouse", Fl = Ce.isTouch = Ct.matchMedia && Ct.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Ct || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, jt = Ce.eventTypes = ("ontouchstart" in Mi ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Mi ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () { return Vl = 0 }, 500), Gl(), js = 1), js }; ct.op = Oe; K.cache = 0; var Ce = function () { function n(t) { this.init(t) } var e = n.prototype; return e.init = function (i) { js || Xl(Xe) || console.warn("Please gsap.registerPlugin(Observer)"), os || Gl(); var r = i.tolerance, s = i.dragMinimum, a = i.type, o = i.target, l = i.lineHeight, d = i.debounce, c = i.preventDefault, u = i.onStop, f = i.onStopDelay, p = i.ignore, m = i.wheelSpeed, h = i.event, g = i.onDragStart, y = i.onDragEnd, v = i.onDrag, _ = i.onPress, w = i.onRelease, S = i.onRight, x = i.onLeft, P = i.onUp, L = i.onDown, M = i.onChangeX, E = i.onChangeY, O = i.onChange, C = i.onToggleX, k = i.onToggleY, b = i.onHover, A = i.onHoverEnd, z = i.onMove, I = i.ignoreCheck, D = i.isNormalizer, R = i.onGestureStart, T = i.onGestureEnd, N = i.onWheel, ie = i.onEnable, F = i.onDisable, Y = i.onClick, se = i.scrollSpeed, de = i.capture, ne = i.allowClicks, Ie = i.lockAxis, Pe = i.onLockAxis; this.target = o = mt(o) || Mi, this.vars = i, p && (p = Xe.utils.toArray(p)), r = r || 1e-9, s = s || 0, m = m || 1, se = se || 1, a = a || "wheel,touch,pointer", d = d !== !1, l || (l = parseFloat(Ct.getComputedStyle(kr).lineHeight) || 22); var Nt, De, et, W, ue, ze, Ve, $ = this, Ae = 0, tt = 0, Ri = Ii(o, ct), xe = Ii(o, Oe), $i = Ri(), Bi = xe(), Yr = ~a.indexOf("touch") && !~a.indexOf("pointer") && jt[0] === "pointerdown", Le = ds(o), we = o.ownerDocument || Ei, Yt = [0, 0, 0], Ht = [0, 0, 0], qi = 0, oi = function () { return qi = ls() }, Kt = function (H, re) { return ($.event = H) && p && ~p.indexOf(H.target) || re && Yr && H.pointerType !== "touch" || I && I(H, re) }, pt = function () { $._vx.reset(), $._vy.reset(), De.pause(), u && u($) }, Fi = function () { var H = $.deltaX = go(Yt), re = $.deltaY = go(Ht), Te = Math.abs(H) >= r, B = Math.abs(re) >= r; O && (Te || B) && O($, H, re, Yt, Ht), Te && (S && $.deltaX > 0 && S($), x && $.deltaX < 0 && x($), M && M($), C && $.deltaX < 0 != Ae < 0 && C($), Ae = $.deltaX, Yt[0] = Yt[1] = Yt[2] = 0), B && (L && $.deltaY > 0 && L($), P && $.deltaY < 0 && P($), E && E($), k && $.deltaY < 0 != tt < 0 && k($), tt = $.deltaY, Ht[0] = Ht[1] = Ht[2] = 0), (W || et) && (z && z($), et && (v($), et = !1), W = !1), ze && !(ze = !1) && Pe && Pe($), ue && (N($), ue = !1), Nt = 0 }, gr = function (H, re, Te) { Yt[Te] += H, Ht[Te] += re, $._vx.update(H), $._vy.update(re), d ? Nt || (Nt = requestAnimationFrame(Fi)) : Fi() }, vr = function (H, re) { Ie && !Ve && ($.axis = Ve = Math.abs(H) > Math.abs(re) ? "x" : "y", ze = !0), Ve !== "y" && (Yt[2] += H, $._vx.update(H, !0)), Ve !== "x" && (Ht[2] += re, $._vy.update(re, !0)), d ? Nt || (Nt = requestAnimationFrame(Fi)) : Fi() }, Ni = function (H) { if (!Kt(H, 1)) { H = Wr(H, c); var re = H.clientX, Te = H.clientY, B = re - $.x, j = Te - $.y, V = $.isDragging; $.x = re, $.y = Te, (V || Math.abs($.startX - re) >= s || Math.abs($.startY - Te) >= s) && (v && (et = !0), V || ($.isDragging = !0), vr(B, j), V || g && g($)) } }, vi = $.onPress = function (G) { Kt(G, 1) || G && G.button || ($.axis = Ve = null, De.pause(), $.isPressed = !0, G = Wr(G), Ae = tt = 0, $.startX = $.x = G.clientX, $.startY = $.y = G.clientY, $._vx.reset(), $._vy.reset(), st(D ? o : we, jt[1], Ni, c, !0), $.deltaX = $.deltaY = 0, _ && _($)) }, _i = $.onRelease = function (G) { if (!Kt(G, 1)) { rt(D ? o : we, jt[1], Ni, !0); var H = !isNaN($.y - $.startY), re = $.isDragging, Te = re && (Math.abs($.x - $.startX) > 3 || Math.abs($.y - $.startY) > 3), B = Wr(G); !Te && H && ($._vx.reset(), $._vy.reset(), c && ne && Xe.delayedCall(.08, function () { if (ls() - qi > 300 && !G.defaultPrevented) { if (G.target.click) G.target.click(); else if (we.createEvent) { var j = we.createEvent("MouseEvents"); j.initMouseEvent("click", !0, !0, Ct, 1, B.screenX, B.screenY, B.clientX, B.clientY, !1, !1, !1, !1, 0, null), G.target.dispatchEvent(j) } } })), $.isDragging = $.isGesturing = $.isPressed = !1, u && re && !D && De.restart(!0), y && re && y($), w && w($, Te) } }, ee = function (H) { return H.touches && H.touches.length > 1 && ($.isGesturing = !0) && R(H, $.isDragging) }, Yi = function () { return ($.isGesturing = !1) || T($) }, Vt = function (H) { if (!Kt(H)) { var re = Ri(), Te = xe(); gr((re - $i) * se, (Te - Bi) * se, 1), $i = re, Bi = Te, u && De.restart(!0) } }, Gt = function (H) { if (!Kt(H)) { H = Wr(H, c), N && (ue = !0); var re = (H.deltaMode === 1 ? l : H.deltaMode === 2 ? Ct.innerHeight : 1) * m; gr(H.deltaX * re, H.deltaY * re, 0), u && !D && De.restart(!0) } }, Xt = function (H) { if (!Kt(H)) { var re = H.clientX, Te = H.clientY, B = re - $.x, j = Te - $.y; $.x = re, $.y = Te, W = !0, u && De.restart(!0), (B || j) && vr(B, j) } }, Hi = function (H) { $.event = H, b($) }, _r = function (H) { $.event = H, A($) }, li = function (H) { return Kt(H) || Wr(H, c) && Y($) }; De = $._dc = Xe.delayedCall(f || .25, pt).pause(), $.deltaX = $.deltaY = 0, $._vx = pa(0, 50, !0), $._vy = pa(0, 50, !0), $.scrollX = Ri, $.scrollY = xe, $.isDragging = $.isGesturing = $.isPressed = !1, Yl(this), $.enable = function (G) { return $.isEnabled || (st(Le ? we : o, "scroll", fa), a.indexOf("scroll") >= 0 && st(Le ? we : o, "scroll", Vt, c, de), a.indexOf("wheel") >= 0 && st(o, "wheel", Gt, c, de), (a.indexOf("touch") >= 0 && Fl || a.indexOf("pointer") >= 0) && (st(o, jt[0], vi, c, de), st(we, jt[2], _i), st(we, jt[3], _i), ne && st(o, "click", oi, !1, !0), Y && st(o, "click", li), R && st(we, "gesturestart", ee), T && st(we, "gestureend", Yi), b && st(o, ji + "enter", Hi), A && st(o, ji + "leave", _r), z && st(o, ji + "move", Xt)), $.isEnabled = !0, G && G.type && vi(G), ie && ie($)), $ }, $.disable = function () { $.isEnabled && (Mr.filter(function (G) { return G !== $ && ds(G.target) }).length || rt(Le ? we : o, "scroll", fa), $.isPressed && ($._vx.reset(), $._vy.reset(), rt(D ? o : we, jt[1], Ni, !0)), rt(Le ? we : o, "scroll", Vt, de), rt(o, "wheel", Gt, de), rt(o, jt[0], vi, de), rt(we, jt[2], _i), rt(we, jt[3], _i), rt(o, "click", oi, !0), rt(o, "click", li), rt(we, "gesturestart", ee), rt(we, "gestureend", Yi), rt(o, ji + "enter", Hi), rt(o, ji + "leave", _r), rt(o, ji + "move", Xt), $.isEnabled = $.isPressed = $.isDragging = !1, F && F($)) }, $.kill = $.revert = function () { $.disable(); var G = Mr.indexOf($); G >= 0 && Mr.splice(G, 1), pi === $ && (pi = 0) }, Mr.push($), D && ds(o) && (pi = $), $.enable(h) }, Nc(n, [{ key: "velocityX", get: function () { return this._vx.getVelocity() } }, { key: "velocityY", get: function () { return this._vy.getVelocity() } }]), n }(); Ce.version = "3.12.4"; Ce.create = function (n) { return new Ce(n) }; Ce.register = Xl; Ce.getAll = function () { return Mr.slice() }; Ce.getById = function (n) { return Mr.filter(function (e) { return e.vars.id === n })[0] }; Hl() && Xe.registerPlugin(Ce);/*!
 * ScrollTrigger 3.12.4
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var q, Sr, Q, he, Ut, ce, Wl, fn, Es, Cr, Us, zs, Ke, En, ha, at, vo, _o, xr, jl, $n, Ul, nt, Kl, Zl, Ql, yi, ma, Na, Or, Ya, pn, ga, Bn, Rs = 1, lt = Date.now, qn = lt(), qt = 0, Zr = 0, yo = function (e, t, i) { var r = xt(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1); return i["_" + t + "Clamp"] = r, r ? e.substr(6, e.length - 7) : e }, wo = function (e, t) { return t && (!xt(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e }, Hc = function n() { return Zr && requestAnimationFrame(n) }, bo = function () { return En = 1 }, So = function () { return En = 0 }, ei = function (e) { return e }, Qr = function (e) { return Math.round(e * 1e5) / 1e5 || 0 }, Jl = function () { return typeof window < "u" }, ed = function () { return q || Jl() && (q = window.gsap) && q.registerPlugin && q }, cr = function (e) { return !!~Wl.indexOf(e) }, td = function (e) { return (e === "Height" ? Ya : Q["inner" + e]) || Ut["client" + e] || ce["client" + e] }, id = function (e) { return Li(e, "getBoundingClientRect") || (cr(e) ? function () { return tn.width = Q.innerWidth, tn.height = Ya, tn } : function () { return ui(e) }) }, Vc = function (e, t, i) { var r = i.d, s = i.d2, a = i.a; return (a = Li(e, "getBoundingClientRect")) ? function () { return a()[r] } : function () { return (t ? td(s) : e["client" + s]) || 0 } }, Gc = function (e, t) { return !t || ~ni.indexOf(e) ? id(e) : function () { return tn } }, ri = function (e, t) { var i = t.s, r = t.d2, s = t.d, a = t.a; return Math.max(0, (i = "scroll" + r) && (a = Li(e, i)) ? a() - id(e)()[s] : cr(e) ? (Ut[i] || ce[i]) - td(r) : e[i] - e["offset" + r]) }, $s = function (e, t) { for (var i = 0; i < xr.length; i += 3)(!t || ~t.indexOf(xr[i + 1])) && e(xr[i], xr[i + 1], xr[i + 2]) }, xt = function (e) { return typeof e == "string" }, ut = function (e) { return typeof e == "function" }, Ks = function (e) { return typeof e == "number" }, Ui = function (e) { return typeof e == "object" }, jr = function (e, t, i) { return e && e.progress(t ? 0 : 1) && i && e.pause() }, Fn = function (e, t) { if (e.enabled) { var i = e._ctx ? e._ctx.add(function () { return t(e) }) : t(e); i && i.totalTime && (e.callbackAnimation = i) } }, wr = Math.abs, rd = "left", sd = "top", Ha = "right", Va = "bottom", rr = "width", sr = "height", cs = "Right", us = "Left", fs = "Top", ps = "Bottom", Ee = "padding", Dt = "margin", qr = "Width", Ga = "Height", Be = "px", zt = function (e) { return Q.getComputedStyle(e) }, Xc = function (e) { var t = zt(e).position; e.style.position = t === "absolute" || t === "fixed" ? t : "relative" }, xo = function (e, t) { for (var i in t) i in e || (e[i] = t[i]); return e }, ui = function (e, t) { var i = t && zt(e)[ha] !== "matrix(1, 0, 0, 1, 0, 0)" && q.to(e, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), r = e.getBoundingClientRect(); return i && i.progress(0).kill(), r }, va = function (e, t) { var i = t.d2; return e["offset" + i] || e["client" + i] || 0 }, nd = function (e) { var t = [], i = e.labels, r = e.duration(), s; for (s in i) t.push(i[s] / r); return t }, Wc = function (e) { return function (t) { return q.utils.snap(nd(e), t) } }, Xa = function (e) { var t = q.utils.snap(e), i = Array.isArray(e) && e.slice(0).sort(function (r, s) { return r - s }); return i ? function (r, s, a) { a === void 0 && (a = .001); var o; if (!s) return t(r); if (s > 0) { for (r -= a, o = 0; o < i.length; o++)if (i[o] >= r) return i[o]; return i[o - 1] } else for (o = i.length, r += a; o--;)if (i[o] <= r) return i[o]; return i[0] } : function (r, s, a) { a === void 0 && (a = .001); var o = t(r); return !s || Math.abs(o - r) < a || o - r < 0 == s < 0 ? o : t(s < 0 ? r - e : r + e) } }, jc = function (e) { return function (t, i) { return Xa(nd(e))(t, i.direction) } }, Bs = function (e, t, i, r) { return i.split(",").forEach(function (s) { return e(t, s, r) }) }, Fe = function (e, t, i, r, s) { return e.addEventListener(t, i, { passive: !r, capture: !!s }) }, qe = function (e, t, i, r) { return e.removeEventListener(t, i, !!r) }, qs = function (e, t, i) { i = i && i.wheelHandler, i && (e(t, "wheel", i), e(t, "touchmove", i)) }, To = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, Fs = { toggleActions: "play", anticipatePin: 0 }, hn = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, Zs = function (e, t) { if (xt(e)) { var i = e.indexOf("="), r = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0; ~i && (e.indexOf("%") > i && (r *= t / 100), e = e.substr(0, i - 1)), e = r + (e in hn ? hn[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0) } return e }, Ns = function (e, t, i, r, s, a, o, l) { var d = s.startColor, c = s.endColor, u = s.fontSize, f = s.indent, p = s.fontWeight, m = he.createElement("div"), h = cr(i) || Li(i, "pinType") === "fixed", g = e.indexOf("scroller") !== -1, y = h ? ce : i, v = e.indexOf("start") !== -1, _ = v ? d : c, w = "border-color:" + _ + ";font-size:" + u + ";color:" + _ + ";font-weight:" + p + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return w += "position:" + ((g || l) && h ? "fixed;" : "absolute;"), (g || l || !h) && (w += (r === Oe ? Ha : Va) + ":" + (a + parseFloat(f)) + "px;"), o && (w += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"), m._isStart = v, m.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), m.style.cssText = w, m.innerText = t || t === 0 ? e + "-" + t : e, y.children[0] ? y.insertBefore(m, y.children[0]) : y.appendChild(m), m._offset = m["offset" + r.op.d2], Qs(m, 0, r, v), m }, Qs = function (e, t, i, r) { var s = { display: "block" }, a = i[r ? "os2" : "p2"], o = i[r ? "p2" : "os2"]; e._isFlipped = r, s[i.a + "Percent"] = r ? -100 : 0, s[i.a] = r ? "1px" : 0, s["border" + a + qr] = 1, s["border" + o + qr] = 0, s[i.p] = t + "px", q.set(e, s) }, X = [], _a = {}, Ms, Eo = function () { return lt() - qt > 34 && (Ms || (Ms = requestAnimationFrame(hi))) }, br = function () { (!nt || !nt.isPressed || nt.startX > ce.clientWidth) && (K.cache++, nt ? Ms || (Ms = requestAnimationFrame(hi)) : hi(), qt || fr("scrollStart"), qt = lt()) }, Nn = function () { Ql = Q.innerWidth, Zl = Q.innerHeight }, Jr = function () { K.cache++, !Ke && !Ul && !he.fullscreenElement && !he.webkitFullscreenElement && (!Kl || Ql !== Q.innerWidth || Math.abs(Q.innerHeight - Zl) > Q.innerHeight * .25) && fn.restart(!0) }, ur = {}, Uc = [], ad = function n() { return qe(Z, "scrollEnd", n) || Qi(!0) }, fr = function (e) { return ur[e] && ur[e].map(function (t) { return t() }) || Uc }, St = [], od = function (e) { for (var t = 0; t < St.length; t += 5)(!e || St[t + 4] && St[t + 4].query === e) && (St[t].style.cssText = St[t + 1], St[t].getBBox && St[t].setAttribute("transform", St[t + 2] || ""), St[t + 3].uncache = 1) }, Wa = function (e, t) { var i; for (at = 0; at < X.length; at++)i = X[at], i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0)); pn = !0, t && od(t), t || fr("revert") }, ld = function (e, t) { K.cache++, (t || !ot) && K.forEach(function (i) { return ut(i) && i.cacheID++ && (i.rec = 0) }), xt(e) && (Q.history.scrollRestoration = Na = e) }, ot, nr = 0, Mo, Kc = function () { if (Mo !== nr) { var e = Mo = nr; requestAnimationFrame(function () { return e === nr && Qi(!0) }) } }, dd = function () { ce.appendChild(Or), Ya = !nt && Or.offsetHeight || Q.innerHeight, ce.removeChild(Or) }, Co = function (e) { return Es(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function (t) { return t.style.display = e ? "none" : "block" }) }, Qi = function (e, t) { if (qt && !e && !pn) { Fe(Z, "scrollEnd", ad); return } dd(), ot = Z.isRefreshing = !0, K.forEach(function (r) { return ut(r) && ++r.cacheID && (r.rec = r()) }); var i = fr("refreshInit"); jl && Z.sort(), t || Wa(), K.forEach(function (r) { ut(r) && (r.smooth && (r.target.style.scrollBehavior = "auto"), r(0)) }), X.slice(0).forEach(function (r) { return r.refresh() }), pn = !1, X.forEach(function (r) { if (r._subPinOffset && r.pin) { var s = r.vars.horizontal ? "offsetWidth" : "offsetHeight", a = r.pin[s]; r.revert(!0, 1), r.adjustPinSpacing(r.pin[s] - a), r.refresh() } }), ga = 1, Co(!0), X.forEach(function (r) { var s = ri(r.scroller, r._dir), a = r.vars.end === "max" || r._endClamp && r.end > s, o = r._startClamp && r.start >= s; (a || o) && r.setPositions(o ? s - 1 : r.start, a ? Math.max(o ? s : r.start + 1, s) : r.end, !0) }), Co(!1), ga = 0, i.forEach(function (r) { return r && r.render && r.render(-1) }), K.forEach(function (r) { ut(r) && (r.smooth && requestAnimationFrame(function () { return r.target.style.scrollBehavior = "smooth" }), r.rec && r(r.rec)) }), ld(Na, 1), fn.pause(), nr++, ot = 2, hi(2), X.forEach(function (r) { return ut(r.vars.onRefresh) && r.vars.onRefresh(r) }), ot = Z.isRefreshing = !1, fr("refresh") }, ya = 0, Js = 1, hs, hi = function (e) { if (e === 2 || !ot && !pn) { Z.isUpdating = !0, hs && hs.update(0); var t = X.length, i = lt(), r = i - qn >= 50, s = t && X[0].scroll(); if (Js = ya > s ? -1 : 1, ot || (ya = s), r && (qt && !En && i - qt > 200 && (qt = 0, fr("scrollEnd")), Us = qn, qn = i), Js < 0) { for (at = t; at-- > 0;)X[at] && X[at].update(0, r); Js = 1 } else for (at = 0; at < t; at++)X[at] && X[at].update(0, r); Z.isUpdating = !1 } Ms = 0 }, wa = [rd, sd, Va, Ha, Dt + ps, Dt + cs, Dt + fs, Dt + us, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], en = wa.concat([rr, sr, "boxSizing", "max" + qr, "max" + Ga, "position", Dt, Ee, Ee + fs, Ee + cs, Ee + ps, Ee + us]), Zc = function (e, t, i) { Ir(i); var r = e._gsap; if (r.spacerIsNative) Ir(r.spacerState); else if (e._gsap.swappedIn) { var s = t.parentNode; s && (s.insertBefore(e, t), s.removeChild(t)) } e._gsap.swappedIn = !1 }, Yn = function (e, t, i, r) { if (!e._gsap.swappedIn) { for (var s = wa.length, a = t.style, o = e.style, l; s--;)l = wa[s], a[l] = i[l]; a.position = i.position === "absolute" ? "absolute" : "relative", i.display === "inline" && (a.display = "inline-block"), o[Va] = o[Ha] = "auto", a.flexBasis = i.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[rr] = va(e, ct) + Be, a[sr] = va(e, Oe) + Be, a[Ee] = o[Dt] = o[sd] = o[rd] = "0", Ir(r), o[rr] = o["max" + qr] = i[rr], o[sr] = o["max" + Ga] = i[sr], o[Ee] = i[Ee], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0 } }, Qc = /([A-Z])/g, Ir = function (e) { if (e) { var t = e.t.style, i = e.length, r = 0, s, a; for ((e.t._gsap || q.core.getCache(e.t)).uncache = 1; r < i; r += 2)a = e[r + 1], s = e[r], a ? t[s] = a : t[s] && t.removeProperty(s.replace(Qc, "-$1").toLowerCase()) } }, Ys = function (e) { for (var t = en.length, i = e.style, r = [], s = 0; s < t; s++)r.push(en[s], i[en[s]]); return r.t = e, r }, Jc = function (e, t, i) { for (var r = [], s = e.length, a = i ? 8 : 0, o; a < s; a += 2)o = e[a], r.push(o, o in t ? t[o] : e[a + 1]); return r.t = e.t, r }, tn = { left: 0, top: 0 }, Po = function (e, t, i, r, s, a, o, l, d, c, u, f, p, m) { ut(e) && (e = e(l)), xt(e) && e.substr(0, 3) === "max" && (e = f + (e.charAt(4) === "=" ? Zs("0" + e.substr(3), i) : 0)); var h = p ? p.time() : 0, g, y, v; if (p && p.seek(0), isNaN(e) || (e = +e), Ks(e)) p && (e = q.utils.mapRange(p.scrollTrigger.start, p.scrollTrigger.end, 0, f, e)), o && Qs(o, i, r, !0); else { ut(t) && (t = t(l)); var _ = (e || "0").split(" "), w, S, x, P; v = mt(t, l) || ce, w = ui(v) || {}, (!w || !w.left && !w.top) && zt(v).display === "none" && (P = v.style.display, v.style.display = "block", w = ui(v), P ? v.style.display = P : v.style.removeProperty("display")), S = Zs(_[0], w[r.d]), x = Zs(_[1] || "0", i), e = w[r.p] - d[r.p] - c + S + s - x, o && Qs(o, x, r, i - x < 20 || o._isStart && x > 20), i -= i - x } if (m && (l[m] = e || -.001, e < 0 && (e = 0)), a) { var L = e + i, M = a._isStart; g = "scroll" + r.d2, Qs(a, L, r, M && L > 20 || !M && (u ? Math.max(ce[g], Ut[g]) : a.parentNode[g]) <= L + 1), u && (d = ui(o), u && (a.style[r.op.p] = d[r.op.p] - r.op.m - a._offset + Be)) } return p && v && (g = ui(v), p.seek(f), y = ui(v), p._caScrollDist = g[r.p] - y[r.p], e = e / p._caScrollDist * f), p && p.seek(h), p ? e : Math.round(e) }, eu = /(webkit|moz|length|cssText|inset)/i, Ao = function (e, t, i, r) { if (e.parentNode !== t) { var s = e.style, a, o; if (t === ce) { e._stOrig = s.cssText, o = zt(e); for (a in o) !+a && !eu.test(a) && o[a] && typeof s[a] == "string" && a !== "0" && (s[a] = o[a]); s.top = i, s.left = r } else s.cssText = e._stOrig; q.core.getCache(e).uncache = 1, t.appendChild(e) } }, cd = function (e, t, i) { var r = t, s = r; return function (a) { var o = Math.round(e()); return o !== r && o !== s && Math.abs(o - r) > 3 && Math.abs(o - s) > 3 && (a = o, i && i()), s = r, r = a, a } }, Hs = function (e, t, i) { var r = {}; r[t.p] = "+=" + i, q.set(e, r) }, Lo = function (e, t) { var i = Ii(e, t), r = "_scroll" + t.p2, s = function a(o, l, d, c, u) { var f = a.tween, p = l.onComplete, m = {}; d = d || i(); var h = cd(i, d, function () { f.kill(), a.tween = 0 }); return u = c && u || 0, c = c || o - d, f && f.kill(), l[r] = o, l.modifiers = m, m[r] = function () { return h(d + c * f.ratio + u * f.ratio * f.ratio) }, l.onUpdate = function () { K.cache++, a.tween && hi() }, l.onComplete = function () { a.tween = 0, p && p.call(f) }, f = a.tween = q.to(e, l), f }; return e[r] = i, i.wheelHandler = function () { return s.tween && s.tween.kill() && (s.tween = 0) }, Fe(e, "wheel", i.wheelHandler), Z.isTouch && Fe(e, "touchmove", i.wheelHandler), s }, Z = function () { function n(t, i) { Sr || n.register(q) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), ma(this), this.init(t, i) } var e = n.prototype; return e.init = function (i, r) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !Zr) { this.update = this.refresh = this.kill = ei; return } i = xo(xt(i) || Ks(i) || i.nodeType ? { trigger: i } : i, Fs); var s = i, a = s.onUpdate, o = s.toggleClass, l = s.id, d = s.onToggle, c = s.onRefresh, u = s.scrub, f = s.trigger, p = s.pin, m = s.pinSpacing, h = s.invalidateOnRefresh, g = s.anticipatePin, y = s.onScrubComplete, v = s.onSnapComplete, _ = s.once, w = s.snap, S = s.pinReparent, x = s.pinSpacer, P = s.containerAnimation, L = s.fastScrollEnd, M = s.preventOverlaps, E = i.horizontal || i.containerAnimation && i.horizontal !== !1 ? ct : Oe, O = !u && u !== 0, C = mt(i.scroller || Q), k = q.core.getCache(C), b = cr(C), A = ("pinType" in i ? i.pinType : Li(C, "pinType") || b && "fixed") === "fixed", z = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack], I = O && i.toggleActions.split(" "), D = "markers" in i ? i.markers : Fs.markers, R = b ? 0 : parseFloat(zt(C)["border" + E.p2 + qr]) || 0, T = this, N = i.onRefreshInit && function () { return i.onRefreshInit(T) }, ie = Vc(C, b, E), F = Gc(C, b), Y = 0, se = 0, de = 0, ne = Ii(C, E), Ie, Pe, Nt, De, et, W, ue, ze, Ve, $, Ae, tt, Ri, xe, $i, Bi, Yr, Le, we, Yt, Ht, qi, oi, Kt, pt, Fi, gr, vr, Ni, vi, _i, ee, Yi, Vt, Gt, Xt, Hi, _r, li; if (T._startClamp = T._endClamp = !1, T._dir = E, g *= 45, T.scroller = C, T.scroll = P ? P.time.bind(P) : ne, De = ne(), T.vars = i, r = r || i.animation, "refreshPriority" in i && (jl = 1, i.refreshPriority === -9999 && (hs = T)), k.tweenScroll = k.tweenScroll || { top: Lo(C, Oe), left: Lo(C, ct) }, T.tweenTo = Ie = k.tweenScroll[E.p], T.scrubDuration = function (B) { Yi = Ks(B) && B, Yi ? ee ? ee.duration(B) : ee = q.to(r, { ease: "expo", totalProgress: "+=0", duration: Yi, paused: !0, onComplete: function () { return y && y(T) } }) : (ee && ee.progress(1).kill(), ee = 0) }, r && (r.vars.lazy = !1, r._initted && !T.isReverted || r.vars.immediateRender !== !1 && i.immediateRender !== !1 && r.duration() && r.render(0, !0, !0), T.animation = r.pause(), r.scrollTrigger = T, T.scrubDuration(u), vi = 0, l || (l = r.vars.id)), w && ((!Ui(w) || w.push) && (w = { snapTo: w }), "scrollBehavior" in ce.style && q.set(b ? [ce, Ut] : C, { scrollBehavior: "auto" }), K.forEach(function (B) { return ut(B) && B.target === (b ? he.scrollingElement || Ut : C) && (B.smooth = !1) }), Nt = ut(w.snapTo) ? w.snapTo : w.snapTo === "labels" ? Wc(r) : w.snapTo === "labelsDirectional" ? jc(r) : w.directional !== !1 ? function (B, j) { return Xa(w.snapTo)(B, lt() - se < 500 ? 0 : j.direction) } : q.utils.snap(w.snapTo), Vt = w.duration || { min: .1, max: 2 }, Vt = Ui(Vt) ? Cr(Vt.min, Vt.max) : Cr(Vt, Vt), Gt = q.delayedCall(w.delay || Yi / 2 || .1, function () { var B = ne(), j = lt() - se < 500, V = Ie.tween; if ((j || Math.abs(T.getVelocity()) < 10) && !V && !En && Y !== B) { var U = (B - W) / xe, Re = r && !O ? r.totalProgress() : U, te = j ? 0 : (Re - _i) / (lt() - Us) * 1e3 || 0, be = q.utils.clamp(-U, 1 - U, wr(te / 2) * te / .185), it = U + (w.inertia === !1 ? 0 : be), $e = Cr(0, 1, Nt(it, T)), fe = Math.round(W + $e * xe), ae = w, Wt = ae.onStart, pe = ae.onInterrupt, bt = ae.onComplete; if (B <= ue && B >= W && fe !== B) { if (V && !V._initted && V.data <= wr(fe - B)) return; w.inertia === !1 && (be = $e - U), Ie(fe, { duration: Vt(wr(Math.max(wr(it - Re), wr($e - Re)) * .185 / te / .05 || 0)), ease: w.ease || "power3", data: wr(fe - B), onInterrupt: function () { return Gt.restart(!0) && pe && pe(T) }, onComplete: function () { T.update(), Y = ne(), ee && r && r.progress($e), vi = _i = r && !O ? r.totalProgress() : T.progress, v && v(T), bt && bt(T) } }, B, be * xe, fe - B - be * xe), Wt && Wt(T, Ie.tween) } } else T.isActive && Y !== B && Gt.restart(!0) }).pause()), l && (_a[l] = T), f = T.trigger = mt(f || p !== !0 && p), li = f && f._gsap && f._gsap.stRevert, li && (li = li(T)), p = p === !0 ? f : mt(p), xt(o) && (o = { targets: f, className: o }), p && (m === !1 || m === Dt || (m = !m && p.parentNode && p.parentNode.style && zt(p.parentNode).display === "flex" ? !1 : Ee), T.pin = p, Pe = q.core.getCache(p), Pe.spacer ? $i = Pe.pinState : (x && (x = mt(x), x && !x.nodeType && (x = x.current || x.nativeElement), Pe.spacerIsNative = !!x, x && (Pe.spacerState = Ys(x))), Pe.spacer = Le = x || he.createElement("div"), Le.classList.add("pin-spacer"), l && Le.classList.add("pin-spacer-" + l), Pe.pinState = $i = Ys(p)), i.force3D !== !1 && q.set(p, { force3D: !0 }), T.spacer = Le = Pe.spacer, Ni = zt(p), Kt = Ni[m + E.os2], Yt = q.getProperty(p), Ht = q.quickSetter(p, E.a, Be), Yn(p, Le, Ni), Yr = Ys(p)), D) { tt = Ui(D) ? xo(D, To) : To, $ = Ns("scroller-start", l, C, E, tt, 0), Ae = Ns("scroller-end", l, C, E, tt, 0, $), we = $["offset" + E.op.d2]; var G = mt(Li(C, "content") || C); ze = this.markerStart = Ns("start", l, G, E, tt, we, 0, P), Ve = this.markerEnd = Ns("end", l, G, E, tt, we, 0, P), P && (_r = q.quickSetter([ze, Ve], E.a, Be)), !A && !(ni.length && Li(C, "fixedMarkers") === !0) && (Xc(b ? ce : C), q.set([$, Ae], { force3D: !0 }), Fi = q.quickSetter($, E.a, Be), vr = q.quickSetter(Ae, E.a, Be)) } if (P) { var H = P.vars.onUpdate, re = P.vars.onUpdateParams; P.eventCallback("onUpdate", function () { T.update(0, 0, 1), H && H.apply(P, re || []) }) } if (T.previous = function () { return X[X.indexOf(T) - 1] }, T.next = function () { return X[X.indexOf(T) + 1] }, T.revert = function (B, j) { if (!j) return T.kill(!0); var V = B !== !1 || !T.enabled, U = Ke; V !== T.isReverted && (V && (Xt = Math.max(ne(), T.scroll.rec || 0), de = T.progress, Hi = r && r.progress()), ze && [ze, Ve, $, Ae].forEach(function (Re) { return Re.style.display = V ? "none" : "block" }), V && (Ke = T, T.update(V)), p && (!S || !T.isActive) && (V ? Zc(p, Le, $i) : Yn(p, Le, zt(p), pt)), V || T.update(V), Ke = U, T.isReverted = V) }, T.refresh = function (B, j, V, U) { if (!((Ke || !T.enabled) && !j)) { if (p && B && qt) { Fe(n, "scrollEnd", ad); return } !ot && N && N(T), Ke = T, Ie.tween && !V && (Ie.tween.kill(), Ie.tween = 0), ee && ee.pause(), h && r && r.revert({ kill: !1 }).invalidate(), T.isReverted || T.revert(!0, !0), T._subPinOffset = !1; var Re = ie(), te = F(), be = P ? P.duration() : ri(C, E), it = xe <= .01, $e = 0, fe = U || 0, ae = Ui(V) ? V.end : i.end, Wt = i.endTrigger || f, pe = Ui(V) ? V.start : i.start || (i.start === 0 || !f ? 0 : p ? "0 0" : "0 100%"), bt = T.pinnedContainer = i.pinnedContainer && mt(i.pinnedContainer, T), Zt = f && Math.max(0, X.indexOf(T)) || 0, ht = Zt, Ge, je, Vi, Ls, Ue, ke, Qt, Cn, Za, Hr, Jt, Vr, ks; for (D && Ui(V) && (Vr = q.getProperty($, E.p), ks = q.getProperty(Ae, E.p)); ht--;)ke = X[ht], ke.end || ke.refresh(0, 1) || (Ke = T), Qt = ke.pin, Qt && (Qt === f || Qt === p || Qt === bt) && !ke.isReverted && (Hr || (Hr = []), Hr.unshift(ke), ke.revert(!0, !0)), ke !== X[ht] && (Zt--, ht--); for (ut(pe) && (pe = pe(T)), pe = yo(pe, "start", T), W = Po(pe, f, Re, E, ne(), ze, $, T, te, R, A, be, P, T._startClamp && "_startClamp") || (p ? -.001 : 0), ut(ae) && (ae = ae(T)), xt(ae) && !ae.indexOf("+=") && (~ae.indexOf(" ") ? ae = (xt(pe) ? pe.split(" ")[0] : "") + ae : ($e = Zs(ae.substr(2), Re), ae = xt(pe) ? pe : (P ? q.utils.mapRange(0, P.duration(), P.scrollTrigger.start, P.scrollTrigger.end, W) : W) + $e, Wt = f)), ae = yo(ae, "end", T), ue = Math.max(W, Po(ae || (Wt ? "100% 0" : be), Wt, Re, E, ne() + $e, Ve, Ae, T, te, R, A, be, P, T._endClamp && "_endClamp")) || -.001, $e = 0, ht = Zt; ht--;)ke = X[ht], Qt = ke.pin, Qt && ke.start - ke._pinPush <= W && !P && ke.end > 0 && (Ge = ke.end - (T._startClamp ? Math.max(0, ke.start) : ke.start), (Qt === f && ke.start - ke._pinPush < W || Qt === bt) && isNaN(pe) && ($e += Ge * (1 - ke.progress)), Qt === p && (fe += Ge)); if (W += $e, ue += $e, T._startClamp && (T._startClamp += $e), T._endClamp && !ot && (T._endClamp = ue || -.001, ue = Math.min(ue, ri(C, E))), xe = ue - W || (W -= .01) && .001, it && (de = q.utils.clamp(0, 1, q.utils.normalize(W, ue, Xt))), T._pinPush = fe, ze && $e && (Ge = {}, Ge[E.a] = "+=" + $e, bt && (Ge[E.p] = "-=" + ne()), q.set([ze, Ve], Ge)), p && !(ga && T.end >= ri(C, E))) Ge = zt(p), Ls = E === Oe, Vi = ne(), qi = parseFloat(Yt(E.a)) + fe, !be && ue > 1 && (Jt = (b ? he.scrollingElement || Ut : C).style, Jt = { style: Jt, value: Jt["overflow" + E.a.toUpperCase()] }, b && zt(ce)["overflow" + E.a.toUpperCase()] !== "scroll" && (Jt.style["overflow" + E.a.toUpperCase()] = "scroll")), Yn(p, Le, Ge), Yr = Ys(p), je = ui(p, !0), Cn = A && Ii(C, Ls ? ct : Oe)(), m && (pt = [m + E.os2, xe + fe + Be], pt.t = Le, ht = m === Ee ? va(p, E) + xe + fe : 0, ht && (pt.push(E.d, ht + Be), Le.style.flexBasis !== "auto" && (Le.style.flexBasis = ht + Be)), Ir(pt), bt && X.forEach(function (Gr) { Gr.pin === bt && Gr.vars.pinSpacing !== !1 && (Gr._subPinOffset = !0) }), A && ne(Xt)), A && (Ue = { top: je.top + (Ls ? Vi - W : Cn) + Be, left: je.left + (Ls ? Cn : Vi - W) + Be, boxSizing: "border-box", position: "fixed" }, Ue[rr] = Ue["max" + qr] = Math.ceil(je.width) + Be, Ue[sr] = Ue["max" + Ga] = Math.ceil(je.height) + Be, Ue[Dt] = Ue[Dt + fs] = Ue[Dt + cs] = Ue[Dt + ps] = Ue[Dt + us] = "0", Ue[Ee] = Ge[Ee], Ue[Ee + fs] = Ge[Ee + fs], Ue[Ee + cs] = Ge[Ee + cs], Ue[Ee + ps] = Ge[Ee + ps], Ue[Ee + us] = Ge[Ee + us], Bi = Jc($i, Ue, S), ot && ne(0)), r ? (Za = r._initted, $n(1), r.render(r.duration(), !0, !0), oi = Yt(E.a) - qi + xe + fe, gr = Math.abs(xe - oi) > 1, A && gr && Bi.splice(Bi.length - 2, 2), r.render(0, !0, !0), Za || r.invalidate(!0), r.parent || r.totalTime(r.totalTime()), $n(0)) : oi = xe, Jt && (Jt.value ? Jt.style["overflow" + E.a.toUpperCase()] = Jt.value : Jt.style.removeProperty("overflow-" + E.a)); else if (f && ne() && !P) for (je = f.parentNode; je && je !== ce;)je._pinOffset && (W -= je._pinOffset, ue -= je._pinOffset), je = je.parentNode; Hr && Hr.forEach(function (Gr) { return Gr.revert(!1, !0) }), T.start = W, T.end = ue, De = et = ot ? Xt : ne(), !P && !ot && (De < Xt && ne(Xt), T.scroll.rec = 0), T.revert(!1, !0), se = lt(), Gt && (Y = -1, Gt.restart(!0)), Ke = 0, r && O && (r._initted || Hi) && r.progress() !== Hi && r.progress(Hi || 0, !0).render(r.time(), !0, !0), (it || de !== T.progress || P) && (r && !O && r.totalProgress(P && W < -.001 && !de ? q.utils.normalize(W, ue, 0) : de, !0), T.progress = it || (De - W) / xe === de ? 0 : de), p && m && (Le._pinOffset = Math.round(T.progress * oi)), ee && ee.invalidate(), isNaN(Vr) || (Vr -= q.getProperty($, E.p), ks -= q.getProperty(Ae, E.p), Hs($, E, Vr), Hs(ze, E, Vr - (U || 0)), Hs(Ae, E, ks), Hs(Ve, E, ks - (U || 0))), it && !ot && T.update(), c && !ot && !Ri && (Ri = !0, c(T), Ri = !1) } }, T.getVelocity = function () { return (ne() - et) / (lt() - Us) * 1e3 || 0 }, T.endAnimation = function () { jr(T.callbackAnimation), r && (ee ? ee.progress(1) : r.paused() ? O || jr(r, T.direction < 0, 1) : jr(r, r.reversed())) }, T.labelToScroll = function (B) { return r && r.labels && (W || T.refresh() || W) + r.labels[B] / r.duration() * xe || 0 }, T.getTrailing = function (B) { var j = X.indexOf(T), V = T.direction > 0 ? X.slice(0, j).reverse() : X.slice(j + 1); return (xt(B) ? V.filter(function (U) { return U.vars.preventOverlaps === B }) : V).filter(function (U) { return T.direction > 0 ? U.end <= W : U.start >= ue }) }, T.update = function (B, j, V) { if (!(P && !V && !B)) { var U = ot === !0 ? Xt : T.scroll(), Re = B ? 0 : (U - W) / xe, te = Re < 0 ? 0 : Re > 1 ? 1 : Re || 0, be = T.progress, it, $e, fe, ae, Wt, pe, bt, Zt; if (j && (et = De, De = P ? ne() : U, w && (_i = vi, vi = r && !O ? r.totalProgress() : te)), g && !te && p && !Ke && !Rs && qt && W < U + (U - et) / (lt() - Us) * g && (te = 1e-4), te !== be && T.enabled) { if (it = T.isActive = !!te && te < 1, $e = !!be && be < 1, pe = it !== $e, Wt = pe || !!te != !!be, T.direction = te > be ? 1 : -1, T.progress = te, Wt && !Ke && (fe = te && !be ? 0 : te === 1 ? 1 : be === 1 ? 2 : 3, O && (ae = !pe && I[fe + 1] !== "none" && I[fe + 1] || I[fe], Zt = r && (ae === "complete" || ae === "reset" || ae in r))), M && (pe || Zt) && (Zt || u || !r) && (ut(M) ? M(T) : T.getTrailing(M).forEach(function (Vi) { return Vi.endAnimation() })), O || (ee && !Ke && !Rs ? (ee._dp._time - ee._start !== ee._time && ee.render(ee._dp._time - ee._start), ee.resetTo ? ee.resetTo("totalProgress", te, r._tTime / r._tDur) : (ee.vars.totalProgress = te, ee.invalidate().restart())) : r && r.totalProgress(te, !!(Ke && (se || B)))), p) { if (B && m && (Le.style[m + E.os2] = Kt), !A) Ht(Qr(qi + oi * te)); else if (Wt) { if (bt = !B && te > be && ue + 1 > U && U + 1 >= ri(C, E), S) if (!B && (it || bt)) { var ht = ui(p, !0), Ge = U - W; Ao(p, ce, ht.top + (E === Oe ? Ge : 0) + Be, ht.left + (E === Oe ? 0 : Ge) + Be) } else Ao(p, Le); Ir(it || bt ? Bi : Yr), gr && te < 1 && it || Ht(qi + (te === 1 && !bt ? oi : 0)) } } w && !Ie.tween && !Ke && !Rs && Gt.restart(!0), o && (pe || _ && te && (te < 1 || !Bn)) && Es(o.targets).forEach(function (Vi) { return Vi.classList[it || _ ? "add" : "remove"](o.className) }), a && !O && !B && a(T), Wt && !Ke ? (O && (Zt && (ae === "complete" ? r.pause().totalProgress(1) : ae === "reset" ? r.restart(!0).pause() : ae === "restart" ? r.restart(!0) : r[ae]()), a && a(T)), (pe || !Bn) && (d && pe && Fn(T, d), z[fe] && Fn(T, z[fe]), _ && (te === 1 ? T.kill(!1, 1) : z[fe] = 0), pe || (fe = te === 1 ? 1 : 3, z[fe] && Fn(T, z[fe]))), L && !it && Math.abs(T.getVelocity()) > (Ks(L) ? L : 2500) && (jr(T.callbackAnimation), ee ? ee.progress(1) : jr(r, ae === "reverse" ? 1 : !te, 1))) : O && a && !Ke && a(T) } if (vr) { var je = P ? U / P.duration() * (P._caScrollDist || 0) : U; Fi(je + ($._isFlipped ? 1 : 0)), vr(je) } _r && _r(-U / P.duration() * (P._caScrollDist || 0)) } }, T.enable = function (B, j) { T.enabled || (T.enabled = !0, Fe(C, "resize", Jr), b || Fe(C, "scroll", br), N && Fe(n, "refreshInit", N), B !== !1 && (T.progress = de = 0, De = et = Y = ne()), j !== !1 && T.refresh()) }, T.getTween = function (B) { return B && Ie ? Ie.tween : ee }, T.setPositions = function (B, j, V, U) { if (P) { var Re = P.scrollTrigger, te = P.duration(), be = Re.end - Re.start; B = Re.start + be * B / te, j = Re.start + be * j / te } T.refresh(!1, !1, { start: wo(B, V && !!T._startClamp), end: wo(j, V && !!T._endClamp) }, U), T.update() }, T.adjustPinSpacing = function (B) { if (pt && B) { var j = pt.indexOf(E.d) + 1; pt[j] = parseFloat(pt[j]) + B + Be, pt[1] = parseFloat(pt[1]) + B + Be, Ir(pt) } }, T.disable = function (B, j) { if (T.enabled && (B !== !1 && T.revert(!0, !0), T.enabled = T.isActive = !1, j || ee && ee.pause(), Xt = 0, Pe && (Pe.uncache = 1), N && qe(n, "refreshInit", N), Gt && (Gt.pause(), Ie.tween && Ie.tween.kill() && (Ie.tween = 0)), !b)) { for (var V = X.length; V--;)if (X[V].scroller === C && X[V] !== T) return; qe(C, "resize", Jr), b || qe(C, "scroll", br) } }, T.kill = function (B, j) { T.disable(B, j), ee && !j && ee.kill(), l && delete _a[l]; var V = X.indexOf(T); V >= 0 && X.splice(V, 1), V === at && Js > 0 && at--, V = 0, X.forEach(function (U) { return U.scroller === T.scroller && (V = 1) }), V || ot || (T.scroll.rec = 0), r && (r.scrollTrigger = null, B && r.revert({ kill: !1 }), j || r.kill()), ze && [ze, Ve, $, Ae].forEach(function (U) { return U.parentNode && U.parentNode.removeChild(U) }), hs === T && (hs = 0), p && (Pe && (Pe.uncache = 1), V = 0, X.forEach(function (U) { return U.pin === p && V++ }), V || (Pe.spacer = 0)), i.onKill && i.onKill(T) }, X.push(T), T.enable(!1, !1), li && li(T), r && r.add && !xe) { var Te = T.update; T.update = function () { T.update = Te, W || ue || T.refresh() }, q.delayedCall(.01, T.update), xe = .01, W = ue = 0 } else T.refresh(); p && Kc() }, n.register = function (i) { return Sr || (q = i || ed(), Jl() && window.document && n.enable(), Sr = Zr), Sr }, n.defaults = function (i) { if (i) for (var r in i) Fs[r] = i[r]; return Fs }, n.disable = function (i, r) { Zr = 0, X.forEach(function (a) { return a[r ? "kill" : "disable"](i) }), qe(Q, "wheel", br), qe(he, "scroll", br), clearInterval(zs), qe(he, "touchcancel", ei), qe(ce, "touchstart", ei), Bs(qe, he, "pointerdown,touchstart,mousedown", bo), Bs(qe, he, "pointerup,touchend,mouseup", So), fn.kill(), $s(qe); for (var s = 0; s < K.length; s += 3)qs(qe, K[s], K[s + 1]), qs(qe, K[s], K[s + 2]) }, n.enable = function () { if (Q = window, he = document, Ut = he.documentElement, ce = he.body, q && (Es = q.utils.toArray, Cr = q.utils.clamp, ma = q.core.context || ei, $n = q.core.suppressOverwrites || ei, Na = Q.history.scrollRestoration || "auto", ya = Q.pageYOffset, q.core.globals("ScrollTrigger", n), ce)) { Zr = 1, Or = document.createElement("div"), Or.style.height = "100vh", Or.style.position = "absolute", dd(), Hc(), Ce.register(q), n.isTouch = Ce.isTouch, yi = Ce.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), Fe(Q, "wheel", br), Wl = [Q, he, Ut, ce], q.matchMedia ? (n.matchMedia = function (l) { var d = q.matchMedia(), c; for (c in l) d.add(c, l[c]); return d }, q.addEventListener("matchMediaInit", function () { return Wa() }), q.addEventListener("matchMediaRevert", function () { return od() }), q.addEventListener("matchMedia", function () { Qi(0, 1), fr("matchMedia") }), q.matchMedia("(orientation: portrait)", function () { return Nn(), Nn })) : console.warn("Requires GSAP 3.11.0 or later"), Nn(), Fe(he, "scroll", br); var i = ce.style, r = i.borderTopStyle, s = q.core.Animation.prototype, a, o; for (s.revert || Object.defineProperty(s, "revert", { value: function () { return this.time(-.01, !0) } }), i.borderTopStyle = "solid", a = ui(ce), Oe.m = Math.round(a.top + Oe.sc()) || 0, ct.m = Math.round(a.left + ct.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), zs = setInterval(Eo, 250), q.delayedCall(.5, function () { return Rs = 0 }), Fe(he, "touchcancel", ei), Fe(ce, "touchstart", ei), Bs(Fe, he, "pointerdown,touchstart,mousedown", bo), Bs(Fe, he, "pointerup,touchend,mouseup", So), ha = q.utils.checkPrefix("transform"), en.push(ha), Sr = lt(), fn = q.delayedCall(.2, Qi).pause(), xr = [he, "visibilitychange", function () { var l = Q.innerWidth, d = Q.innerHeight; he.hidden ? (vo = l, _o = d) : (vo !== l || _o !== d) && Jr() }, he, "DOMContentLoaded", Qi, Q, "load", Qi, Q, "resize", Jr], $s(Fe), X.forEach(function (l) { return l.enable(0, 1) }), o = 0; o < K.length; o += 3)qs(qe, K[o], K[o + 1]), qs(qe, K[o], K[o + 2]) } }, n.config = function (i) { "limitCallbacks" in i && (Bn = !!i.limitCallbacks); var r = i.syncInterval; r && clearInterval(zs) || (zs = r) && setInterval(Eo, r), "ignoreMobileResize" in i && (Kl = n.isTouch === 1 && i.ignoreMobileResize), "autoRefreshEvents" in i && ($s(qe) || $s(Fe, i.autoRefreshEvents || "none"), Ul = (i.autoRefreshEvents + "").indexOf("resize") === -1) }, n.scrollerProxy = function (i, r) { var s = mt(i), a = K.indexOf(s), o = cr(s); ~a && K.splice(a, o ? 6 : 2), r && (o ? ni.unshift(Q, r, ce, r, Ut, r) : ni.unshift(s, r)) }, n.clearMatchMedia = function (i) { X.forEach(function (r) { return r._ctx && r._ctx.query === i && r._ctx.kill(!0, !0) }) }, n.isInViewport = function (i, r, s) { var a = (xt(i) ? mt(i) : i).getBoundingClientRect(), o = a[s ? rr : sr] * r || 0; return s ? a.right - o > 0 && a.left + o < Q.innerWidth : a.bottom - o > 0 && a.top + o < Q.innerHeight }, n.positionInViewport = function (i, r, s) { xt(i) && (i = mt(i)); var a = i.getBoundingClientRect(), o = a[s ? rr : sr], l = r == null ? o / 2 : r in hn ? hn[r] * o : ~r.indexOf("%") ? parseFloat(r) * o / 100 : parseFloat(r) || 0; return s ? (a.left + l) / Q.innerWidth : (a.top + l) / Q.innerHeight }, n.killAll = function (i) { if (X.slice(0).forEach(function (s) { return s.vars.id !== "ScrollSmoother" && s.kill() }), i !== !0) { var r = ur.killAll || []; ur = {}, r.forEach(function (s) { return s() }) } }, n }(); Z.version = "3.12.4"; Z.saveStyles = function (n) { return n ? Es(n).forEach(function (e) { if (e && e.style) { var t = St.indexOf(e); t >= 0 && St.splice(t, 5), St.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), q.core.getCache(e), ma()) } }) : St }; Z.revert = function (n, e) { return Wa(!n, e) }; Z.create = function (n, e) { return new Z(n, e) }; Z.refresh = function (n) { return n ? Jr() : (Sr || Z.register()) && Qi(!0) }; Z.update = function (n) { return ++K.cache && hi(n === !0 ? 2 : 0) }; Z.clearScrollMemory = ld; Z.maxScroll = function (n, e) { return ri(n, e ? ct : Oe) }; Z.getScrollFunc = function (n, e) { return Ii(mt(n), e ? ct : Oe) }; Z.getById = function (n) { return _a[n] }; Z.getAll = function () { return X.filter(function (n) { return n.vars.id !== "ScrollSmoother" }) }; Z.isScrolling = function () { return !!qt }; Z.snapDirectional = Xa; Z.addEventListener = function (n, e) { var t = ur[n] || (ur[n] = []); ~t.indexOf(e) || t.push(e) }; Z.removeEventListener = function (n, e) { var t = ur[n], i = t && t.indexOf(e); i >= 0 && t.splice(i, 1) }; Z.batch = function (n, e) { var t = [], i = {}, r = e.interval || .016, s = e.batchMax || 1e9, a = function (d, c) { var u = [], f = [], p = q.delayedCall(r, function () { c(u, f), u = [], f = [] }).pause(); return function (m) { u.length || p.restart(!0), u.push(m.trigger), f.push(m), s <= u.length && p.progress(1) } }, o; for (o in e) i[o] = o.substr(0, 2) === "on" && ut(e[o]) && o !== "onRefreshInit" ? a(o, e[o]) : e[o]; return ut(s) && (s = s(), Fe(Z, "refresh", function () { return s = e.batchMax() })), Es(n).forEach(function (l) { var d = {}; for (o in i) d[o] = i[o]; d.trigger = l, t.push(Z.create(d)) }), t }; var ko = function (e, t, i, r) { return t > r ? e(r) : t < 0 && e(0), i > r ? (r - t) / (i - t) : i < 0 ? t / (t - i) : 1 }, Hn = function n(e, t) { t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (Ce.isTouch ? " pinch-zoom" : "") : "none", e === Ut && n(ce, t) }, Vs = { auto: 1, scroll: 1 }, tu = function (e) { var t = e.event, i = e.target, r = e.axis, s = (t.changedTouches ? t.changedTouches[0] : t).target, a = s._gsap || q.core.getCache(s), o = lt(), l; if (!a._isScrollT || o - a._isScrollT > 2e3) { for (; s && s !== ce && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(Vs[(l = zt(s)).overflowY] || Vs[l.overflowX]));)s = s.parentNode; a._isScroll = s && s !== i && !cr(s) && (Vs[(l = zt(s)).overflowY] || Vs[l.overflowX]), a._isScrollT = o } (a._isScroll || r === "x") && (t.stopPropagation(), t._gsapAllow = !0) }, ud = function (e, t, i, r) { return Ce.create({ target: e, capture: !0, debounce: !1, lockAxis: !0, type: t, onWheel: r = r && tu, onPress: r, onDrag: r, onScroll: r, onEnable: function () { return i && Fe(he, Ce.eventTypes[0], Io, !1, !0) }, onDisable: function () { return qe(he, Ce.eventTypes[0], Io, !0) } }) }, iu = /(input|label|select|textarea)/i, Oo, Io = function (e) { var t = iu.test(e.target.tagName); (t || Oo) && (e._gsapAllow = !0, Oo = t) }, ru = function (e) { Ui(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer"; var t = e, i = t.normalizeScrollX, r = t.momentum, s = t.allowNestedScroll, a = t.onRelease, o, l, d = mt(e.target) || Ut, c = q.core.globals().ScrollSmoother, u = c && c.get(), f = yi && (e.content && mt(e.content) || u && e.content !== !1 && !u.smooth() && u.content()), p = Ii(d, Oe), m = Ii(d, ct), h = 1, g = (Ce.isTouch && Q.visualViewport ? Q.visualViewport.scale * Q.visualViewport.width : Q.outerWidth) / Q.innerWidth, y = 0, v = ut(r) ? function () { return r(o) } : function () { return r || 2.8 }, _, w, S = ud(d, e.type, !0, s), x = function () { return w = !1 }, P = ei, L = ei, M = function () { l = ri(d, Oe), L = Cr(yi ? 1 : 0, l), i && (P = Cr(0, ri(d, ct))), _ = nr }, E = function () { f._gsap.y = Qr(parseFloat(f._gsap.y) + p.offset) + "px", f.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(f._gsap.y) + ", 0, 1)", p.offset = p.cacheID = 0 }, O = function () { if (w) { requestAnimationFrame(x); var D = Qr(o.deltaY / 2), R = L(p.v - D); if (f && R !== p.v + p.offset) { p.offset = R - p.v; var T = Qr((parseFloat(f && f._gsap.y) || 0) - p.offset); f.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + T + ", 0, 1)", f._gsap.y = T + "px", p.cacheID = K.cache, hi() } return !0 } p.offset && E(), w = !0 }, C, k, b, A, z = function () { M(), C.isActive() && C.vars.scrollY > l && (p() > l ? C.progress(1) && p(l) : C.resetTo("scrollY", l)) }; return f && q.set(f, { y: "+=0" }), e.ignoreCheck = function (I) { return yi && I.type === "touchmove" && O() || h > 1.05 && I.type !== "touchstart" || o.isGesturing || I.touches && I.touches.length > 1 }, e.onPress = function () { w = !1; var I = h; h = Qr((Q.visualViewport && Q.visualViewport.scale || 1) / g), C.pause(), I !== h && Hn(d, h > 1.01 ? !0 : i ? !1 : "x"), k = m(), b = p(), M(), _ = nr }, e.onRelease = e.onGestureStart = function (I, D) { if (p.offset && E(), !D) A.restart(!0); else { K.cache++; var R = v(), T, N; i && (T = m(), N = T + R * .05 * -I.velocityX / .227, R *= ko(m, T, N, ri(d, ct)), C.vars.scrollX = P(N)), T = p(), N = T + R * .05 * -I.velocityY / .227, R *= ko(p, T, N, ri(d, Oe)), C.vars.scrollY = L(N), C.invalidate().duration(R).play(.01), (yi && C.vars.scrollY >= l || T >= l - 1) && q.to({}, { onUpdate: z, duration: R }) } a && a(I) }, e.onWheel = function () { C._ts && C.pause(), lt() - y > 1e3 && (_ = 0, y = lt()) }, e.onChange = function (I, D, R, T, N) { if (nr !== _ && M(), D && i && m(P(T[2] === D ? k + (I.startX - I.x) : m() + D - T[1])), R) { p.offset && E(); var ie = N[2] === R, F = ie ? b + I.startY - I.y : p() + R - N[1], Y = L(F); ie && F !== Y && (b += Y - F), p(Y) } (R || D) && hi() }, e.onEnable = function () { Hn(d, i ? !1 : "x"), Z.addEventListener("refresh", z), Fe(Q, "resize", z), p.smooth && (p.target.style.scrollBehavior = "auto", p.smooth = m.smooth = !1), S.enable() }, e.onDisable = function () { Hn(d, !0), qe(Q, "resize", z), Z.removeEventListener("refresh", z), S.kill() }, e.lockAxis = e.lockAxis !== !1, o = new Ce(e), o.iOS = yi, yi && !p() && p(1), yi && q.ticker.add(ei), A = o._dc, C = q.to(o, { ease: "power4", paused: !0, scrollX: i ? "+=0.1" : "+=0", scrollY: "+=0.1", modifiers: { scrollY: cd(p, p(), function () { return C.pause() }) }, onUpdate: hi, onComplete: A.vars.onComplete }), o }; Z.sort = function (n) { return X.sort(n || function (e, t) { return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6) }) }; Z.observe = function (n) { return new Ce(n) }; Z.normalizeScroll = function (n) { if (typeof n > "u") return nt; if (n === !0 && nt) return nt.enable(); if (n === !1) { nt && nt.kill(), nt = n; return } var e = n instanceof Ce ? n : ru(n); return nt && nt.target === e.target && nt.kill(), cr(e.target) && (nt = e), e }; Z.core = { _getVelocityProp: pa, _inputObserver: ud, _scrollers: K, _proxies: ni, bridge: { ss: function () { qt || fr("scrollStart"), qt = lt() }, ref: function () { return Ke } } }; ed() && q.registerPlugin(Z); Tn.registerPlugin(Z); document.querySelector(".about-work__number") && Tn.fromTo(".about-work__number", { opacity: 0, x: -30 }, { opacity: 1, x: 0, stagger: .2, scrollTrigger: { trigger: ".about-work__title", start: "center 94%", end: "bottom 38%" } }); document.querySelector(".advancements__item") && Tn.fromTo(".advancements__item", { opacity: 0, scale: 0 }, { opacity: 1, scale: 1, stagger: .2, scrollTrigger: { trigger: ".advancements__title", start: "top 94%", end: "center 38%" } }); function Do(n) { return n !== null && typeof n == "object" && "constructor" in n && n.constructor === Object } function ja(n, e) { n === void 0 && (n = {}), e === void 0 && (e = {}), Object.keys(e).forEach(t => { typeof n[t] > "u" ? n[t] = e[t] : Do(e[t]) && Do(n[t]) && Object.keys(e[t]).length > 0 && ja(n[t], e[t]) }) } const fd = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() { } } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName() { return [] } } }, createElementNS() { return {} }, importNode() { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function ft() { const n = typeof document < "u" ? document : {}; return ja(n, fd), n } const su = { document: fd, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle() { return { getPropertyValue() { return "" } } }, Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia() { return {} }, requestAnimationFrame(n) { return typeof setTimeout > "u" ? (n(), null) : setTimeout(n, 0) }, cancelAnimationFrame(n) { typeof setTimeout > "u" || clearTimeout(n) } }; function ye() { const n = typeof window < "u" ? window : {}; return ja(n, su), n } function wi(n) { return n === void 0 && (n = ""), n.trim().split(" ").filter(e => !!e.trim()) } function nu(n) { const e = n; Object.keys(e).forEach(t => { try { e[t] = null } catch { } try { delete e[t] } catch { } }) } function pr(n, e) { return e === void 0 && (e = 0), setTimeout(n, e) } function Rt() { return Date.now() } function au(n) { const e = ye(); let t; return e.getComputedStyle && (t = e.getComputedStyle(n, null)), !t && n.currentStyle && (t = n.currentStyle), t || (t = n.style), t } function ba(n, e) { e === void 0 && (e = "x"); const t = ye(); let i, r, s; const a = au(n); return t.WebKitCSSMatrix ? (r = a.transform || a.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map(o => o.replace(",", ".")).join(", ")), s = new t.WebKitCSSMatrix(r === "none" ? "" : r)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = s.toString().split(",")), e === "x" && (t.WebKitCSSMatrix ? r = s.m41 : i.length === 16 ? r = parseFloat(i[12]) : r = parseFloat(i[4])), e === "y" && (t.WebKitCSSMatrix ? r = s.m42 : i.length === 16 ? r = parseFloat(i[13]) : r = parseFloat(i[5])), r || 0 } function es(n) { return typeof n == "object" && n !== null && n.constructor && Object.prototype.toString.call(n).slice(8, -1) === "Object" } function ou(n) { return typeof window < "u" && typeof window.HTMLElement < "u" ? n instanceof HTMLElement : n && (n.nodeType === 1 || n.nodeType === 11) } function Et() { const n = Object(arguments.length <= 0 ? void 0 : arguments[0]), e = ["__proto__", "constructor", "prototype"]; for (let t = 1; t < arguments.length; t += 1) { const i = t < 0 || arguments.length <= t ? void 0 : arguments[t]; if (i != null && !ou(i)) { const r = Object.keys(Object(i)).filter(s => e.indexOf(s) < 0); for (let s = 0, a = r.length; s < a; s += 1) { const o = r[s], l = Object.getOwnPropertyDescriptor(i, o); l !== void 0 && l.enumerable && (es(n[o]) && es(i[o]) ? i[o].__swiper__ ? n[o] = i[o] : Et(n[o], i[o]) : !es(n[o]) && es(i[o]) ? (n[o] = {}, i[o].__swiper__ ? n[o] = i[o] : Et(n[o], i[o])) : n[o] = i[o]) } } } return n } function ts(n, e, t) { n.style.setProperty(e, t) } function pd(n) { let { swiper: e, targetPosition: t, side: i } = n; const r = ye(), s = -e.translate; let a = null, o; const l = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(e.cssModeFrameID); const d = t > s ? "next" : "prev", c = (f, p) => d === "next" && f >= p || d === "prev" && f <= p, u = () => { o = new Date().getTime(), a === null && (a = o); const f = Math.max(Math.min((o - a) / l, 1), 0), p = .5 - Math.cos(f * Math.PI) / 2; let m = s + p * (t - s); if (c(m, t) && (m = t), e.wrapperEl.scrollTo({ [i]: m }), c(m, t)) { e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [i]: m }) }), r.cancelAnimationFrame(e.cssModeFrameID); return } e.cssModeFrameID = r.requestAnimationFrame(u) }; u() } function mr(n) { return n.querySelector(".swiper-slide-transform") || n.shadowRoot && n.shadowRoot.querySelector(".swiper-slide-transform") || n } function We(n, e) { return e === void 0 && (e = ""), [...n.children].filter(t => t.matches(e)) } function mn(n) { try { console.warn(n); return } catch { } } function At(n, e) { e === void 0 && (e = []); const t = document.createElement(n); return t.classList.add(...Array.isArray(e) ? e : wi(e)), t } function gn(n) { const e = ye(), t = ft(), i = n.getBoundingClientRect(), r = t.body, s = n.clientTop || r.clientTop || 0, a = n.clientLeft || r.clientLeft || 0, o = n === e ? e.scrollY : n.scrollTop, l = n === e ? e.scrollX : n.scrollLeft; return { top: i.top + o - s, left: i.left + l - a } } function lu(n, e) { const t = []; for (; n.previousElementSibling;) { const i = n.previousElementSibling; e ? i.matches(e) && t.push(i) : t.push(i), n = i } return t } function du(n, e) { const t = []; for (; n.nextElementSibling;) { const i = n.nextElementSibling; e ? i.matches(e) && t.push(i) : t.push(i), n = i } return t } function Ci(n, e) { return ye().getComputedStyle(n, null).getPropertyValue(e) } function Cs(n) { let e = n, t; if (e) { for (t = 0; (e = e.previousSibling) !== null;)e.nodeType === 1 && (t += 1); return t } } function ar(n, e) { const t = []; let i = n.parentElement; for (; i;)e ? i.matches(e) && t.push(i) : t.push(i), i = i.parentElement; return t } function ms(n, e) { function t(i) { i.target === n && (e.call(n, i), n.removeEventListener("transitionend", t)) } e && n.addEventListener("transitionend", t) } function Sa(n, e, t) { const i = ye(); return t ? n[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) : n.offsetWidth } let Vn; function cu() { const n = ye(), e = ft(); return { smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior" in e.documentElement.style, touch: !!("ontouchstart" in n || n.DocumentTouch && e instanceof n.DocumentTouch) } } function hd() { return Vn || (Vn = cu()), Vn } let Gn; function uu(n) { let { userAgent: e } = n === void 0 ? {} : n; const t = hd(), i = ye(), r = i.navigator.platform, s = e || i.navigator.userAgent, a = { ios: !1, android: !1 }, o = i.screen.width, l = i.screen.height, d = s.match(/(Android);?[\s\/]+([\d.]+)?/); let c = s.match(/(iPad).*OS\s([\d_]+)/); const u = s.match(/(iPod)(.*OS\s([\d_]+))?/), f = !c && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/), p = r === "Win32"; let m = r === "MacIntel"; const h = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"]; return !c && m && t.touch && h.indexOf(`${o}x${l}`) >= 0 && (c = s.match(/(Version)\/([\d.]+)/), c || (c = [0, 1, "13_0_0"]), m = !1), d && !p && (a.os = "android", a.android = !0), (c || f || u) && (a.os = "ios", a.ios = !0), a } function fu(n) { return n === void 0 && (n = {}), Gn || (Gn = uu(n)), Gn } let Xn; function pu() { const n = ye(); let e = !1; function t() { const i = n.navigator.userAgent.toLowerCase(); return i.indexOf("safari") >= 0 && i.indexOf("chrome") < 0 && i.indexOf("android") < 0 } if (t()) { const i = String(n.navigator.userAgent); if (i.includes("Version/")) { const [r, s] = i.split("Version/")[1].split(" ")[0].split(".").map(a => Number(a)); e = r < 16 || r === 16 && s < 2 } } return { isSafari: e || t(), needPerspectiveFix: e, isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(n.navigator.userAgent) } } function hu() { return Xn || (Xn = pu()), Xn } function mu(n) { let { swiper: e, on: t, emit: i } = n; const r = ye(); let s = null, a = null; const o = () => { !e || e.destroyed || !e.initialized || (i("beforeResize"), i("resize")) }, l = () => { !e || e.destroyed || !e.initialized || (s = new ResizeObserver(u => { a = r.requestAnimationFrame(() => { const { width: f, height: p } = e; let m = f, h = p; u.forEach(g => { let { contentBoxSize: y, contentRect: v, target: _ } = g; _ && _ !== e.el || (m = v ? v.width : (y[0] || y).inlineSize, h = v ? v.height : (y[0] || y).blockSize) }), (m !== f || h !== p) && o() }) }), s.observe(e.el)) }, d = () => { a && r.cancelAnimationFrame(a), s && s.unobserve && e.el && (s.unobserve(e.el), s = null) }, c = () => { !e || e.destroyed || !e.initialized || i("orientationchange") }; t("init", () => { if (e.params.resizeObserver && typeof r.ResizeObserver < "u") { l(); return } r.addEventListener("resize", o), r.addEventListener("orientationchange", c) }), t("destroy", () => { d(), r.removeEventListener("resize", o), r.removeEventListener("orientationchange", c) }) } function gu(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = [], a = ye(), o = function (c, u) { u === void 0 && (u = {}); const f = a.MutationObserver || a.WebkitMutationObserver, p = new f(m => { if (e.__preventObserver__) return; if (m.length === 1) { r("observerUpdate", m[0]); return } const h = function () { r("observerUpdate", m[0]) }; a.requestAnimationFrame ? a.requestAnimationFrame(h) : a.setTimeout(h, 0) }); p.observe(c, { attributes: typeof u.attributes > "u" ? !0 : u.attributes, childList: typeof u.childList > "u" ? !0 : u.childList, characterData: typeof u.characterData > "u" ? !0 : u.characterData }), s.push(p) }, l = () => { if (e.params.observer) { if (e.params.observeParents) { const c = ar(e.hostEl); for (let u = 0; u < c.length; u += 1)o(c[u]) } o(e.hostEl, { childList: e.params.observeSlideChildren }), o(e.wrapperEl, { attributes: !1 }) } }, d = () => { s.forEach(c => { c.disconnect() }), s.splice(0, s.length) }; t({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), i("init", l), i("destroy", d) } var vu = { on(n, e, t) { const i = this; if (!i.eventsListeners || i.destroyed || typeof e != "function") return i; const r = t ? "unshift" : "push"; return n.split(" ").forEach(s => { i.eventsListeners[s] || (i.eventsListeners[s] = []), i.eventsListeners[s][r](e) }), i }, once(n, e, t) { const i = this; if (!i.eventsListeners || i.destroyed || typeof e != "function") return i; function r() { i.off(n, r), r.__emitterProxy && delete r.__emitterProxy; for (var s = arguments.length, a = new Array(s), o = 0; o < s; o++)a[o] = arguments[o]; e.apply(i, a) } return r.__emitterProxy = e, i.on(n, r, t) }, onAny(n, e) { const t = this; if (!t.eventsListeners || t.destroyed || typeof n != "function") return t; const i = e ? "unshift" : "push"; return t.eventsAnyListeners.indexOf(n) < 0 && t.eventsAnyListeners[i](n), t }, offAny(n) { const e = this; if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e; const t = e.eventsAnyListeners.indexOf(n); return t >= 0 && e.eventsAnyListeners.splice(t, 1), e }, off(n, e) { const t = this; return !t.eventsListeners || t.destroyed || !t.eventsListeners || n.split(" ").forEach(i => { typeof e > "u" ? t.eventsListeners[i] = [] : t.eventsListeners[i] && t.eventsListeners[i].forEach((r, s) => { (r === e || r.__emitterProxy && r.__emitterProxy === e) && t.eventsListeners[i].splice(s, 1) }) }), t }, emit() { const n = this; if (!n.eventsListeners || n.destroyed || !n.eventsListeners) return n; let e, t, i; for (var r = arguments.length, s = new Array(r), a = 0; a < r; a++)s[a] = arguments[a]; return typeof s[0] == "string" || Array.isArray(s[0]) ? (e = s[0], t = s.slice(1, s.length), i = n) : (e = s[0].events, t = s[0].data, i = s[0].context || n), t.unshift(i), (Array.isArray(e) ? e : e.split(" ")).forEach(l => { n.eventsAnyListeners && n.eventsAnyListeners.length && n.eventsAnyListeners.forEach(d => { d.apply(i, [l, ...t]) }), n.eventsListeners && n.eventsListeners[l] && n.eventsListeners[l].forEach(d => { d.apply(i, t) }) }), n } }; function _u() { const n = this; let e, t; const i = n.el; typeof n.params.width < "u" && n.params.width !== null ? e = n.params.width : e = i.clientWidth, typeof n.params.height < "u" && n.params.height !== null ? t = n.params.height : t = i.clientHeight, !(e === 0 && n.isHorizontal() || t === 0 && n.isVertical()) && (e = e - parseInt(Ci(i, "padding-left") || 0, 10) - parseInt(Ci(i, "padding-right") || 0, 10), t = t - parseInt(Ci(i, "padding-top") || 0, 10) - parseInt(Ci(i, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(n, { width: e, height: t, size: n.isHorizontal() ? e : t })) } function yu() { const n = this; function e(E, O) { return parseFloat(E.getPropertyValue(n.getDirectionLabel(O)) || 0) } const t = n.params, { wrapperEl: i, slidesEl: r, size: s, rtlTranslate: a, wrongRTL: o } = n, l = n.virtual && t.virtual.enabled, d = l ? n.virtual.slides.length : n.slides.length, c = We(r, `.${n.params.slideClass}, swiper-slide`), u = l ? n.virtual.slides.length : c.length; let f = []; const p = [], m = []; let h = t.slidesOffsetBefore; typeof h == "function" && (h = t.slidesOffsetBefore.call(n)); let g = t.slidesOffsetAfter; typeof g == "function" && (g = t.slidesOffsetAfter.call(n)); const y = n.snapGrid.length, v = n.slidesGrid.length; let _ = t.spaceBetween, w = -h, S = 0, x = 0; if (typeof s > "u") return; typeof _ == "string" && _.indexOf("%") >= 0 ? _ = parseFloat(_.replace("%", "")) / 100 * s : typeof _ == "string" && (_ = parseFloat(_)), n.virtualSize = -_, c.forEach(E => { a ? E.style.marginLeft = "" : E.style.marginRight = "", E.style.marginBottom = "", E.style.marginTop = "" }), t.centeredSlides && t.cssMode && (ts(i, "--swiper-centered-offset-before", ""), ts(i, "--swiper-centered-offset-after", "")); const P = t.grid && t.grid.rows > 1 && n.grid; P ? n.grid.initSlides(c) : n.grid && n.grid.unsetSlides(); let L; const M = t.slidesPerView === "auto" && t.breakpoints && Object.keys(t.breakpoints).filter(E => typeof t.breakpoints[E].slidesPerView < "u").length > 0; for (let E = 0; E < u; E += 1) { L = 0; let O; if (c[E] && (O = c[E]), P && n.grid.updateSlide(E, O, c), !(c[E] && Ci(O, "display") === "none")) { if (t.slidesPerView === "auto") { M && (c[E].style[n.getDirectionLabel("width")] = ""); const C = getComputedStyle(O), k = O.style.transform, b = O.style.webkitTransform; if (k && (O.style.transform = "none"), b && (O.style.webkitTransform = "none"), t.roundLengths) L = n.isHorizontal() ? Sa(O, "width", !0) : Sa(O, "height", !0); else { const A = e(C, "width"), z = e(C, "padding-left"), I = e(C, "padding-right"), D = e(C, "margin-left"), R = e(C, "margin-right"), T = C.getPropertyValue("box-sizing"); if (T && T === "border-box") L = A + D + R; else { const { clientWidth: N, offsetWidth: ie } = O; L = A + z + I + D + R + (ie - N) } } k && (O.style.transform = k), b && (O.style.webkitTransform = b), t.roundLengths && (L = Math.floor(L)) } else L = (s - (t.slidesPerView - 1) * _) / t.slidesPerView, t.roundLengths && (L = Math.floor(L)), c[E] && (c[E].style[n.getDirectionLabel("width")] = `${L}px`); c[E] && (c[E].swiperSlideSize = L), m.push(L), t.centeredSlides ? (w = w + L / 2 + S / 2 + _, S === 0 && E !== 0 && (w = w - s / 2 - _), E === 0 && (w = w - s / 2 - _), Math.abs(w) < 1 / 1e3 && (w = 0), t.roundLengths && (w = Math.floor(w)), x % t.slidesPerGroup === 0 && f.push(w), p.push(w)) : (t.roundLengths && (w = Math.floor(w)), (x - Math.min(n.params.slidesPerGroupSkip, x)) % n.params.slidesPerGroup === 0 && f.push(w), p.push(w), w = w + L + _), n.virtualSize += L + _, S = L, x += 1 } } if (n.virtualSize = Math.max(n.virtualSize, s) + g, a && o && (t.effect === "slide" || t.effect === "coverflow") && (i.style.width = `${n.virtualSize + _}px`), t.setWrapperSize && (i.style[n.getDirectionLabel("width")] = `${n.virtualSize + _}px`), P && n.grid.updateWrapperSize(L, f), !t.centeredSlides) { const E = []; for (let O = 0; O < f.length; O += 1) { let C = f[O]; t.roundLengths && (C = Math.floor(C)), f[O] <= n.virtualSize - s && E.push(C) } f = E, Math.floor(n.virtualSize - s) - Math.floor(f[f.length - 1]) > 1 && f.push(n.virtualSize - s) } if (l && t.loop) { const E = m[0] + _; if (t.slidesPerGroup > 1) { const O = Math.ceil((n.virtual.slidesBefore + n.virtual.slidesAfter) / t.slidesPerGroup), C = E * t.slidesPerGroup; for (let k = 0; k < O; k += 1)f.push(f[f.length - 1] + C) } for (let O = 0; O < n.virtual.slidesBefore + n.virtual.slidesAfter; O += 1)t.slidesPerGroup === 1 && f.push(f[f.length - 1] + E), p.push(p[p.length - 1] + E), n.virtualSize += E } if (f.length === 0 && (f = [0]), _ !== 0) { const E = n.isHorizontal() && a ? "marginLeft" : n.getDirectionLabel("marginRight"); c.filter((O, C) => !t.cssMode || t.loop ? !0 : C !== c.length - 1).forEach(O => { O.style[E] = `${_}px` }) } if (t.centeredSlides && t.centeredSlidesBounds) { let E = 0; m.forEach(C => { E += C + (_ || 0) }), E -= _; const O = E - s; f = f.map(C => C <= 0 ? -h : C > O ? O + g : C) } if (t.centerInsufficientSlides) { let E = 0; if (m.forEach(O => { E += O + (_ || 0) }), E -= _, E < s) { const O = (s - E) / 2; f.forEach((C, k) => { f[k] = C - O }), p.forEach((C, k) => { p[k] = C + O }) } } if (Object.assign(n, { slides: c, snapGrid: f, slidesGrid: p, slidesSizesGrid: m }), t.centeredSlides && t.cssMode && !t.centeredSlidesBounds) { ts(i, "--swiper-centered-offset-before", `${-f[0]}px`), ts(i, "--swiper-centered-offset-after", `${n.size / 2 - m[m.length - 1] / 2}px`); const E = -n.snapGrid[0], O = -n.slidesGrid[0]; n.snapGrid = n.snapGrid.map(C => C + E), n.slidesGrid = n.slidesGrid.map(C => C + O) } if (u !== d && n.emit("slidesLengthChange"), f.length !== y && (n.params.watchOverflow && n.checkOverflow(), n.emit("snapGridLengthChange")), p.length !== v && n.emit("slidesGridLengthChange"), t.watchSlidesProgress && n.updateSlidesOffset(), n.emit("slidesUpdated"), !l && !t.cssMode && (t.effect === "slide" || t.effect === "fade")) { const E = `${t.containerModifierClass}backface-hidden`, O = n.el.classList.contains(E); u <= t.maxBackfaceHiddenSlides ? O || n.el.classList.add(E) : O && n.el.classList.remove(E) } } function wu(n) { const e = this, t = [], i = e.virtual && e.params.virtual.enabled; let r = 0, s; typeof n == "number" ? e.setTransition(n) : n === !0 && e.setTransition(e.params.speed); const a = o => i ? e.slides[e.getSlideIndexByData(o)] : e.slides[o]; if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1) if (e.params.centeredSlides) (e.visibleSlides || []).forEach(o => { t.push(o) }); else for (s = 0; s < Math.ceil(e.params.slidesPerView); s += 1) { const o = e.activeIndex + s; if (o > e.slides.length && !i) break; t.push(a(o)) } else t.push(a(e.activeIndex)); for (s = 0; s < t.length; s += 1)if (typeof t[s] < "u") { const o = t[s].offsetHeight; r = o > r ? o : r } (r || r === 0) && (e.wrapperEl.style.height = `${r}px`) } function bu() { const n = this, e = n.slides, t = n.isElement ? n.isHorizontal() ? n.wrapperEl.offsetLeft : n.wrapperEl.offsetTop : 0; for (let i = 0; i < e.length; i += 1)e[i].swiperSlideOffset = (n.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop) - t - n.cssOverflowAdjustment() } function Su(n) { n === void 0 && (n = this && this.translate || 0); const e = this, t = e.params, { slides: i, rtlTranslate: r, snapGrid: s } = e; if (i.length === 0) return; typeof i[0].swiperSlideOffset > "u" && e.updateSlidesOffset(); let a = -n; r && (a = n), i.forEach(l => { l.classList.remove(t.slideVisibleClass, t.slideFullyVisibleClass) }), e.visibleSlidesIndexes = [], e.visibleSlides = []; let o = t.spaceBetween; typeof o == "string" && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * e.size : typeof o == "string" && (o = parseFloat(o)); for (let l = 0; l < i.length; l += 1) { const d = i[l]; let c = d.swiperSlideOffset; t.cssMode && t.centeredSlides && (c -= i[0].swiperSlideOffset); const u = (a + (t.centeredSlides ? e.minTranslate() : 0) - c) / (d.swiperSlideSize + o), f = (a - s[0] + (t.centeredSlides ? e.minTranslate() : 0) - c) / (d.swiperSlideSize + o), p = -(a - c), m = p + e.slidesSizesGrid[l], h = p >= 0 && p <= e.size - e.slidesSizesGrid[l]; (p >= 0 && p < e.size - 1 || m > 1 && m <= e.size || p <= 0 && m >= e.size) && (e.visibleSlides.push(d), e.visibleSlidesIndexes.push(l), i[l].classList.add(t.slideVisibleClass)), h && i[l].classList.add(t.slideFullyVisibleClass), d.progress = r ? -u : u, d.originalProgress = r ? -f : f } } function xu(n) { const e = this; if (typeof n > "u") { const c = e.rtlTranslate ? -1 : 1; n = e && e.translate && e.translate * c || 0 } const t = e.params, i = e.maxTranslate() - e.minTranslate(); let { progress: r, isBeginning: s, isEnd: a, progressLoop: o } = e; const l = s, d = a; if (i === 0) r = 0, s = !0, a = !0; else { r = (n - e.minTranslate()) / i; const c = Math.abs(n - e.minTranslate()) < 1, u = Math.abs(n - e.maxTranslate()) < 1; s = c || r <= 0, a = u || r >= 1, c && (r = 0), u && (r = 1) } if (t.loop) { const c = e.getSlideIndexByData(0), u = e.getSlideIndexByData(e.slides.length - 1), f = e.slidesGrid[c], p = e.slidesGrid[u], m = e.slidesGrid[e.slidesGrid.length - 1], h = Math.abs(n); h >= f ? o = (h - f) / m : o = (h + m - p) / m, o > 1 && (o -= 1) } Object.assign(e, { progress: r, progressLoop: o, isBeginning: s, isEnd: a }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(n), s && !l && e.emit("reachBeginning toEdge"), a && !d && e.emit("reachEnd toEdge"), (l && !s || d && !a) && e.emit("fromEdge"), e.emit("progress", r) } function Tu() { const n = this, { slides: e, params: t, slidesEl: i, activeIndex: r } = n, s = n.virtual && t.virtual.enabled, a = n.grid && t.grid && t.grid.rows > 1, o = u => We(i, `.${t.slideClass}${u}, swiper-slide${u}`)[0]; e.forEach(u => { u.classList.remove(t.slideActiveClass, t.slideNextClass, t.slidePrevClass) }); let l, d, c; if (s) if (t.loop) { let u = r - n.virtual.slidesBefore; u < 0 && (u = n.virtual.slides.length + u), u >= n.virtual.slides.length && (u -= n.virtual.slides.length), l = o(`[data-swiper-slide-index="${u}"]`) } else l = o(`[data-swiper-slide-index="${r}"]`); else a ? (l = e.filter(u => u.column === r)[0], c = e.filter(u => u.column === r + 1)[0], d = e.filter(u => u.column === r - 1)[0]) : l = e[r]; l && (l.classList.add(t.slideActiveClass), a ? (c && c.classList.add(t.slideNextClass), d && d.classList.add(t.slidePrevClass)) : (c = du(l, `.${t.slideClass}, swiper-slide`)[0], t.loop && !c && (c = e[0]), c && c.classList.add(t.slideNextClass), d = lu(l, `.${t.slideClass}, swiper-slide`)[0], t.loop && !d === 0 && (d = e[e.length - 1]), d && d.classList.add(t.slidePrevClass))), n.emitSlidesClasses() } const rn = (n, e) => { if (!n || n.destroyed || !n.params) return; const t = () => n.isElement ? "swiper-slide" : `.${n.params.slideClass}`, i = e.closest(t()); if (i) { let r = i.querySelector(`.${n.params.lazyPreloaderClass}`); !r && n.isElement && (i.shadowRoot ? r = i.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`) : requestAnimationFrame(() => { i.shadowRoot && (r = i.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`), r && r.remove()) })), r && r.remove() } }, Wn = (n, e) => { if (!n.slides[e]) return; const t = n.slides[e].querySelector('[loading="lazy"]'); t && t.removeAttribute("loading") }, xa = n => { if (!n || n.destroyed || !n.params) return; let e = n.params.lazyPreloadPrevNext; const t = n.slides.length; if (!t || !e || e < 0) return; e = Math.min(e, t); const i = n.params.slidesPerView === "auto" ? n.slidesPerViewDynamic() : Math.ceil(n.params.slidesPerView), r = n.activeIndex; if (n.params.grid && n.params.grid.rows > 1) { const a = r, o = [a - e]; o.push(...Array.from({ length: e }).map((l, d) => a + i + d)), n.slides.forEach((l, d) => { o.includes(l.column) && Wn(n, d) }); return } const s = r + i - 1; if (n.params.rewind || n.params.loop) for (let a = r - e; a <= s + e; a += 1) { const o = (a % t + t) % t; (o < r || o > s) && Wn(n, o) } else for (let a = Math.max(r - e, 0); a <= Math.min(s + e, t - 1); a += 1)a !== r && (a > s || a < r) && Wn(n, a) }; function Eu(n) { const { slidesGrid: e, params: t } = n, i = n.rtlTranslate ? n.translate : -n.translate; let r; for (let s = 0; s < e.length; s += 1)typeof e[s + 1] < "u" ? i >= e[s] && i < e[s + 1] - (e[s + 1] - e[s]) / 2 ? r = s : i >= e[s] && i < e[s + 1] && (r = s + 1) : i >= e[s] && (r = s); return t.normalizeSlideIndex && (r < 0 || typeof r > "u") && (r = 0), r } function Mu(n) { const e = this, t = e.rtlTranslate ? e.translate : -e.translate, { snapGrid: i, params: r, activeIndex: s, realIndex: a, snapIndex: o } = e; let l = n, d; const c = p => { let m = p - e.virtual.slidesBefore; return m < 0 && (m = e.virtual.slides.length + m), m >= e.virtual.slides.length && (m -= e.virtual.slides.length), m }; if (typeof l > "u" && (l = Eu(e)), i.indexOf(t) >= 0) d = i.indexOf(t); else { const p = Math.min(r.slidesPerGroupSkip, l); d = p + Math.floor((l - p) / r.slidesPerGroup) } if (d >= i.length && (d = i.length - 1), l === s && !e.params.loop) { d !== o && (e.snapIndex = d, e.emit("snapIndexChange")); return } if (l === s && e.params.loop && e.virtual && e.params.virtual.enabled) { e.realIndex = c(l); return } const u = e.grid && r.grid && r.grid.rows > 1; let f; if (e.virtual && r.virtual.enabled && r.loop) f = c(l); else if (u) { const p = e.slides.filter(h => h.column === l)[0]; let m = parseInt(p.getAttribute("data-swiper-slide-index"), 10); Number.isNaN(m) && (m = Math.max(e.slides.indexOf(p), 0)), f = Math.floor(m / r.grid.rows) } else if (e.slides[l]) { const p = e.slides[l].getAttribute("data-swiper-slide-index"); p ? f = parseInt(p, 10) : f = l } else f = l; Object.assign(e, { previousSnapIndex: o, snapIndex: d, previousRealIndex: a, realIndex: f, previousIndex: s, activeIndex: l }), e.initialized && xa(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && (a !== f && e.emit("realIndexChange"), e.emit("slideChange")) } function Cu(n, e) { const t = this, i = t.params; let r = n.closest(`.${i.slideClass}, swiper-slide`); !r && t.isElement && e && e.length > 1 && e.includes(n) && [...e.slice(e.indexOf(n) + 1, e.length)].forEach(o => { !r && o.matches && o.matches(`.${i.slideClass}, swiper-slide`) && (r = o) }); let s = !1, a; if (r) { for (let o = 0; o < t.slides.length; o += 1)if (t.slides[o] === r) { s = !0, a = o; break } } if (r && s) t.clickedSlide = r, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = a; else { t.clickedSlide = void 0, t.clickedIndex = void 0; return } i.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } var Pu = { updateSize: _u, updateSlides: yu, updateAutoHeight: wu, updateSlidesOffset: bu, updateSlidesProgress: Su, updateProgress: xu, updateSlidesClasses: Tu, updateActiveIndex: Mu, updateClickedSlide: Cu }; function Au(n) { n === void 0 && (n = this.isHorizontal() ? "x" : "y"); const e = this, { params: t, rtlTranslate: i, translate: r, wrapperEl: s } = e; if (t.virtualTranslate) return i ? -r : r; if (t.cssMode) return r; let a = ba(s, n); return a += e.cssOverflowAdjustment(), i && (a = -a), a || 0 } function Lu(n, e) { const t = this, { rtlTranslate: i, params: r, wrapperEl: s, progress: a } = t; let o = 0, l = 0; const d = 0; t.isHorizontal() ? o = i ? -n : n : l = n, r.roundLengths && (o = Math.floor(o), l = Math.floor(l)), t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? o : l, r.cssMode ? s[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -o : -l : r.virtualTranslate || (t.isHorizontal() ? o -= t.cssOverflowAdjustment() : l -= t.cssOverflowAdjustment(), s.style.transform = `translate3d(${o}px, ${l}px, ${d}px)`); let c; const u = t.maxTranslate() - t.minTranslate(); u === 0 ? c = 0 : c = (n - t.minTranslate()) / u, c !== a && t.updateProgress(n), t.emit("setTranslate", t.translate, e) } function ku() { return -this.snapGrid[0] } function Ou() { return -this.snapGrid[this.snapGrid.length - 1] } function Iu(n, e, t, i, r) { n === void 0 && (n = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), i === void 0 && (i = !0); const s = this, { params: a, wrapperEl: o } = s; if (s.animating && a.preventInteractionOnTransition) return !1; const l = s.minTranslate(), d = s.maxTranslate(); let c; if (i && n > l ? c = l : i && n < d ? c = d : c = n, s.updateProgress(c), a.cssMode) { const u = s.isHorizontal(); if (e === 0) o[u ? "scrollLeft" : "scrollTop"] = -c; else { if (!s.support.smoothScroll) return pd({ swiper: s, targetPosition: -c, side: u ? "left" : "top" }), !0; o.scrollTo({ [u ? "left" : "top"]: -c, behavior: "smooth" }) } return !0 } return e === 0 ? (s.setTransition(0), s.setTranslate(c), t && (s.emit("beforeTransitionStart", e, r), s.emit("transitionEnd"))) : (s.setTransition(e), s.setTranslate(c), t && (s.emit("beforeTransitionStart", e, r), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function (f) { !s || s.destroyed || f.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, t && s.emit("transitionEnd")) }), s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))), !0 } var Du = { getTranslate: Au, setTranslate: Lu, minTranslate: ku, maxTranslate: Ou, translateTo: Iu }; function zu(n, e) { const t = this; t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${n}ms`, t.wrapperEl.style.transitionDelay = n === 0 ? "0ms" : ""), t.emit("setTransition", n, e) } function md(n) { let { swiper: e, runCallbacks: t, direction: i, step: r } = n; const { activeIndex: s, previousIndex: a } = e; let o = i; if (o || (s > a ? o = "next" : s < a ? o = "prev" : o = "reset"), e.emit(`transition${r}`), t && s !== a) { if (o === "reset") { e.emit(`slideResetTransition${r}`); return } e.emit(`slideChangeTransition${r}`), o === "next" ? e.emit(`slideNextTransition${r}`) : e.emit(`slidePrevTransition${r}`) } } function Ru(n, e) { n === void 0 && (n = !0); const t = this, { params: i } = t; i.cssMode || (i.autoHeight && t.updateAutoHeight(), md({ swiper: t, runCallbacks: n, direction: e, step: "Start" })) } function $u(n, e) { n === void 0 && (n = !0); const t = this, { params: i } = t; t.animating = !1, !i.cssMode && (t.setTransition(0), md({ swiper: t, runCallbacks: n, direction: e, step: "End" })) } var Bu = { setTransition: zu, transitionStart: Ru, transitionEnd: $u }; function qu(n, e, t, i, r) { n === void 0 && (n = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), typeof n == "string" && (n = parseInt(n, 10)); const s = this; let a = n; a < 0 && (a = 0); const { params: o, snapGrid: l, slidesGrid: d, previousIndex: c, activeIndex: u, rtlTranslate: f, wrapperEl: p, enabled: m } = s; if (s.animating && o.preventInteractionOnTransition || !m && !i && !r) return !1; const h = Math.min(s.params.slidesPerGroupSkip, a); let g = h + Math.floor((a - h) / s.params.slidesPerGroup); g >= l.length && (g = l.length - 1); const y = -l[g]; if (o.normalizeSlideIndex) for (let _ = 0; _ < d.length; _ += 1) { const w = -Math.floor(y * 100), S = Math.floor(d[_] * 100), x = Math.floor(d[_ + 1] * 100); typeof d[_ + 1] < "u" ? w >= S && w < x - (x - S) / 2 ? a = _ : w >= S && w < x && (a = _ + 1) : w >= S && (a = _) } if (s.initialized && a !== u && (!s.allowSlideNext && (f ? y > s.translate && y > s.minTranslate() : y < s.translate && y < s.minTranslate()) || !s.allowSlidePrev && y > s.translate && y > s.maxTranslate() && (u || 0) !== a)) return !1; a !== (c || 0) && t && s.emit("beforeSlideChangeStart"), s.updateProgress(y); let v; if (a > u ? v = "next" : a < u ? v = "prev" : v = "reset", f && -y === s.translate || !f && y === s.translate) return s.updateActiveIndex(a), o.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), o.effect !== "slide" && s.setTranslate(y), v !== "reset" && (s.transitionStart(t, v), s.transitionEnd(t, v)), !1; if (o.cssMode) { const _ = s.isHorizontal(), w = f ? y : -y; if (e === 0) { const S = s.virtual && s.params.virtual.enabled; S && (s.wrapperEl.style.scrollSnapType = "none", s._immediateVirtual = !0), S && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => { p[_ ? "scrollLeft" : "scrollTop"] = w })) : p[_ ? "scrollLeft" : "scrollTop"] = w, S && requestAnimationFrame(() => { s.wrapperEl.style.scrollSnapType = "", s._immediateVirtual = !1 }) } else { if (!s.support.smoothScroll) return pd({ swiper: s, targetPosition: w, side: _ ? "left" : "top" }), !0; p.scrollTo({ [_ ? "left" : "top"]: w, behavior: "smooth" }) } return !0 } return s.setTransition(e), s.setTranslate(y), s.updateActiveIndex(a), s.updateSlidesClasses(), s.emit("beforeTransitionStart", e, i), s.transitionStart(t, v), e === 0 ? s.transitionEnd(t, v) : s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function (w) { !s || s.destroyed || w.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(t, v)) }), s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)), !0 } function Fu(n, e, t, i) { n === void 0 && (n = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), typeof n == "string" && (n = parseInt(n, 10)); const r = this, s = r.grid && r.params.grid && r.params.grid.rows > 1; let a = n; if (r.params.loop) if (r.virtual && r.params.virtual.enabled) a = a + r.virtual.slidesBefore; else { let o; if (s) { const f = a * r.params.grid.rows; o = r.slides.filter(p => p.getAttribute("data-swiper-slide-index") * 1 === f)[0].column } else o = r.getSlideIndexByData(a); const l = s ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length, { centeredSlides: d } = r.params; let c = r.params.slidesPerView; c === "auto" ? c = r.slidesPerViewDynamic() : (c = Math.ceil(parseFloat(r.params.slidesPerView, 10)), d && c % 2 === 0 && (c = c + 1)); let u = l - o < c; if (d && (u = u || o < Math.ceil(c / 2)), u) { const f = d ? o < r.activeIndex ? "prev" : "next" : o - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev"; r.loopFix({ direction: f, slideTo: !0, activeSlideIndex: f === "next" ? o + 1 : o - l + 1, slideRealIndex: f === "next" ? r.realIndex : void 0 }) } if (s) { const f = a * r.params.grid.rows; a = r.slides.filter(p => p.getAttribute("data-swiper-slide-index") * 1 === f)[0].column } else a = r.getSlideIndexByData(a) } return requestAnimationFrame(() => { r.slideTo(a, e, t, i) }), r } function Nu(n, e, t) { n === void 0 && (n = this.params.speed), e === void 0 && (e = !0); const i = this, { enabled: r, params: s, animating: a } = i; if (!r) return i; let o = s.slidesPerGroup; s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (o = Math.max(i.slidesPerViewDynamic("current", !0), 1)); const l = i.activeIndex < s.slidesPerGroupSkip ? 1 : o, d = i.virtual && s.virtual.enabled; if (s.loop) { if (a && !d && s.loopPreventsSliding) return !1; if (i.loopFix({ direction: "next" }), i._clientLeft = i.wrapperEl.clientLeft, i.activeIndex === i.slides.length - 1 && s.cssMode) return requestAnimationFrame(() => { i.slideTo(i.activeIndex + l, n, e, t) }), !0 } return s.rewind && i.isEnd ? i.slideTo(0, n, e, t) : i.slideTo(i.activeIndex + l, n, e, t) } function Yu(n, e, t) { n === void 0 && (n = this.params.speed), e === void 0 && (e = !0); const i = this, { params: r, snapGrid: s, slidesGrid: a, rtlTranslate: o, enabled: l, animating: d } = i; if (!l) return i; const c = i.virtual && r.virtual.enabled; if (r.loop) { if (d && !c && r.loopPreventsSliding) return !1; i.loopFix({ direction: "prev" }), i._clientLeft = i.wrapperEl.clientLeft } const u = o ? i.translate : -i.translate; function f(y) { return y < 0 ? -Math.floor(Math.abs(y)) : Math.floor(y) } const p = f(u), m = s.map(y => f(y)); let h = s[m.indexOf(p) - 1]; if (typeof h > "u" && r.cssMode) { let y; s.forEach((v, _) => { p >= v && (y = _) }), typeof y < "u" && (h = s[y > 0 ? y - 1 : y]) } let g = 0; if (typeof h < "u" && (g = a.indexOf(h), g < 0 && (g = i.activeIndex - 1), r.slidesPerView === "auto" && r.slidesPerGroup === 1 && r.slidesPerGroupAuto && (g = g - i.slidesPerViewDynamic("previous", !0) + 1, g = Math.max(g, 0))), r.rewind && i.isBeginning) { const y = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1; return i.slideTo(y, n, e, t) } else if (r.loop && i.activeIndex === 0 && r.cssMode) return requestAnimationFrame(() => { i.slideTo(g, n, e, t) }), !0; return i.slideTo(g, n, e, t) } function Hu(n, e, t) { n === void 0 && (n = this.params.speed), e === void 0 && (e = !0); const i = this; return i.slideTo(i.activeIndex, n, e, t) } function Vu(n, e, t, i) { n === void 0 && (n = this.params.speed), e === void 0 && (e = !0), i === void 0 && (i = .5); const r = this; let s = r.activeIndex; const a = Math.min(r.params.slidesPerGroupSkip, s), o = a + Math.floor((s - a) / r.params.slidesPerGroup), l = r.rtlTranslate ? r.translate : -r.translate; if (l >= r.snapGrid[o]) { const d = r.snapGrid[o], c = r.snapGrid[o + 1]; l - d > (c - d) * i && (s += r.params.slidesPerGroup) } else { const d = r.snapGrid[o - 1], c = r.snapGrid[o]; l - d <= (c - d) * i && (s -= r.params.slidesPerGroup) } return s = Math.max(s, 0), s = Math.min(s, r.slidesGrid.length - 1), r.slideTo(s, n, e, t) } function Gu() { const n = this, { params: e, slidesEl: t } = n, i = e.slidesPerView === "auto" ? n.slidesPerViewDynamic() : e.slidesPerView; let r = n.clickedIndex, s; const a = n.isElement ? "swiper-slide" : `.${e.slideClass}`; if (e.loop) { if (n.animating) return; s = parseInt(n.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? r < n.loopedSlides - i / 2 || r > n.slides.length - n.loopedSlides + i / 2 ? (n.loopFix(), r = n.getSlideIndex(We(t, `${a}[data-swiper-slide-index="${s}"]`)[0]), pr(() => { n.slideTo(r) })) : n.slideTo(r) : r > n.slides.length - i ? (n.loopFix(), r = n.getSlideIndex(We(t, `${a}[data-swiper-slide-index="${s}"]`)[0]), pr(() => { n.slideTo(r) })) : n.slideTo(r) } else n.slideTo(r) } var Xu = { slideTo: qu, slideToLoop: Fu, slideNext: Nu, slidePrev: Yu, slideReset: Hu, slideToClosest: Vu, slideToClickedSlide: Gu }; function Wu(n) { const e = this, { params: t, slidesEl: i } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; const r = () => { We(i, `.${t.slideClass}, swiper-slide`).forEach((u, f) => { u.setAttribute("data-swiper-slide-index", f) }) }, s = e.grid && t.grid && t.grid.rows > 1, a = t.slidesPerGroup * (s ? t.grid.rows : 1), o = e.slides.length % a !== 0, l = s && e.slides.length % t.grid.rows !== 0, d = c => { for (let u = 0; u < c; u += 1) { const f = e.isElement ? At("swiper-slide", [t.slideBlankClass]) : At("div", [t.slideClass, t.slideBlankClass]); e.slidesEl.append(f) } }; if (o) { if (t.loopAddBlankSlides) { const c = a - e.slides.length % a; d(c), e.recalcSlides(), e.updateSlides() } else mn("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); r() } else if (l) { if (t.loopAddBlankSlides) { const c = t.grid.rows - e.slides.length % t.grid.rows; d(c), e.recalcSlides(), e.updateSlides() } else mn("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); r() } else r(); e.loopFix({ slideRealIndex: n, direction: t.centeredSlides ? void 0 : "next" }) } function ju(n) { let { slideRealIndex: e, slideTo: t = !0, direction: i, setTranslate: r, activeSlideIndex: s, byController: a, byMousewheel: o } = n === void 0 ? {} : n; const l = this; if (!l.params.loop) return; l.emit("beforeLoopFix"); const { slides: d, allowSlidePrev: c, allowSlideNext: u, slidesEl: f, params: p } = l, { centeredSlides: m } = p; if (l.allowSlidePrev = !0, l.allowSlideNext = !0, l.virtual && p.virtual.enabled) { t && (!p.centeredSlides && l.snapIndex === 0 ? l.slideTo(l.virtual.slides.length, 0, !1, !0) : p.centeredSlides && l.snapIndex < p.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0)), l.allowSlidePrev = c, l.allowSlideNext = u, l.emit("loopFix"); return } let h = p.slidesPerView; h === "auto" ? h = l.slidesPerViewDynamic() : (h = Math.ceil(parseFloat(p.slidesPerView, 10)), m && h % 2 === 0 && (h = h + 1)); const g = p.slidesPerGroupAuto ? h : p.slidesPerGroup; let y = g; y % g !== 0 && (y += g - y % g), y += p.loopAdditionalSlides, l.loopedSlides = y; const v = l.grid && p.grid && p.grid.rows > 1; d.length < h + y ? mn("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : v && p.grid.fill === "row" && mn("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"); const _ = [], w = []; let S = l.activeIndex; typeof s > "u" ? s = l.getSlideIndex(d.filter(k => k.classList.contains(p.slideActiveClass))[0]) : S = s; const x = i === "next" || !i, P = i === "prev" || !i; let L = 0, M = 0; const E = v ? Math.ceil(d.length / p.grid.rows) : d.length, C = (v ? d[s].column : s) + (m && typeof r > "u" ? -h / 2 + .5 : 0); if (C < y) { L = Math.max(y - C, g); for (let k = 0; k < y - C; k += 1) { const b = k - Math.floor(k / E) * E; if (v) { const A = E - b - 1; for (let z = d.length - 1; z >= 0; z -= 1)d[z].column === A && _.push(z) } else _.push(E - b - 1) } } else if (C + h > E - y) { M = Math.max(C - (E - y * 2), g); for (let k = 0; k < M; k += 1) { const b = k - Math.floor(k / E) * E; v ? d.forEach((A, z) => { A.column === b && w.push(z) }) : w.push(b) } } if (l.__preventObserver__ = !0, requestAnimationFrame(() => { l.__preventObserver__ = !1 }), P && _.forEach(k => { d[k].swiperLoopMoveDOM = !0, f.prepend(d[k]), d[k].swiperLoopMoveDOM = !1 }), x && w.forEach(k => { d[k].swiperLoopMoveDOM = !0, f.append(d[k]), d[k].swiperLoopMoveDOM = !1 }), l.recalcSlides(), p.slidesPerView === "auto" ? l.updateSlides() : v && (_.length > 0 && P || w.length > 0 && x) && l.slides.forEach((k, b) => { l.grid.updateSlide(b, k, l.slides) }), p.watchSlidesProgress && l.updateSlidesOffset(), t) { if (_.length > 0 && P) { if (typeof e > "u") { const k = l.slidesGrid[S], A = l.slidesGrid[S + L] - k; o ? l.setTranslate(l.translate - A) : (l.slideTo(S + L, 0, !1, !0), r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - A, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - A)) } else if (r) { const k = v ? _.length / p.grid.rows : _.length; l.slideTo(l.activeIndex + k, 0, !1, !0), l.touchEventsData.currentTranslate = l.translate } } else if (w.length > 0 && x) if (typeof e > "u") { const k = l.slidesGrid[S], A = l.slidesGrid[S - M] - k; o ? l.setTranslate(l.translate - A) : (l.slideTo(S - M, 0, !1, !0), r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - A, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - A)) } else { const k = v ? w.length / p.grid.rows : w.length; l.slideTo(l.activeIndex - k, 0, !1, !0) } } if (l.allowSlidePrev = c, l.allowSlideNext = u, l.controller && l.controller.control && !a) { const k = { slideRealIndex: e, direction: i, setTranslate: r, activeSlideIndex: s, byController: !0 }; Array.isArray(l.controller.control) ? l.controller.control.forEach(b => { !b.destroyed && b.params.loop && b.loopFix({ ...k, slideTo: b.params.slidesPerView === p.slidesPerView ? t : !1 }) }) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({ ...k, slideTo: l.controller.control.params.slidesPerView === p.slidesPerView ? t : !1 }) } l.emit("loopFix") } function Uu() { const n = this, { params: e, slidesEl: t } = n; if (!e.loop || n.virtual && n.params.virtual.enabled) return; n.recalcSlides(); const i = []; n.slides.forEach(r => { const s = typeof r.swiperSlideIndex > "u" ? r.getAttribute("data-swiper-slide-index") * 1 : r.swiperSlideIndex; i[s] = r }), n.slides.forEach(r => { r.removeAttribute("data-swiper-slide-index") }), i.forEach(r => { t.append(r) }), n.recalcSlides(), n.slideTo(n.realIndex, 0) } var Ku = { loopCreate: Wu, loopFix: ju, loopDestroy: Uu }; function Zu(n) { const e = this; if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return; const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl; e.isElement && (e.__preventObserver__ = !0), t.style.cursor = "move", t.style.cursor = n ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => { e.__preventObserver__ = !1 }) } function Qu() { const n = this; n.params.watchOverflow && n.isLocked || n.params.cssMode || (n.isElement && (n.__preventObserver__ = !0), n[n.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", n.isElement && requestAnimationFrame(() => { n.__preventObserver__ = !1 })) } var Ju = { setGrabCursor: Zu, unsetGrabCursor: Qu }; function ef(n, e) { e === void 0 && (e = this); function t(i) { if (!i || i === ft() || i === ye()) return null; i.assignedSlot && (i = i.assignedSlot); const r = i.closest(n); return !r && !i.getRootNode ? null : r || t(i.getRootNode().host) } return t(e) } function zo(n, e, t) { const i = ye(), { params: r } = n, s = r.edgeSwipeDetection, a = r.edgeSwipeThreshold; return s && (t <= a || t >= i.innerWidth - a) ? s === "prevent" ? (e.preventDefault(), !0) : !1 : !0 } function tf(n) { const e = this, t = ft(); let i = n; i.originalEvent && (i = i.originalEvent); const r = e.touchEventsData; if (i.type === "pointerdown") { if (r.pointerId !== null && r.pointerId !== i.pointerId) return; r.pointerId = i.pointerId } else i.type === "touchstart" && i.targetTouches.length === 1 && (r.touchId = i.targetTouches[0].identifier); if (i.type === "touchstart") { zo(e, i, i.targetTouches[0].pageX); return } const { params: s, touches: a, enabled: o } = e; if (!o || !s.simulateTouch && i.pointerType === "mouse" || e.animating && s.preventInteractionOnTransition) return; !e.animating && s.cssMode && s.loop && e.loopFix(); let l = i.target; if (s.touchEventsTarget === "wrapper" && !e.wrapperEl.contains(l) || "which" in i && i.which === 3 || "button" in i && i.button > 0 || r.isTouched && r.isMoved) return; const d = !!s.noSwipingClass && s.noSwipingClass !== "", c = i.composedPath ? i.composedPath() : i.path; d && i.target && i.target.shadowRoot && c && (l = c[0]); const u = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`, f = !!(i.target && i.target.shadowRoot); if (s.noSwiping && (f ? ef(u, l) : l.closest(u))) { e.allowClick = !0; return } if (s.swipeHandler && !l.closest(s.swipeHandler)) return; a.currentX = i.pageX, a.currentY = i.pageY; const p = a.currentX, m = a.currentY; if (!zo(e, i, p)) return; Object.assign(r, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), a.startX = p, a.startY = m, r.touchStartTime = Rt(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, s.threshold > 0 && (r.allowThresholdMove = !1); let h = !0; l.matches(r.focusableElements) && (h = !1, l.nodeName === "SELECT" && (r.isTouched = !1)), t.activeElement && t.activeElement.matches(r.focusableElements) && t.activeElement !== l && t.activeElement.blur(); const g = h && e.allowTouchMove && s.touchStartPreventDefault; (s.touchStartForcePreventDefault || g) && !l.isContentEditable && i.preventDefault(), s.freeMode && s.freeMode.enabled && e.freeMode && e.animating && !s.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", i) } function rf(n) { const e = ft(), t = this, i = t.touchEventsData, { params: r, touches: s, rtlTranslate: a, enabled: o } = t; if (!o || !r.simulateTouch && n.pointerType === "mouse") return; let l = n; if (l.originalEvent && (l = l.originalEvent), l.type === "pointermove" && (i.touchId !== null || l.pointerId !== i.pointerId)) return; let d; if (l.type === "touchmove") { if (d = [...l.changedTouches].filter(x => x.identifier === i.touchId)[0], !d || d.identifier !== i.touchId) return } else d = l; if (!i.isTouched) { i.startMoving && i.isScrolling && t.emit("touchMoveOpposite", l); return } const c = d.pageX, u = d.pageY; if (l.preventedByNestedSwiper) { s.startX = c, s.startY = u; return } if (!t.allowTouchMove) { l.target.matches(i.focusableElements) || (t.allowClick = !1), i.isTouched && (Object.assign(s, { startX: c, startY: u, currentX: c, currentY: u }), i.touchStartTime = Rt()); return } if (r.touchReleaseOnEdges && !r.loop) { if (t.isVertical()) { if (u < s.startY && t.translate <= t.maxTranslate() || u > s.startY && t.translate >= t.minTranslate()) { i.isTouched = !1, i.isMoved = !1; return } } else if (c < s.startX && t.translate <= t.maxTranslate() || c > s.startX && t.translate >= t.minTranslate()) return } if (e.activeElement && l.target === e.activeElement && l.target.matches(i.focusableElements)) { i.isMoved = !0, t.allowClick = !1; return } i.allowTouchCallbacks && t.emit("touchMove", l), s.previousX = s.currentX, s.previousY = s.currentY, s.currentX = c, s.currentY = u; const f = s.currentX - s.startX, p = s.currentY - s.startY; if (t.params.threshold && Math.sqrt(f ** 2 + p ** 2) < t.params.threshold) return; if (typeof i.isScrolling > "u") { let x; t.isHorizontal() && s.currentY === s.startY || t.isVertical() && s.currentX === s.startX ? i.isScrolling = !1 : f * f + p * p >= 25 && (x = Math.atan2(Math.abs(p), Math.abs(f)) * 180 / Math.PI, i.isScrolling = t.isHorizontal() ? x > r.touchAngle : 90 - x > r.touchAngle) } if (i.isScrolling && t.emit("touchMoveOpposite", l), typeof i.startMoving > "u" && (s.currentX !== s.startX || s.currentY !== s.startY) && (i.startMoving = !0), i.isScrolling) { i.isTouched = !1; return } if (!i.startMoving) return; t.allowClick = !1, !r.cssMode && l.cancelable && l.preventDefault(), r.touchMoveStopPropagation && !r.nested && l.stopPropagation(); let m = t.isHorizontal() ? f : p, h = t.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY; r.oneWayMovement && (m = Math.abs(m) * (a ? 1 : -1), h = Math.abs(h) * (a ? 1 : -1)), s.diff = m, m *= r.touchRatio, a && (m = -m, h = -h); const g = t.touchesDirection; t.swipeDirection = m > 0 ? "prev" : "next", t.touchesDirection = h > 0 ? "prev" : "next"; const y = t.params.loop && !r.cssMode, v = t.touchesDirection === "next" && t.allowSlideNext || t.touchesDirection === "prev" && t.allowSlidePrev; if (!i.isMoved) { if (y && v && t.loopFix({ direction: t.swipeDirection }), i.startTranslate = t.getTranslate(), t.setTransition(0), t.animating) { const x = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); t.wrapperEl.dispatchEvent(x) } i.allowMomentumBounce = !1, r.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0), t.emit("sliderFirstMove", l) } let _; if (new Date().getTime(), i.isMoved && i.allowThresholdMove && g !== t.touchesDirection && y && v && Math.abs(m) >= 1) { Object.assign(s, { startX: c, startY: u, currentX: c, currentY: u, startTranslate: i.currentTranslate }), i.loopSwapReset = !0, i.startTranslate = i.currentTranslate; return } t.emit("sliderMove", l), i.isMoved = !0, i.currentTranslate = m + i.startTranslate; let w = !0, S = r.resistanceRatio; if (r.touchReleaseOnEdges && (S = 0), m > 0 ? (y && v && !_ && i.allowThresholdMove && i.currentTranslate > (r.centeredSlides ? t.minTranslate() - t.slidesSizesGrid[t.activeIndex + 1] : t.minTranslate()) && t.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), i.currentTranslate > t.minTranslate() && (w = !1, r.resistance && (i.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + i.startTranslate + m) ** S))) : m < 0 && (y && v && !_ && i.allowThresholdMove && i.currentTranslate < (r.centeredSlides ? t.maxTranslate() + t.slidesSizesGrid[t.slidesSizesGrid.length - 1] : t.maxTranslate()) && t.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: t.slides.length - (r.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10))) }), i.currentTranslate < t.maxTranslate() && (w = !1, r.resistance && (i.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - i.startTranslate - m) ** S))), w && (l.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === "next" && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && t.swipeDirection === "prev" && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && !t.allowSlideNext && (i.currentTranslate = i.startTranslate), r.threshold > 0) if (Math.abs(m) > r.threshold || i.allowThresholdMove) { if (!i.allowThresholdMove) { i.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, i.currentTranslate = i.startTranslate, s.diff = t.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY; return } } else { i.currentTranslate = i.startTranslate; return } !r.followFinger || r.cssMode || ((r.freeMode && r.freeMode.enabled && t.freeMode || r.watchSlidesProgress) && (t.updateActiveIndex(), t.updateSlidesClasses()), r.freeMode && r.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(), t.updateProgress(i.currentTranslate), t.setTranslate(i.currentTranslate)) } function sf(n) { const e = this, t = e.touchEventsData; let i = n; i.originalEvent && (i = i.originalEvent); let r; if (i.type === "touchend" || i.type === "touchcancel") { if (r = [...i.changedTouches].filter(S => S.identifier === t.touchId)[0], !r || r.identifier !== t.touchId) return } else { if (t.touchId !== null || i.pointerId !== t.pointerId) return; r = i } if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(i.type) && !(["pointercancel", "contextmenu"].includes(i.type) && (e.browser.isSafari || e.browser.isWebView))) return; t.pointerId = null, t.touchId = null; const { params: a, touches: o, rtlTranslate: l, slidesGrid: d, enabled: c } = e; if (!c || !a.simulateTouch && i.pointerType === "mouse") return; if (t.allowTouchCallbacks && e.emit("touchEnd", i), t.allowTouchCallbacks = !1, !t.isTouched) { t.isMoved && a.grabCursor && e.setGrabCursor(!1), t.isMoved = !1, t.startMoving = !1; return } a.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1); const u = Rt(), f = u - t.touchStartTime; if (e.allowClick) { const S = i.path || i.composedPath && i.composedPath(); e.updateClickedSlide(S && S[0] || i.target, S), e.emit("tap click", i), f < 300 && u - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", i) } if (t.lastClickTime = Rt(), pr(() => { e.destroyed || (e.allowClick = !0) }), !t.isTouched || !t.isMoved || !e.swipeDirection || o.diff === 0 && !t.loopSwapReset || t.currentTranslate === t.startTranslate && !t.loopSwapReset) { t.isTouched = !1, t.isMoved = !1, t.startMoving = !1; return } t.isTouched = !1, t.isMoved = !1, t.startMoving = !1; let p; if (a.followFinger ? p = l ? e.translate : -e.translate : p = -t.currentTranslate, a.cssMode) return; if (a.freeMode && a.freeMode.enabled) { e.freeMode.onTouchEnd({ currentPos: p }); return } const m = p >= -e.maxTranslate() && !e.params.loop; let h = 0, g = e.slidesSizesGrid[0]; for (let S = 0; S < d.length; S += S < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) { const x = S < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; typeof d[S + x] < "u" ? (m || p >= d[S] && p < d[S + x]) && (h = S, g = d[S + x] - d[S]) : (m || p >= d[S]) && (h = S, g = d[d.length - 1] - d[d.length - 2]) } let y = null, v = null; a.rewind && (e.isBeginning ? v = a.virtual && a.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (y = 0)); const _ = (p - d[h]) / g, w = h < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; if (f > a.longSwipesMs) { if (!a.longSwipes) { e.slideTo(e.activeIndex); return } e.swipeDirection === "next" && (_ >= a.longSwipesRatio ? e.slideTo(a.rewind && e.isEnd ? y : h + w) : e.slideTo(h)), e.swipeDirection === "prev" && (_ > 1 - a.longSwipesRatio ? e.slideTo(h + w) : v !== null && _ < 0 && Math.abs(_) > a.longSwipesRatio ? e.slideTo(v) : e.slideTo(h)) } else { if (!a.shortSwipes) { e.slideTo(e.activeIndex); return } e.navigation && (i.target === e.navigation.nextEl || i.target === e.navigation.prevEl) ? i.target === e.navigation.nextEl ? e.slideTo(h + w) : e.slideTo(h) : (e.swipeDirection === "next" && e.slideTo(y !== null ? y : h + w), e.swipeDirection === "prev" && e.slideTo(v !== null ? v : h)) } } function Ro() { const n = this, { params: e, el: t } = n; if (t && t.offsetWidth === 0) return; e.breakpoints && n.setBreakpoint(); const { allowSlideNext: i, allowSlidePrev: r, snapGrid: s } = n, a = n.virtual && n.params.virtual.enabled; n.allowSlideNext = !0, n.allowSlidePrev = !0, n.updateSize(), n.updateSlides(), n.updateSlidesClasses(); const o = a && e.loop; (e.slidesPerView === "auto" || e.slidesPerView > 1) && n.isEnd && !n.isBeginning && !n.params.centeredSlides && !o ? n.slideTo(n.slides.length - 1, 0, !1, !0) : n.params.loop && !a ? n.slideToLoop(n.realIndex, 0, !1, !0) : n.slideTo(n.activeIndex, 0, !1, !0), n.autoplay && n.autoplay.running && n.autoplay.paused && (clearTimeout(n.autoplay.resizeTimeout), n.autoplay.resizeTimeout = setTimeout(() => { n.autoplay && n.autoplay.running && n.autoplay.paused && n.autoplay.resume() }, 500)), n.allowSlidePrev = r, n.allowSlideNext = i, n.params.watchOverflow && s !== n.snapGrid && n.checkOverflow() } function nf(n) { const e = this; e.enabled && (e.allowClick || (e.params.preventClicks && n.preventDefault(), e.params.preventClicksPropagation && e.animating && (n.stopPropagation(), n.stopImmediatePropagation()))) } function af() { const n = this, { wrapperEl: e, rtlTranslate: t, enabled: i } = n; if (!i) return; n.previousTranslate = n.translate, n.isHorizontal() ? n.translate = -e.scrollLeft : n.translate = -e.scrollTop, n.translate === 0 && (n.translate = 0), n.updateActiveIndex(), n.updateSlidesClasses(); let r; const s = n.maxTranslate() - n.minTranslate(); s === 0 ? r = 0 : r = (n.translate - n.minTranslate()) / s, r !== n.progress && n.updateProgress(t ? -n.translate : n.translate), n.emit("setTranslate", n.translate, !1) } function of(n) { const e = this; rn(e, n.target), !(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update() } function lf() { const n = this; n.documentTouchHandlerProceeded || (n.documentTouchHandlerProceeded = !0, n.params.touchReleaseOnEdges && (n.el.style.touchAction = "auto")) } const gd = (n, e) => { const t = ft(), { params: i, el: r, wrapperEl: s, device: a } = n, o = !!i.nested, l = e === "on" ? "addEventListener" : "removeEventListener", d = e; t[l]("touchstart", n.onDocumentTouchStart, { passive: !1, capture: o }), r[l]("touchstart", n.onTouchStart, { passive: !1 }), r[l]("pointerdown", n.onTouchStart, { passive: !1 }), t[l]("touchmove", n.onTouchMove, { passive: !1, capture: o }), t[l]("pointermove", n.onTouchMove, { passive: !1, capture: o }), t[l]("touchend", n.onTouchEnd, { passive: !0 }), t[l]("pointerup", n.onTouchEnd, { passive: !0 }), t[l]("pointercancel", n.onTouchEnd, { passive: !0 }), t[l]("touchcancel", n.onTouchEnd, { passive: !0 }), t[l]("pointerout", n.onTouchEnd, { passive: !0 }), t[l]("pointerleave", n.onTouchEnd, { passive: !0 }), t[l]("contextmenu", n.onTouchEnd, { passive: !0 }), (i.preventClicks || i.preventClicksPropagation) && r[l]("click", n.onClick, !0), i.cssMode && s[l]("scroll", n.onScroll), i.updateOnWindowResize ? n[d](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", Ro, !0) : n[d]("observerUpdate", Ro, !0), r[l]("load", n.onLoad, { capture: !0 }) }; function df() { const n = this, { params: e } = n; n.onTouchStart = tf.bind(n), n.onTouchMove = rf.bind(n), n.onTouchEnd = sf.bind(n), n.onDocumentTouchStart = lf.bind(n), e.cssMode && (n.onScroll = af.bind(n)), n.onClick = nf.bind(n), n.onLoad = of.bind(n), gd(n, "on") } function cf() { gd(this, "off") } var uf = { attachEvents: df, detachEvents: cf }; const $o = (n, e) => n.grid && e.grid && e.grid.rows > 1; function ff() { const n = this, { realIndex: e, initialized: t, params: i, el: r } = n, s = i.breakpoints; if (!s || s && Object.keys(s).length === 0) return; const a = n.getBreakpoint(s, n.params.breakpointsBase, n.el); if (!a || n.currentBreakpoint === a) return; const l = (a in s ? s[a] : void 0) || n.originalParams, d = $o(n, i), c = $o(n, l), u = i.enabled; d && !c ? (r.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), n.emitContainerClasses()) : !d && c && (r.classList.add(`${i.containerModifierClass}grid`), (l.grid.fill && l.grid.fill === "column" || !l.grid.fill && i.grid.fill === "column") && r.classList.add(`${i.containerModifierClass}grid-column`), n.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach(y => { if (typeof l[y] > "u") return; const v = i[y] && i[y].enabled, _ = l[y] && l[y].enabled; v && !_ && n[y].disable(), !v && _ && n[y].enable() }); const f = l.direction && l.direction !== i.direction, p = i.loop && (l.slidesPerView !== i.slidesPerView || f), m = i.loop; f && t && n.changeDirection(), Et(n.params, l); const h = n.params.enabled, g = n.params.loop; Object.assign(n, { allowTouchMove: n.params.allowTouchMove, allowSlideNext: n.params.allowSlideNext, allowSlidePrev: n.params.allowSlidePrev }), u && !h ? n.disable() : !u && h && n.enable(), n.currentBreakpoint = a, n.emit("_beforeBreakpoint", l), t && (p ? (n.loopDestroy(), n.loopCreate(e), n.updateSlides()) : !m && g ? (n.loopCreate(e), n.updateSlides()) : m && !g && n.loopDestroy()), n.emit("breakpoint", l) } function pf(n, e, t) { if (e === void 0 && (e = "window"), !n || e === "container" && !t) return; let i = !1; const r = ye(), s = e === "window" ? r.innerHeight : t.clientHeight, a = Object.keys(n).map(o => { if (typeof o == "string" && o.indexOf("@") === 0) { const l = parseFloat(o.substr(1)); return { value: s * l, point: o } } return { value: o, point: o } }); a.sort((o, l) => parseInt(o.value, 10) - parseInt(l.value, 10)); for (let o = 0; o < a.length; o += 1) { const { point: l, value: d } = a[o]; e === "window" ? r.matchMedia(`(min-width: ${d}px)`).matches && (i = l) : d <= t.clientWidth && (i = l) } return i || "max" } var hf = { setBreakpoint: ff, getBreakpoint: pf }; function mf(n, e) { const t = []; return n.forEach(i => { typeof i == "object" ? Object.keys(i).forEach(r => { i[r] && t.push(e + r) }) : typeof i == "string" && t.push(e + i) }), t } function gf() { const n = this, { classNames: e, params: t, rtl: i, el: r, device: s } = n, a = mf(["initialized", t.direction, { "free-mode": n.params.freeMode && t.freeMode.enabled }, { autoheight: t.autoHeight }, { rtl: i }, { grid: t.grid && t.grid.rows > 1 }, { "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column" }, { android: s.android }, { ios: s.ios }, { "css-mode": t.cssMode }, { centered: t.cssMode && t.centeredSlides }, { "watch-progress": t.watchSlidesProgress }], t.containerModifierClass); e.push(...a), r.classList.add(...e), n.emitContainerClasses() } function vf() { const n = this, { el: e, classNames: t } = n; e.classList.remove(...t), n.emitContainerClasses() } var _f = { addClasses: gf, removeClasses: vf }; function yf() { const n = this, { isLocked: e, params: t } = n, { slidesOffsetBefore: i } = t; if (i) { const r = n.slides.length - 1, s = n.slidesGrid[r] + n.slidesSizesGrid[r] + i * 2; n.isLocked = n.size > s } else n.isLocked = n.snapGrid.length === 1; t.allowSlideNext === !0 && (n.allowSlideNext = !n.isLocked), t.allowSlidePrev === !0 && (n.allowSlidePrev = !n.isLocked), e && e !== n.isLocked && (n.isEnd = !1), e !== n.isLocked && n.emit(n.isLocked ? "lock" : "unlock") } var wf = { checkOverflow: yf }, Bo = { init: !0, direction: "horizontal", oneWayMovement: !1, touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: "swiper", enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-blank", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideFullyVisibleClass: "swiper-slide-fully-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function bf(n, e) { return function (i) { i === void 0 && (i = {}); const r = Object.keys(i)[0], s = i[r]; if (typeof s != "object" || s === null) { Et(e, i); return } if (n[r] === !0 && (n[r] = { enabled: !0 }), r === "navigation" && n[r] && n[r].enabled && !n[r].prevEl && !n[r].nextEl && (n[r].auto = !0), ["pagination", "scrollbar"].indexOf(r) >= 0 && n[r] && n[r].enabled && !n[r].el && (n[r].auto = !0), !(r in n && "enabled" in s)) { Et(e, i); return } typeof n[r] == "object" && !("enabled" in n[r]) && (n[r].enabled = !0), n[r] || (n[r] = { enabled: !1 }), Et(e, i) } } const jn = { eventsEmitter: vu, update: Pu, translate: Du, transition: Bu, slide: Xu, loop: Ku, grabCursor: Ju, events: uf, breakpoints: hf, checkOverflow: wf, classes: _f }, Un = {}; class Ne { constructor() { let e, t; for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++)r[s] = arguments[s]; r.length === 1 && r[0].constructor && Object.prototype.toString.call(r[0]).slice(8, -1) === "Object" ? t = r[0] : [e, t] = r, t || (t = {}), t = Et({}, t), e && !t.el && (t.el = e); const a = ft(); if (t.el && typeof t.el == "string" && a.querySelectorAll(t.el).length > 1) { const c = []; return a.querySelectorAll(t.el).forEach(u => { const f = Et({}, t, { el: u }); c.push(new Ne(f)) }), c } const o = this; o.__swiper__ = !0, o.support = hd(), o.device = fu({ userAgent: t.userAgent }), o.browser = hu(), o.eventsListeners = {}, o.eventsAnyListeners = [], o.modules = [...o.__modules__], t.modules && Array.isArray(t.modules) && o.modules.push(...t.modules); const l = {}; o.modules.forEach(c => { c({ params: t, swiper: o, extendParams: bf(t, l), on: o.on.bind(o), once: o.once.bind(o), off: o.off.bind(o), emit: o.emit.bind(o) }) }); const d = Et({}, Bo, l); return o.params = Et({}, d, Un, t), o.originalParams = Et({}, o.params), o.passedParams = Et({}, t), o.params && o.params.on && Object.keys(o.params.on).forEach(c => { o.on(c, o.params.on[c]) }), o.params && o.params.onAny && o.onAny(o.params.onAny), Object.assign(o, { enabled: o.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return o.params.direction === "horizontal" }, isVertical() { return o.params.direction === "vertical" }, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: o.params.allowSlideNext, allowSlidePrev: o.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: o.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null }, allowClick: !0, allowTouchMove: o.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), o.emit("_swiper"), o.params.init && o.init(), o } getDirectionLabel(e) { return this.isHorizontal() ? e : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[e] } getSlideIndex(e) { const { slidesEl: t, params: i } = this, r = We(t, `.${i.slideClass}, swiper-slide`), s = Cs(r[0]); return Cs(e) - s } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter(t => t.getAttribute("data-swiper-slide-index") * 1 === e)[0]) } recalcSlides() { const e = this, { slidesEl: t, params: i } = e; e.slides = We(t, `.${i.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const i = this; e = Math.min(Math.max(e, 0), 1); const r = i.minTranslate(), a = (i.maxTranslate() - r) * e + r; i.translateTo(a, typeof t > "u" ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter(i => i.indexOf("swiper") === 0 || i.indexOf(e.params.containerModifierClass) === 0); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter(i => i.indexOf("swiper-slide") === 0 || i.indexOf(t.params.slideClass) === 0).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach(i => { const r = e.getSlideClasses(i); t.push({ slideEl: i, classNames: r }), e.emit("_slideClass", i, r) }), e.emit("_slideClasses", t) } slidesPerViewDynamic(e, t) { e === void 0 && (e = "current"), t === void 0 && (t = !1); const i = this, { params: r, slides: s, slidesGrid: a, slidesSizesGrid: o, size: l, activeIndex: d } = i; let c = 1; if (typeof r.slidesPerView == "number") return r.slidesPerView; if (r.centeredSlides) { let u = s[d] ? s[d].swiperSlideSize : 0, f; for (let p = d + 1; p < s.length; p += 1)s[p] && !f && (u += s[p].swiperSlideSize, c += 1, u > l && (f = !0)); for (let p = d - 1; p >= 0; p -= 1)s[p] && !f && (u += s[p].swiperSlideSize, c += 1, u > l && (f = !0)) } else if (e === "current") for (let u = d + 1; u < s.length; u += 1)(t ? a[u] + o[u] - a[d] < l : a[u] - a[d] < l) && (c += 1); else for (let u = d - 1; u >= 0; u -= 1)a[d] - a[u] < l && (c += 1); return c } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: i } = e; i.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(a => { a.complete && rn(e, a) }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(); function r() { const a = e.rtlTranslate ? e.translate * -1 : e.translate, o = Math.min(Math.max(a, e.maxTranslate()), e.minTranslate()); e.setTranslate(o), e.updateActiveIndex(), e.updateSlidesClasses() } let s; if (i.freeMode && i.freeMode.enabled && !i.cssMode) r(), i.autoHeight && e.updateAutoHeight(); else { if ((i.slidesPerView === "auto" || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) { const a = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides; s = e.slideTo(a.length - 1, 0, !1, !0) } else s = e.slideTo(e.activeIndex, 0, !1, !0); s || r() } i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t) { t === void 0 && (t = !0); const i = this, r = i.params.direction; return e || (e = r === "horizontal" ? "vertical" : "horizontal"), e === r || e !== "horizontal" && e !== "vertical" || (i.el.classList.remove(`${i.params.containerModifierClass}${r}`), i.el.classList.add(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.forEach(s => { e === "vertical" ? s.style.width = "" : s.style.height = "" }), i.emit("changeDirection"), t && i.update()), i } changeLanguageDirection(e) { const t = this; t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl", t.rtlTranslate = t.params.direction === "horizontal" && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let i = e || t.params.el; if (typeof i == "string" && (i = document.querySelector(i)), !i) return !1; i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === "SWIPER-CONTAINER" && (t.isElement = !0); const r = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let a = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(r()) : We(i, r())[0]; return !a && t.params.createElements && (a = At("div", t.params.wrapperClass), i.append(a), We(i, `.${t.params.slideClass}`).forEach(o => { a.append(o) })), Object.assign(t, { el: i, wrapperEl: a, slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : a, hostEl: t.isElement ? i.parentNode.host : i, mounted: !0, rtl: i.dir.toLowerCase() === "rtl" || Ci(i, "direction") === "rtl", rtlTranslate: t.params.direction === "horizontal" && (i.dir.toLowerCase() === "rtl" || Ci(i, "direction") === "rtl"), wrongRTL: Ci(a, "display") === "-webkit-box" }), !0 } init(e) { const t = this; if (t.initialized || t.mount(e) === !1) return t; t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(); const r = [...t.el.querySelectorAll('[loading="lazy"]')]; return t.isElement && r.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), r.forEach(s => { s.complete ? rn(t, s) : s.addEventListener("load", a => { rn(t, a.target) }) }), xa(t), t.initialized = !0, xa(t), t.emit("init"), t.emit("afterInit"), t } destroy(e, t) { e === void 0 && (e = !0), t === void 0 && (t = !0); const i = this, { params: r, el: s, wrapperEl: a, slides: o } = i; return typeof i.params > "u" || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), r.loop && i.loopDestroy(), t && (i.removeClasses(), s.removeAttribute("style"), a.removeAttribute("style"), o && o.length && o.forEach(l => { l.classList.remove(r.slideVisibleClass, r.slideFullyVisibleClass, r.slideActiveClass, r.slideNextClass, r.slidePrevClass), l.removeAttribute("style"), l.removeAttribute("data-swiper-slide-index") })), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(l => { i.off(l) }), e !== !1 && (i.el.swiper = null, nu(i)), i.destroyed = !0), null } static extendDefaults(e) { Et(Un, e) } static get extendedDefaults() { return Un } static get defaults() { return Bo } static installModule(e) { Ne.prototype.__modules__ || (Ne.prototype.__modules__ = []); const t = Ne.prototype.__modules__; typeof e == "function" && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach(t => Ne.installModule(t)), Ne) : (Ne.installModule(e), Ne) } } Object.keys(jn).forEach(n => { Object.keys(jn[n]).forEach(e => { Ne.prototype[e] = jn[n][e] }) }); Ne.use([mu, gu]); function Sf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; t({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }); let s; const a = ft(); e.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }; const o = a.createElement("div"); function l(m, h) { const g = e.params.virtual; if (g.cache && e.virtual.cache[h]) return e.virtual.cache[h]; let y; return g.renderSlide ? (y = g.renderSlide.call(e, m, h), typeof y == "string" && (o.innerHTML = y, y = o.children[0])) : e.isElement ? y = At("swiper-slide") : y = At("div", e.params.slideClass), y.setAttribute("data-swiper-slide-index", h), g.renderSlide || (y.innerHTML = m), g.cache && (e.virtual.cache[h] = y), y } function d(m) { const { slidesPerView: h, slidesPerGroup: g, centeredSlides: y, loop: v } = e.params, { addSlidesBefore: _, addSlidesAfter: w } = e.params.virtual, { from: S, to: x, slides: P, slidesGrid: L, offset: M } = e.virtual; e.params.cssMode || e.updateActiveIndex(); const E = e.activeIndex || 0; let O; e.rtlTranslate ? O = "right" : O = e.isHorizontal() ? "left" : "top"; let C, k; y ? (C = Math.floor(h / 2) + g + w, k = Math.floor(h / 2) + g + _) : (C = h + (g - 1) + w, k = (v ? h : g) + _); let b = E - k, A = E + C; v || (b = Math.max(b, 0), A = Math.min(A, P.length - 1)); let z = (e.slidesGrid[b] || 0) - (e.slidesGrid[0] || 0); v && E >= k ? (b -= k, y || (z += e.slidesGrid[0])) : v && E < k && (b = -k, y && (z += e.slidesGrid[0])), Object.assign(e.virtual, { from: b, to: A, offset: z, slidesGrid: e.slidesGrid, slidesBefore: k, slidesAfter: C }); function I() { e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), r("virtualUpdate") } if (S === b && x === A && !m) { e.slidesGrid !== L && z !== M && e.slides.forEach(F => { F.style[O] = `${z - Math.abs(e.cssOverflowAdjustment())}px` }), e.updateProgress(), r("virtualUpdate"); return } if (e.params.virtual.renderExternal) { e.params.virtual.renderExternal.call(e, { offset: z, from: b, to: A, slides: function () { const Y = []; for (let se = b; se <= A; se += 1)Y.push(P[se]); return Y }() }), e.params.virtual.renderExternalUpdate ? I() : r("virtualUpdate"); return } const D = [], R = [], T = F => { let Y = F; return F < 0 ? Y = P.length + F : Y >= P.length && (Y = Y - P.length), Y }; if (m) e.slides.filter(F => F.matches(`.${e.params.slideClass}, swiper-slide`)).forEach(F => { F.remove() }); else for (let F = S; F <= x; F += 1)if (F < b || F > A) { const Y = T(F); e.slides.filter(se => se.matches(`.${e.params.slideClass}[data-swiper-slide-index="${Y}"], swiper-slide[data-swiper-slide-index="${Y}"]`)).forEach(se => { se.remove() }) } const N = v ? -P.length : 0, ie = v ? P.length * 2 : P.length; for (let F = N; F < ie; F += 1)if (F >= b && F <= A) { const Y = T(F); typeof x > "u" || m ? R.push(Y) : (F > x && R.push(Y), F < S && D.push(Y)) } if (R.forEach(F => { e.slidesEl.append(l(P[F], F)) }), v) for (let F = D.length - 1; F >= 0; F -= 1) { const Y = D[F]; e.slidesEl.prepend(l(P[Y], Y)) } else D.sort((F, Y) => Y - F), D.forEach(F => { e.slidesEl.prepend(l(P[F], F)) }); We(e.slidesEl, ".swiper-slide, swiper-slide").forEach(F => { F.style[O] = `${z - Math.abs(e.cssOverflowAdjustment())}px` }), I() } function c(m) { if (typeof m == "object" && "length" in m) for (let h = 0; h < m.length; h += 1)m[h] && e.virtual.slides.push(m[h]); else e.virtual.slides.push(m); d(!0) } function u(m) { const h = e.activeIndex; let g = h + 1, y = 1; if (Array.isArray(m)) { for (let v = 0; v < m.length; v += 1)m[v] && e.virtual.slides.unshift(m[v]); g = h + m.length, y = m.length } else e.virtual.slides.unshift(m); if (e.params.virtual.cache) { const v = e.virtual.cache, _ = {}; Object.keys(v).forEach(w => { const S = v[w], x = S.getAttribute("data-swiper-slide-index"); x && S.setAttribute("data-swiper-slide-index", parseInt(x, 10) + y), _[parseInt(w, 10) + y] = S }), e.virtual.cache = _ } d(!0), e.slideTo(g, 0) } function f(m) { if (typeof m > "u" || m === null) return; let h = e.activeIndex; if (Array.isArray(m)) for (let g = m.length - 1; g >= 0; g -= 1)e.params.virtual.cache && (delete e.virtual.cache[m[g]], Object.keys(e.virtual.cache).forEach(y => { y > m && (e.virtual.cache[y - 1] = e.virtual.cache[y], e.virtual.cache[y - 1].setAttribute("data-swiper-slide-index", y - 1), delete e.virtual.cache[y]) })), e.virtual.slides.splice(m[g], 1), m[g] < h && (h -= 1), h = Math.max(h, 0); else e.params.virtual.cache && (delete e.virtual.cache[m], Object.keys(e.virtual.cache).forEach(g => { g > m && (e.virtual.cache[g - 1] = e.virtual.cache[g], e.virtual.cache[g - 1].setAttribute("data-swiper-slide-index", g - 1), delete e.virtual.cache[g]) })), e.virtual.slides.splice(m, 1), m < h && (h -= 1), h = Math.max(h, 0); d(!0), e.slideTo(h, 0) } function p() { e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), d(!0), e.slideTo(0, 0) } i("beforeInit", () => { if (!e.params.virtual.enabled) return; let m; if (typeof e.passedParams.virtual.slides > "u") { const h = [...e.slidesEl.children].filter(g => g.matches(`.${e.params.slideClass}, swiper-slide`)); h && h.length && (e.virtual.slides = [...h], m = !0, h.forEach((g, y) => { g.setAttribute("data-swiper-slide-index", y), e.virtual.cache[y] = g, g.remove() })) } m || (e.virtual.slides = e.params.virtual.slides), e.classNames.push(`${e.params.containerModifierClass}virtual`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0, d() }), i("setTranslate", () => { e.params.virtual.enabled && (e.params.cssMode && !e._immediateVirtual ? (clearTimeout(s), s = setTimeout(() => { d() }, 100)) : d()) }), i("init update resize", () => { e.params.virtual.enabled && e.params.cssMode && ts(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`) }), Object.assign(e.virtual, { appendSlide: c, prependSlide: u, removeSlide: f, removeAllSlides: p, update: d }) } function xf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = ft(), a = ye(); e.keyboard = { enabled: !1 }, t({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }); function o(c) { if (!e.enabled) return; const { rtlTranslate: u } = e; let f = c; f.originalEvent && (f = f.originalEvent); const p = f.keyCode || f.charCode, m = e.params.keyboard.pageUpDown, h = m && p === 33, g = m && p === 34, y = p === 37, v = p === 39, _ = p === 38, w = p === 40; if (!e.allowSlideNext && (e.isHorizontal() && v || e.isVertical() && w || g) || !e.allowSlidePrev && (e.isHorizontal() && y || e.isVertical() && _ || h)) return !1; if (!(f.shiftKey || f.altKey || f.ctrlKey || f.metaKey) && !(s.activeElement && s.activeElement.nodeName && (s.activeElement.nodeName.toLowerCase() === "input" || s.activeElement.nodeName.toLowerCase() === "textarea"))) { if (e.params.keyboard.onlyInViewport && (h || g || y || v || _ || w)) { let S = !1; if (ar(e.el, `.${e.params.slideClass}, swiper-slide`).length > 0 && ar(e.el, `.${e.params.slideActiveClass}`).length === 0) return; const x = e.el, P = x.clientWidth, L = x.clientHeight, M = a.innerWidth, E = a.innerHeight, O = gn(x); u && (O.left -= x.scrollLeft); const C = [[O.left, O.top], [O.left + P, O.top], [O.left, O.top + L], [O.left + P, O.top + L]]; for (let k = 0; k < C.length; k += 1) { const b = C[k]; if (b[0] >= 0 && b[0] <= M && b[1] >= 0 && b[1] <= E) { if (b[0] === 0 && b[1] === 0) continue; S = !0 } } if (!S) return } e.isHorizontal() ? ((h || g || y || v) && (f.preventDefault ? f.preventDefault() : f.returnValue = !1), ((g || v) && !u || (h || y) && u) && e.slideNext(), ((h || y) && !u || (g || v) && u) && e.slidePrev()) : ((h || g || _ || w) && (f.preventDefault ? f.preventDefault() : f.returnValue = !1), (g || w) && e.slideNext(), (h || _) && e.slidePrev()), r("keyPress", p) } } function l() { e.keyboard.enabled || (s.addEventListener("keydown", o), e.keyboard.enabled = !0) } function d() { e.keyboard.enabled && (s.removeEventListener("keydown", o), e.keyboard.enabled = !1) } i("init", () => { e.params.keyboard.enabled && l() }), i("destroy", () => { e.keyboard.enabled && d() }), Object.assign(e.keyboard, { enable: l, disable: d }) } function Tf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = ye(); t({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null, noMousewheelClass: "swiper-no-mousewheel" } }), e.mousewheel = { enabled: !1 }; let a, o = Rt(), l; const d = []; function c(_) { let P = 0, L = 0, M = 0, E = 0; return "detail" in _ && (L = _.detail), "wheelDelta" in _ && (L = -_.wheelDelta / 120), "wheelDeltaY" in _ && (L = -_.wheelDeltaY / 120), "wheelDeltaX" in _ && (P = -_.wheelDeltaX / 120), "axis" in _ && _.axis === _.HORIZONTAL_AXIS && (P = L, L = 0), M = P * 10, E = L * 10, "deltaY" in _ && (E = _.deltaY), "deltaX" in _ && (M = _.deltaX), _.shiftKey && !M && (M = E, E = 0), (M || E) && _.deltaMode && (_.deltaMode === 1 ? (M *= 40, E *= 40) : (M *= 800, E *= 800)), M && !P && (P = M < 1 ? -1 : 1), E && !L && (L = E < 1 ? -1 : 1), { spinX: P, spinY: L, pixelX: M, pixelY: E } } function u() { e.enabled && (e.mouseEntered = !0) } function f() { e.enabled && (e.mouseEntered = !1) } function p(_) { return e.params.mousewheel.thresholdDelta && _.delta < e.params.mousewheel.thresholdDelta || e.params.mousewheel.thresholdTime && Rt() - o < e.params.mousewheel.thresholdTime ? !1 : _.delta >= 6 && Rt() - o < 60 ? !0 : (_.direction < 0 ? (!e.isEnd || e.params.loop) && !e.animating && (e.slideNext(), r("scroll", _.raw)) : (!e.isBeginning || e.params.loop) && !e.animating && (e.slidePrev(), r("scroll", _.raw)), o = new s.Date().getTime(), !1) } function m(_) { const w = e.params.mousewheel; if (_.direction < 0) { if (e.isEnd && !e.params.loop && w.releaseOnEdges) return !0 } else if (e.isBeginning && !e.params.loop && w.releaseOnEdges) return !0; return !1 } function h(_) { let w = _, S = !0; if (!e.enabled || _.target.closest(`.${e.params.mousewheel.noMousewheelClass}`)) return; const x = e.params.mousewheel; e.params.cssMode && w.preventDefault(); let P = e.el; e.params.mousewheel.eventsTarget !== "container" && (P = document.querySelector(e.params.mousewheel.eventsTarget)); const L = P && P.contains(w.target); if (!e.mouseEntered && !L && !x.releaseOnEdges) return !0; w.originalEvent && (w = w.originalEvent); let M = 0; const E = e.rtlTranslate ? -1 : 1, O = c(w); if (x.forceToAxis) if (e.isHorizontal()) if (Math.abs(O.pixelX) > Math.abs(O.pixelY)) M = -O.pixelX * E; else return !0; else if (Math.abs(O.pixelY) > Math.abs(O.pixelX)) M = -O.pixelY; else return !0; else M = Math.abs(O.pixelX) > Math.abs(O.pixelY) ? -O.pixelX * E : -O.pixelY; if (M === 0) return !0; x.invert && (M = -M); let C = e.getTranslate() + M * x.sensitivity; if (C >= e.minTranslate() && (C = e.minTranslate()), C <= e.maxTranslate() && (C = e.maxTranslate()), S = e.params.loop ? !0 : !(C === e.minTranslate() || C === e.maxTranslate()), S && e.params.nested && w.stopPropagation(), !e.params.freeMode || !e.params.freeMode.enabled) { const k = { time: Rt(), delta: Math.abs(M), direction: Math.sign(M), raw: _ }; d.length >= 2 && d.shift(); const b = d.length ? d[d.length - 1] : void 0; if (d.push(k), b ? (k.direction !== b.direction || k.delta > b.delta || k.time > b.time + 150) && p(k) : p(k), m(k)) return !0 } else { const k = { time: Rt(), delta: Math.abs(M), direction: Math.sign(M) }, b = l && k.time < l.time + 500 && k.delta <= l.delta && k.direction === l.direction; if (!b) { l = void 0; let A = e.getTranslate() + M * x.sensitivity; const z = e.isBeginning, I = e.isEnd; if (A >= e.minTranslate() && (A = e.minTranslate()), A <= e.maxTranslate() && (A = e.maxTranslate()), e.setTransition(0), e.setTranslate(A), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses(), (!z && e.isBeginning || !I && e.isEnd) && e.updateSlidesClasses(), e.params.loop && e.loopFix({ direction: k.direction < 0 ? "next" : "prev", byMousewheel: !0 }), e.params.freeMode.sticky) { clearTimeout(a), a = void 0, d.length >= 15 && d.shift(); const D = d.length ? d[d.length - 1] : void 0, R = d[0]; if (d.push(k), D && (k.delta > D.delta || k.direction !== D.direction)) d.splice(0); else if (d.length >= 15 && k.time - R.time < 500 && R.delta - k.delta >= 1 && k.delta <= 6) { const T = M > 0 ? .8 : .2; l = k, d.splice(0), a = pr(() => { e.slideToClosest(e.params.speed, !0, void 0, T) }, 0) } a || (a = pr(() => { l = k, d.splice(0), e.slideToClosest(e.params.speed, !0, void 0, .5) }, 500)) } if (b || r("scroll", w), e.params.autoplay && e.params.autoplayDisableOnInteraction && e.autoplay.stop(), x.releaseOnEdges && (A === e.minTranslate() || A === e.maxTranslate())) return !0 } } return w.preventDefault ? w.preventDefault() : w.returnValue = !1, !1 } function g(_) { let w = e.el; e.params.mousewheel.eventsTarget !== "container" && (w = document.querySelector(e.params.mousewheel.eventsTarget)), w[_]("mouseenter", u), w[_]("mouseleave", f), w[_]("wheel", h) } function y() { return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", h), !0) : e.mousewheel.enabled ? !1 : (g("addEventListener"), e.mousewheel.enabled = !0, !0) } function v() { return e.params.cssMode ? (e.wrapperEl.addEventListener(event, h), !0) : e.mousewheel.enabled ? (g("removeEventListener"), e.mousewheel.enabled = !1, !0) : !1 } i("init", () => { !e.params.mousewheel.enabled && e.params.cssMode && v(), e.params.mousewheel.enabled && y() }), i("destroy", () => { e.params.cssMode && y(), e.mousewheel.enabled && v() }), Object.assign(e.mousewheel, { enable: y, disable: v }) } function Ua(n, e, t, i) { return n.params.createElements && Object.keys(i).forEach(r => { if (!t[r] && t.auto === !0) { let s = We(n.el, `.${i[r]}`)[0]; s || (s = At("div", i[r]), s.className = i[r], n.el.append(s)), t[r] = s, e[r] = s } }), t } function Ef(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; t({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), e.navigation = { nextEl: null, prevEl: null }; const s = h => (Array.isArray(h) ? h : [h]).filter(g => !!g); function a(h) { let g; return h && typeof h == "string" && e.isElement && (g = e.el.querySelector(h), g) ? g : (h && (typeof h == "string" && (g = [...document.querySelectorAll(h)]), e.params.uniqueNavElements && typeof h == "string" && g.length > 1 && e.el.querySelectorAll(h).length === 1 && (g = e.el.querySelector(h))), h && !g ? h : g) } function o(h, g) { const y = e.params.navigation; h = s(h), h.forEach(v => { v && (v.classList[g ? "add" : "remove"](...y.disabledClass.split(" ")), v.tagName === "BUTTON" && (v.disabled = g), e.params.watchOverflow && e.enabled && v.classList[e.isLocked ? "add" : "remove"](y.lockClass)) }) } function l() { const { nextEl: h, prevEl: g } = e.navigation; if (e.params.loop) { o(g, !1), o(h, !1); return } o(g, e.isBeginning && !e.params.rewind), o(h, e.isEnd && !e.params.rewind) } function d(h) { h.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), r("navigationPrev")) } function c(h) { h.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), r("navigationNext")) } function u() { const h = e.params.navigation; if (e.params.navigation = Ua(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !(h.nextEl || h.prevEl)) return; let g = a(h.nextEl), y = a(h.prevEl); Object.assign(e.navigation, { nextEl: g, prevEl: y }), g = s(g), y = s(y); const v = (_, w) => { _ && _.addEventListener("click", w === "next" ? c : d), !e.enabled && _ && _.classList.add(...h.lockClass.split(" ")) }; g.forEach(_ => v(_, "next")), y.forEach(_ => v(_, "prev")) } function f() { let { nextEl: h, prevEl: g } = e.navigation; h = s(h), g = s(g); const y = (v, _) => { v.removeEventListener("click", _ === "next" ? c : d), v.classList.remove(...e.params.navigation.disabledClass.split(" ")) }; h.forEach(v => y(v, "next")), g.forEach(v => y(v, "prev")) } i("init", () => { e.params.navigation.enabled === !1 ? m() : (u(), l()) }), i("toEdge fromEdge lock unlock", () => { l() }), i("destroy", () => { f() }), i("enable disable", () => { let { nextEl: h, prevEl: g } = e.navigation; if (h = s(h), g = s(g), e.enabled) { l(); return } [...h, ...g].filter(y => !!y).forEach(y => y.classList.add(e.params.navigation.lockClass)) }), i("click", (h, g) => { let { nextEl: y, prevEl: v } = e.navigation; y = s(y), v = s(v); const _ = g.target; if (e.params.navigation.hideOnClick && !v.includes(_) && !y.includes(_)) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === _ || e.pagination.el.contains(_))) return; let w; y.length ? w = y[0].classList.contains(e.params.navigation.hiddenClass) : v.length && (w = v[0].classList.contains(e.params.navigation.hiddenClass)), r(w === !0 ? "navigationShow" : "navigationHide"), [...y, ...v].filter(S => !!S).forEach(S => S.classList.toggle(e.params.navigation.hiddenClass)) } }); const p = () => { e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), u(), l() }, m = () => { e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), f() }; Object.assign(e.navigation, { enable: p, disable: m, update: l, init: u, destroy: f }) } function fi(n) { return n === void 0 && (n = ""), `.${n.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}` } function Mf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = "swiper-pagination"; t({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: v => v, formatFractionTotal: v => v, bulletClass: `${s}-bullet`, bulletActiveClass: `${s}-bullet-active`, modifierClass: `${s}-`, currentClass: `${s}-current`, totalClass: `${s}-total`, hiddenClass: `${s}-hidden`, progressbarFillClass: `${s}-progressbar-fill`, progressbarOppositeClass: `${s}-progressbar-opposite`, clickableClass: `${s}-clickable`, lockClass: `${s}-lock`, horizontalClass: `${s}-horizontal`, verticalClass: `${s}-vertical`, paginationDisabledClass: `${s}-disabled` } }), e.pagination = { el: null, bullets: [] }; let a, o = 0; const l = v => (Array.isArray(v) ? v : [v]).filter(_ => !!_); function d() { return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0 } function c(v, _) { const { bulletActiveClass: w } = e.params.pagination; v && (v = v[`${_ === "prev" ? "previous" : "next"}ElementSibling`], v && (v.classList.add(`${w}-${_}`), v = v[`${_ === "prev" ? "previous" : "next"}ElementSibling`], v && v.classList.add(`${w}-${_}-${_}`))) } function u(v) { const _ = v.target.closest(fi(e.params.pagination.bulletClass)); if (!_) return; v.preventDefault(); const w = Cs(_) * e.params.slidesPerGroup; if (e.params.loop) { if (e.realIndex === w) return; e.slideToLoop(w) } else e.slideTo(w) } function f() { const v = e.rtl, _ = e.params.pagination; if (d()) return; let w = e.pagination.el; w = l(w); let S, x; const P = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, L = e.params.loop ? Math.ceil(P / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (x = e.previousRealIndex || 0, S = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (S = e.snapIndex, x = e.previousSnapIndex) : (x = e.previousIndex || 0, S = e.activeIndex || 0), _.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) { const M = e.pagination.bullets; let E, O, C; if (_.dynamicBullets && (a = Sa(M[0], e.isHorizontal() ? "width" : "height", !0), w.forEach(k => { k.style[e.isHorizontal() ? "width" : "height"] = `${a * (_.dynamicMainBullets + 4)}px` }), _.dynamicMainBullets > 1 && x !== void 0 && (o += S - (x || 0), o > _.dynamicMainBullets - 1 ? o = _.dynamicMainBullets - 1 : o < 0 && (o = 0)), E = Math.max(S - o, 0), O = E + (Math.min(M.length, _.dynamicMainBullets) - 1), C = (O + E) / 2), M.forEach(k => { const b = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(A => `${_.bulletActiveClass}${A}`)].map(A => typeof A == "string" && A.includes(" ") ? A.split(" ") : A).flat(); k.classList.remove(...b) }), w.length > 1) M.forEach(k => { const b = Cs(k); b === S ? k.classList.add(..._.bulletActiveClass.split(" ")) : e.isElement && k.setAttribute("part", "bullet"), _.dynamicBullets && (b >= E && b <= O && k.classList.add(...`${_.bulletActiveClass}-main`.split(" ")), b === E && c(k, "prev"), b === O && c(k, "next")) }); else { const k = M[S]; if (k && k.classList.add(..._.bulletActiveClass.split(" ")), e.isElement && M.forEach((b, A) => { b.setAttribute("part", A === S ? "bullet-active" : "bullet") }), _.dynamicBullets) { const b = M[E], A = M[O]; for (let z = E; z <= O; z += 1)M[z] && M[z].classList.add(...`${_.bulletActiveClass}-main`.split(" ")); c(b, "prev"), c(A, "next") } } if (_.dynamicBullets) { const k = Math.min(M.length, _.dynamicMainBullets + 4), b = (a * k - a) / 2 - C * a, A = v ? "right" : "left"; M.forEach(z => { z.style[e.isHorizontal() ? A : "top"] = `${b}px` }) } } w.forEach((M, E) => { if (_.type === "fraction" && (M.querySelectorAll(fi(_.currentClass)).forEach(O => { O.textContent = _.formatFractionCurrent(S + 1) }), M.querySelectorAll(fi(_.totalClass)).forEach(O => { O.textContent = _.formatFractionTotal(L) })), _.type === "progressbar") { let O; _.progressbarOpposite ? O = e.isHorizontal() ? "vertical" : "horizontal" : O = e.isHorizontal() ? "horizontal" : "vertical"; const C = (S + 1) / L; let k = 1, b = 1; O === "horizontal" ? k = C : b = C, M.querySelectorAll(fi(_.progressbarFillClass)).forEach(A => { A.style.transform = `translate3d(0,0,0) scaleX(${k}) scaleY(${b})`, A.style.transitionDuration = `${e.params.speed}ms` }) } _.type === "custom" && _.renderCustom ? (M.innerHTML = _.renderCustom(e, S + 1, L), E === 0 && r("paginationRender", M)) : (E === 0 && r("paginationRender", M), r("paginationUpdate", M)), e.params.watchOverflow && e.enabled && M.classList[e.isLocked ? "add" : "remove"](_.lockClass) }) } function p() { const v = e.params.pagination; if (d()) return; const _ = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length; let w = e.pagination.el; w = l(w); let S = ""; if (v.type === "bullets") { let x = e.params.loop ? Math.ceil(_ / e.params.slidesPerGroup) : e.snapGrid.length; e.params.freeMode && e.params.freeMode.enabled && x > _ && (x = _); for (let P = 0; P < x; P += 1)v.renderBullet ? S += v.renderBullet.call(e, P, v.bulletClass) : S += `<${v.bulletElement} ${e.isElement ? 'part="bullet"' : ""} class="${v.bulletClass}"></${v.bulletElement}>` } v.type === "fraction" && (v.renderFraction ? S = v.renderFraction.call(e, v.currentClass, v.totalClass) : S = `<span class="${v.currentClass}"></span> / <span class="${v.totalClass}"></span>`), v.type === "progressbar" && (v.renderProgressbar ? S = v.renderProgressbar.call(e, v.progressbarFillClass) : S = `<span class="${v.progressbarFillClass}"></span>`), e.pagination.bullets = [], w.forEach(x => { v.type !== "custom" && (x.innerHTML = S || ""), v.type === "bullets" && e.pagination.bullets.push(...x.querySelectorAll(fi(v.bulletClass))) }), v.type !== "custom" && r("paginationRender", w[0]) } function m() { e.params.pagination = Ua(e, e.originalParams.pagination, e.params.pagination, { el: "swiper-pagination" }); const v = e.params.pagination; if (!v.el) return; let _; typeof v.el == "string" && e.isElement && (_ = e.el.querySelector(v.el)), !_ && typeof v.el == "string" && (_ = [...document.querySelectorAll(v.el)]), _ || (_ = v.el), !(!_ || _.length === 0) && (e.params.uniqueNavElements && typeof v.el == "string" && Array.isArray(_) && _.length > 1 && (_ = [...e.el.querySelectorAll(v.el)], _.length > 1 && (_ = _.filter(w => ar(w, ".swiper")[0] === e.el)[0])), Array.isArray(_) && _.length === 1 && (_ = _[0]), Object.assign(e.pagination, { el: _ }), _ = l(_), _.forEach(w => { v.type === "bullets" && v.clickable && w.classList.add(...(v.clickableClass || "").split(" ")), w.classList.add(v.modifierClass + v.type), w.classList.add(e.isHorizontal() ? v.horizontalClass : v.verticalClass), v.type === "bullets" && v.dynamicBullets && (w.classList.add(`${v.modifierClass}${v.type}-dynamic`), o = 0, v.dynamicMainBullets < 1 && (v.dynamicMainBullets = 1)), v.type === "progressbar" && v.progressbarOpposite && w.classList.add(v.progressbarOppositeClass), v.clickable && w.addEventListener("click", u), e.enabled || w.classList.add(v.lockClass) })) } function h() { const v = e.params.pagination; if (d()) return; let _ = e.pagination.el; _ && (_ = l(_), _.forEach(w => { w.classList.remove(v.hiddenClass), w.classList.remove(v.modifierClass + v.type), w.classList.remove(e.isHorizontal() ? v.horizontalClass : v.verticalClass), v.clickable && (w.classList.remove(...(v.clickableClass || "").split(" ")), w.removeEventListener("click", u)) })), e.pagination.bullets && e.pagination.bullets.forEach(w => w.classList.remove(...v.bulletActiveClass.split(" "))) } i("changeDirection", () => { if (!e.pagination || !e.pagination.el) return; const v = e.params.pagination; let { el: _ } = e.pagination; _ = l(_), _.forEach(w => { w.classList.remove(v.horizontalClass, v.verticalClass), w.classList.add(e.isHorizontal() ? v.horizontalClass : v.verticalClass) }) }), i("init", () => { e.params.pagination.enabled === !1 ? y() : (m(), p(), f()) }), i("activeIndexChange", () => { typeof e.snapIndex > "u" && f() }), i("snapIndexChange", () => { f() }), i("snapGridLengthChange", () => { p(), f() }), i("destroy", () => { h() }), i("enable disable", () => { let { el: v } = e.pagination; v && (v = l(v), v.forEach(_ => _.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass))) }), i("lock unlock", () => { f() }), i("click", (v, _) => { const w = _.target, S = l(e.pagination.el); if (e.params.pagination.el && e.params.pagination.hideOnClick && S && S.length > 0 && !w.classList.contains(e.params.pagination.bulletClass)) { if (e.navigation && (e.navigation.nextEl && w === e.navigation.nextEl || e.navigation.prevEl && w === e.navigation.prevEl)) return; const x = S[0].classList.contains(e.params.pagination.hiddenClass); r(x === !0 ? "paginationShow" : "paginationHide"), S.forEach(P => P.classList.toggle(e.params.pagination.hiddenClass)) } }); const g = () => { e.el.classList.remove(e.params.pagination.paginationDisabledClass); let { el: v } = e.pagination; v && (v = l(v), v.forEach(_ => _.classList.remove(e.params.pagination.paginationDisabledClass))), m(), p(), f() }, y = () => { e.el.classList.add(e.params.pagination.paginationDisabledClass); let { el: v } = e.pagination; v && (v = l(v), v.forEach(_ => _.classList.add(e.params.pagination.paginationDisabledClass))), h() }; Object.assign(e.pagination, { enable: g, disable: y, render: p, update: f, init: m, destroy: h }) } function Cf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = ft(); let a = !1, o = null, l = null, d, c, u, f; t({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag", scrollbarDisabledClass: "swiper-scrollbar-disabled", horizontalClass: "swiper-scrollbar-horizontal", verticalClass: "swiper-scrollbar-vertical" } }), e.scrollbar = { el: null, dragEl: null }; function p() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: C, rtlTranslate: k } = e, { dragEl: b, el: A } = C, z = e.params.scrollbar, I = e.params.loop ? e.progressLoop : e.progress; let D = c, R = (u - c) * I; k ? (R = -R, R > 0 ? (D = c - R, R = 0) : -R + c > u && (D = u + R)) : R < 0 ? (D = c + R, R = 0) : R + c > u && (D = u - R), e.isHorizontal() ? (b.style.transform = `translate3d(${R}px, 0, 0)`, b.style.width = `${D}px`) : (b.style.transform = `translate3d(0px, ${R}px, 0)`, b.style.height = `${D}px`), z.hide && (clearTimeout(o), A.style.opacity = 1, o = setTimeout(() => { A.style.opacity = 0, A.style.transitionDuration = "400ms" }, 1e3)) } function m(C) { !e.params.scrollbar.el || !e.scrollbar.el || (e.scrollbar.dragEl.style.transitionDuration = `${C}ms`) } function h() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: C } = e, { dragEl: k, el: b } = C; k.style.width = "", k.style.height = "", u = e.isHorizontal() ? b.offsetWidth : b.offsetHeight, f = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), e.params.scrollbar.dragSize === "auto" ? c = u * f : c = parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? k.style.width = `${c}px` : k.style.height = `${c}px`, f >= 1 ? b.style.display = "none" : b.style.display = "", e.params.scrollbar.hide && (b.style.opacity = 0), e.params.watchOverflow && e.enabled && C.el.classList[e.isLocked ? "add" : "remove"](e.params.scrollbar.lockClass) } function g(C) { return e.isHorizontal() ? C.clientX : C.clientY } function y(C) { const { scrollbar: k, rtlTranslate: b } = e, { el: A } = k; let z; z = (g(C) - gn(A)[e.isHorizontal() ? "left" : "top"] - (d !== null ? d : c / 2)) / (u - c), z = Math.max(Math.min(z, 1), 0), b && (z = 1 - z); const I = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * z; e.updateProgress(I), e.setTranslate(I), e.updateActiveIndex(), e.updateSlidesClasses() } function v(C) { const k = e.params.scrollbar, { scrollbar: b, wrapperEl: A } = e, { el: z, dragEl: I } = b; a = !0, d = C.target === I ? g(C) - C.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, C.preventDefault(), C.stopPropagation(), A.style.transitionDuration = "100ms", I.style.transitionDuration = "100ms", y(C), clearTimeout(l), z.style.transitionDuration = "0ms", k.hide && (z.style.opacity = 1), e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "none"), r("scrollbarDragStart", C) } function _(C) { const { scrollbar: k, wrapperEl: b } = e, { el: A, dragEl: z } = k; a && (C.preventDefault ? C.preventDefault() : C.returnValue = !1, y(C), b.style.transitionDuration = "0ms", A.style.transitionDuration = "0ms", z.style.transitionDuration = "0ms", r("scrollbarDragMove", C)) } function w(C) { const k = e.params.scrollbar, { scrollbar: b, wrapperEl: A } = e, { el: z } = b; a && (a = !1, e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "", A.style.transitionDuration = ""), k.hide && (clearTimeout(l), l = pr(() => { z.style.opacity = 0, z.style.transitionDuration = "400ms" }, 1e3)), r("scrollbarDragEnd", C), k.snapOnRelease && e.slideToClosest()) } function S(C) { const { scrollbar: k, params: b } = e, A = k.el; if (!A) return; const z = A, I = b.passiveListeners ? { passive: !1, capture: !1 } : !1, D = b.passiveListeners ? { passive: !0, capture: !1 } : !1; if (!z) return; const R = C === "on" ? "addEventListener" : "removeEventListener"; z[R]("pointerdown", v, I), s[R]("pointermove", _, I), s[R]("pointerup", w, D) } function x() { !e.params.scrollbar.el || !e.scrollbar.el || S("on") } function P() { !e.params.scrollbar.el || !e.scrollbar.el || S("off") } function L() { const { scrollbar: C, el: k } = e; e.params.scrollbar = Ua(e, e.originalParams.scrollbar, e.params.scrollbar, { el: "swiper-scrollbar" }); const b = e.params.scrollbar; if (!b.el) return; let A; if (typeof b.el == "string" && e.isElement && (A = e.el.querySelector(b.el)), !A && typeof b.el == "string") { if (A = s.querySelectorAll(b.el), !A.length) return } else A || (A = b.el); e.params.uniqueNavElements && typeof b.el == "string" && A.length > 1 && k.querySelectorAll(b.el).length === 1 && (A = k.querySelector(b.el)), A.length > 0 && (A = A[0]), A.classList.add(e.isHorizontal() ? b.horizontalClass : b.verticalClass); let z; A && (z = A.querySelector(fi(e.params.scrollbar.dragClass)), z || (z = At("div", e.params.scrollbar.dragClass), A.append(z))), Object.assign(C, { el: A, dragEl: z }), b.draggable && x(), A && A.classList[e.enabled ? "remove" : "add"](...wi(e.params.scrollbar.lockClass)) } function M() { const C = e.params.scrollbar, k = e.scrollbar.el; k && k.classList.remove(...wi(e.isHorizontal() ? C.horizontalClass : C.verticalClass)), P() } i("init", () => { e.params.scrollbar.enabled === !1 ? O() : (L(), h(), p()) }), i("update resize observerUpdate lock unlock", () => { h() }), i("setTranslate", () => { p() }), i("setTransition", (C, k) => { m(k) }), i("enable disable", () => { const { el: C } = e.scrollbar; C && C.classList[e.enabled ? "remove" : "add"](...wi(e.params.scrollbar.lockClass)) }), i("destroy", () => { M() }); const E = () => { e.el.classList.remove(...wi(e.params.scrollbar.scrollbarDisabledClass)), e.scrollbar.el && e.scrollbar.el.classList.remove(...wi(e.params.scrollbar.scrollbarDisabledClass)), L(), h(), p() }, O = () => { e.el.classList.add(...wi(e.params.scrollbar.scrollbarDisabledClass)), e.scrollbar.el && e.scrollbar.el.classList.add(...wi(e.params.scrollbar.scrollbarDisabledClass)), M() }; Object.assign(e.scrollbar, { enable: E, disable: O, updateSize: h, setTranslate: p, init: L, destroy: M }) } function Pf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ parallax: { enabled: !1 } }); const r = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]", s = (l, d) => { const { rtl: c } = e, u = c ? -1 : 1, f = l.getAttribute("data-swiper-parallax") || "0"; let p = l.getAttribute("data-swiper-parallax-x"), m = l.getAttribute("data-swiper-parallax-y"); const h = l.getAttribute("data-swiper-parallax-scale"), g = l.getAttribute("data-swiper-parallax-opacity"), y = l.getAttribute("data-swiper-parallax-rotate"); if (p || m ? (p = p || "0", m = m || "0") : e.isHorizontal() ? (p = f, m = "0") : (m = f, p = "0"), p.indexOf("%") >= 0 ? p = `${parseInt(p, 10) * d * u}%` : p = `${p * d * u}px`, m.indexOf("%") >= 0 ? m = `${parseInt(m, 10) * d}%` : m = `${m * d}px`, typeof g < "u" && g !== null) { const _ = g - (g - 1) * (1 - Math.abs(d)); l.style.opacity = _ } let v = `translate3d(${p}, ${m}, 0px)`; if (typeof h < "u" && h !== null) { const _ = h - (h - 1) * (1 - Math.abs(d)); v += ` scale(${_})` } if (y && typeof y < "u" && y !== null) { const _ = y * d * -1; v += ` rotate(${_}deg)` } l.style.transform = v }, a = () => { const { el: l, slides: d, progress: c, snapGrid: u, isElement: f } = e, p = We(l, r); e.isElement && p.push(...We(e.hostEl, r)), p.forEach(m => { s(m, c) }), d.forEach((m, h) => { let g = m.progress; e.params.slidesPerGroup > 1 && e.params.slidesPerView !== "auto" && (g += Math.ceil(h / 2) - c * (u.length - 1)), g = Math.min(Math.max(g, -1), 1), m.querySelectorAll(`${r}, [data-swiper-parallax-rotate]`).forEach(y => { s(y, g) }) }) }, o = function (l) { l === void 0 && (l = e.params.speed); const { el: d, hostEl: c } = e, u = [...d.querySelectorAll(r)]; e.isElement && u.push(...c.querySelectorAll(r)), u.forEach(f => { let p = parseInt(f.getAttribute("data-swiper-parallax-duration"), 10) || l; l === 0 && (p = 0), f.style.transitionDuration = `${p}ms` }) }; i("beforeInit", () => { e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) }), i("init", () => { e.params.parallax.enabled && a() }), i("setTranslate", () => { e.params.parallax.enabled && a() }), i("setTransition", (l, d) => { e.params.parallax.enabled && o(d) }) } function Af(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = ye(); t({ zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), e.zoom = { enabled: !1 }; let a = 1, o = !1, l, d; const c = [], u = { originX: 0, originY: 0, slideEl: void 0, slideWidth: void 0, slideHeight: void 0, imageEl: void 0, imageWrapEl: void 0, maxRatio: 3 }, f = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, p = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let m = 1; Object.defineProperty(e.zoom, "scale", { get() { return m }, set(I) { if (m !== I) { const D = u.imageEl, R = u.slideEl; r("zoomChange", I, D, R) } m = I } }); function h() { if (c.length < 2) return 1; const I = c[0].pageX, D = c[0].pageY, R = c[1].pageX, T = c[1].pageY; return Math.sqrt((R - I) ** 2 + (T - D) ** 2) } function g() { if (c.length < 2) return { x: null, y: null }; const I = u.imageEl.getBoundingClientRect(); return [(c[0].pageX + (c[1].pageX - c[0].pageX) / 2 - I.x - s.scrollX) / a, (c[0].pageY + (c[1].pageY - c[0].pageY) / 2 - I.y - s.scrollY) / a] } function y() { return e.isElement ? "swiper-slide" : `.${e.params.slideClass}` } function v(I) { const D = y(); return !!(I.target.matches(D) || e.slides.filter(R => R.contains(I.target)).length > 0) } function _(I) { const D = `.${e.params.zoom.containerClass}`; return !!(I.target.matches(D) || [...e.hostEl.querySelectorAll(D)].filter(R => R.contains(I.target)).length > 0) } function w(I) { if (I.pointerType === "mouse" && c.splice(0, c.length), !v(I)) return; const D = e.params.zoom; if (l = !1, d = !1, c.push(I), !(c.length < 2)) { if (l = !0, u.scaleStart = h(), !u.slideEl) { u.slideEl = I.target.closest(`.${e.params.slideClass}, swiper-slide`), u.slideEl || (u.slideEl = e.slides[e.activeIndex]); let R = u.slideEl.querySelector(`.${D.containerClass}`); if (R && (R = R.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), u.imageEl = R, R ? u.imageWrapEl = ar(u.imageEl, `.${D.containerClass}`)[0] : u.imageWrapEl = void 0, !u.imageWrapEl) { u.imageEl = void 0; return } u.maxRatio = u.imageWrapEl.getAttribute("data-swiper-zoom") || D.maxRatio } if (u.imageEl) { const [R, T] = g(); u.originX = R, u.originY = T, u.imageEl.style.transitionDuration = "0ms" } o = !0 } } function S(I) { if (!v(I)) return; const D = e.params.zoom, R = e.zoom, T = c.findIndex(N => N.pointerId === I.pointerId); T >= 0 && (c[T] = I), !(c.length < 2) && (d = !0, u.scaleMove = h(), u.imageEl && (R.scale = u.scaleMove / u.scaleStart * a, R.scale > u.maxRatio && (R.scale = u.maxRatio - 1 + (R.scale - u.maxRatio + 1) ** .5), R.scale < D.minRatio && (R.scale = D.minRatio + 1 - (D.minRatio - R.scale + 1) ** .5), u.imageEl.style.transform = `translate3d(0,0,0) scale(${R.scale})`)) } function x(I) { if (!v(I) || I.pointerType === "mouse" && I.type === "pointerout") return; const D = e.params.zoom, R = e.zoom, T = c.findIndex(N => N.pointerId === I.pointerId); T >= 0 && c.splice(T, 1), !(!l || !d) && (l = !1, d = !1, u.imageEl && (R.scale = Math.max(Math.min(R.scale, u.maxRatio), D.minRatio), u.imageEl.style.transitionDuration = `${e.params.speed}ms`, u.imageEl.style.transform = `translate3d(0,0,0) scale(${R.scale})`, a = R.scale, o = !1, R.scale > 1 && u.slideEl ? u.slideEl.classList.add(`${D.zoomedSlideClass}`) : R.scale <= 1 && u.slideEl && u.slideEl.classList.remove(`${D.zoomedSlideClass}`), R.scale === 1 && (u.originX = 0, u.originY = 0, u.slideEl = void 0))) } function P(I) { const D = e.device; if (!u.imageEl || f.isTouched) return; D.android && I.cancelable && I.preventDefault(), f.isTouched = !0; const R = c.length > 0 ? c[0] : I; f.touchesStart.x = R.pageX, f.touchesStart.y = R.pageY } function L(I) { if (!v(I) || !_(I)) return; const D = e.zoom; if (!u.imageEl || !f.isTouched || !u.slideEl) return; f.isMoved || (f.width = u.imageEl.offsetWidth, f.height = u.imageEl.offsetHeight, f.startX = ba(u.imageWrapEl, "x") || 0, f.startY = ba(u.imageWrapEl, "y") || 0, u.slideWidth = u.slideEl.offsetWidth, u.slideHeight = u.slideEl.offsetHeight, u.imageWrapEl.style.transitionDuration = "0ms"); const R = f.width * D.scale, T = f.height * D.scale; if (R < u.slideWidth && T < u.slideHeight) return; if (f.minX = Math.min(u.slideWidth / 2 - R / 2, 0), f.maxX = -f.minX, f.minY = Math.min(u.slideHeight / 2 - T / 2, 0), f.maxY = -f.minY, f.touchesCurrent.x = c.length > 0 ? c[0].pageX : I.pageX, f.touchesCurrent.y = c.length > 0 ? c[0].pageY : I.pageY, Math.max(Math.abs(f.touchesCurrent.x - f.touchesStart.x), Math.abs(f.touchesCurrent.y - f.touchesStart.y)) > 5 && (e.allowClick = !1), !f.isMoved && !o) { if (e.isHorizontal() && (Math.floor(f.minX) === Math.floor(f.startX) && f.touchesCurrent.x < f.touchesStart.x || Math.floor(f.maxX) === Math.floor(f.startX) && f.touchesCurrent.x > f.touchesStart.x)) { f.isTouched = !1; return } if (!e.isHorizontal() && (Math.floor(f.minY) === Math.floor(f.startY) && f.touchesCurrent.y < f.touchesStart.y || Math.floor(f.maxY) === Math.floor(f.startY) && f.touchesCurrent.y > f.touchesStart.y)) { f.isTouched = !1; return } } I.cancelable && I.preventDefault(), I.stopPropagation(), f.isMoved = !0; const ie = (D.scale - a) / (u.maxRatio - e.params.zoom.minRatio), { originX: F, originY: Y } = u; f.currentX = f.touchesCurrent.x - f.touchesStart.x + f.startX + ie * (f.width - F * 2), f.currentY = f.touchesCurrent.y - f.touchesStart.y + f.startY + ie * (f.height - Y * 2), f.currentX < f.minX && (f.currentX = f.minX + 1 - (f.minX - f.currentX + 1) ** .8), f.currentX > f.maxX && (f.currentX = f.maxX - 1 + (f.currentX - f.maxX + 1) ** .8), f.currentY < f.minY && (f.currentY = f.minY + 1 - (f.minY - f.currentY + 1) ** .8), f.currentY > f.maxY && (f.currentY = f.maxY - 1 + (f.currentY - f.maxY + 1) ** .8), p.prevPositionX || (p.prevPositionX = f.touchesCurrent.x), p.prevPositionY || (p.prevPositionY = f.touchesCurrent.y), p.prevTime || (p.prevTime = Date.now()), p.x = (f.touchesCurrent.x - p.prevPositionX) / (Date.now() - p.prevTime) / 2, p.y = (f.touchesCurrent.y - p.prevPositionY) / (Date.now() - p.prevTime) / 2, Math.abs(f.touchesCurrent.x - p.prevPositionX) < 2 && (p.x = 0), Math.abs(f.touchesCurrent.y - p.prevPositionY) < 2 && (p.y = 0), p.prevPositionX = f.touchesCurrent.x, p.prevPositionY = f.touchesCurrent.y, p.prevTime = Date.now(), u.imageWrapEl.style.transform = `translate3d(${f.currentX}px, ${f.currentY}px,0)` } function M() { const I = e.zoom; if (!u.imageEl) return; if (!f.isTouched || !f.isMoved) { f.isTouched = !1, f.isMoved = !1; return } f.isTouched = !1, f.isMoved = !1; let D = 300, R = 300; const T = p.x * D, N = f.currentX + T, ie = p.y * R, F = f.currentY + ie; p.x !== 0 && (D = Math.abs((N - f.currentX) / p.x)), p.y !== 0 && (R = Math.abs((F - f.currentY) / p.y)); const Y = Math.max(D, R); f.currentX = N, f.currentY = F; const se = f.width * I.scale, de = f.height * I.scale; f.minX = Math.min(u.slideWidth / 2 - se / 2, 0), f.maxX = -f.minX, f.minY = Math.min(u.slideHeight / 2 - de / 2, 0), f.maxY = -f.minY, f.currentX = Math.max(Math.min(f.currentX, f.maxX), f.minX), f.currentY = Math.max(Math.min(f.currentY, f.maxY), f.minY), u.imageWrapEl.style.transitionDuration = `${Y}ms`, u.imageWrapEl.style.transform = `translate3d(${f.currentX}px, ${f.currentY}px,0)` } function E() { const I = e.zoom; u.slideEl && e.activeIndex !== e.slides.indexOf(u.slideEl) && (u.imageEl && (u.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), u.imageWrapEl && (u.imageWrapEl.style.transform = "translate3d(0,0,0)"), u.slideEl.classList.remove(`${e.params.zoom.zoomedSlideClass}`), I.scale = 1, a = 1, u.slideEl = void 0, u.imageEl = void 0, u.imageWrapEl = void 0, u.originX = 0, u.originY = 0) } function O(I) { const D = e.zoom, R = e.params.zoom; if (!u.slideEl) { I && I.target && (u.slideEl = I.target.closest(`.${e.params.slideClass}, swiper-slide`)), u.slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.slideEl = We(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : u.slideEl = e.slides[e.activeIndex]); let tt = u.slideEl.querySelector(`.${R.containerClass}`); tt && (tt = tt.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), u.imageEl = tt, tt ? u.imageWrapEl = ar(u.imageEl, `.${R.containerClass}`)[0] : u.imageWrapEl = void 0 } if (!u.imageEl || !u.imageWrapEl) return; e.params.cssMode && (e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.touchAction = "none"), u.slideEl.classList.add(`${R.zoomedSlideClass}`); let T, N, ie, F, Y, se, de, ne, Ie, Pe, Nt, De, et, W, ue, ze, Ve, $; typeof f.touchesStart.x > "u" && I ? (T = I.pageX, N = I.pageY) : (T = f.touchesStart.x, N = f.touchesStart.y); const Ae = typeof I == "number" ? I : null; a === 1 && Ae && (T = void 0, N = void 0), D.scale = Ae || u.imageWrapEl.getAttribute("data-swiper-zoom") || R.maxRatio, a = Ae || u.imageWrapEl.getAttribute("data-swiper-zoom") || R.maxRatio, I && !(a === 1 && Ae) ? (Ve = u.slideEl.offsetWidth, $ = u.slideEl.offsetHeight, ie = gn(u.slideEl).left + s.scrollX, F = gn(u.slideEl).top + s.scrollY, Y = ie + Ve / 2 - T, se = F + $ / 2 - N, Ie = u.imageEl.offsetWidth, Pe = u.imageEl.offsetHeight, Nt = Ie * D.scale, De = Pe * D.scale, et = Math.min(Ve / 2 - Nt / 2, 0), W = Math.min($ / 2 - De / 2, 0), ue = -et, ze = -W, de = Y * D.scale, ne = se * D.scale, de < et && (de = et), de > ue && (de = ue), ne < W && (ne = W), ne > ze && (ne = ze)) : (de = 0, ne = 0), Ae && D.scale === 1 && (u.originX = 0, u.originY = 0), u.imageWrapEl.style.transitionDuration = "300ms", u.imageWrapEl.style.transform = `translate3d(${de}px, ${ne}px,0)`, u.imageEl.style.transitionDuration = "300ms", u.imageEl.style.transform = `translate3d(0,0,0) scale(${D.scale})` } function C() { const I = e.zoom, D = e.params.zoom; if (!u.slideEl) { e.params.virtual && e.params.virtual.enabled && e.virtual ? u.slideEl = We(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : u.slideEl = e.slides[e.activeIndex]; let R = u.slideEl.querySelector(`.${D.containerClass}`); R && (R = R.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), u.imageEl = R, R ? u.imageWrapEl = ar(u.imageEl, `.${D.containerClass}`)[0] : u.imageWrapEl = void 0 } !u.imageEl || !u.imageWrapEl || (e.params.cssMode && (e.wrapperEl.style.overflow = "", e.wrapperEl.style.touchAction = ""), I.scale = 1, a = 1, u.imageWrapEl.style.transitionDuration = "300ms", u.imageWrapEl.style.transform = "translate3d(0,0,0)", u.imageEl.style.transitionDuration = "300ms", u.imageEl.style.transform = "translate3d(0,0,0) scale(1)", u.slideEl.classList.remove(`${D.zoomedSlideClass}`), u.slideEl = void 0, u.originX = 0, u.originY = 0) } function k(I) { const D = e.zoom; D.scale && D.scale !== 1 ? C() : O(I) } function b() { const I = e.params.passiveListeners ? { passive: !0, capture: !1 } : !1, D = e.params.passiveListeners ? { passive: !1, capture: !0 } : !0; return { passiveListener: I, activeListenerWithCapture: D } } function A() { const I = e.zoom; if (I.enabled) return; I.enabled = !0; const { passiveListener: D, activeListenerWithCapture: R } = b(); e.wrapperEl.addEventListener("pointerdown", w, D), e.wrapperEl.addEventListener("pointermove", S, R), ["pointerup", "pointercancel", "pointerout"].forEach(T => { e.wrapperEl.addEventListener(T, x, D) }), e.wrapperEl.addEventListener("pointermove", L, R) } function z() { const I = e.zoom; if (!I.enabled) return; I.enabled = !1; const { passiveListener: D, activeListenerWithCapture: R } = b(); e.wrapperEl.removeEventListener("pointerdown", w, D), e.wrapperEl.removeEventListener("pointermove", S, R), ["pointerup", "pointercancel", "pointerout"].forEach(T => { e.wrapperEl.removeEventListener(T, x, D) }), e.wrapperEl.removeEventListener("pointermove", L, R) } i("init", () => { e.params.zoom.enabled && A() }), i("destroy", () => { z() }), i("touchStart", (I, D) => { e.zoom.enabled && P(D) }), i("touchEnd", (I, D) => { e.zoom.enabled && M() }), i("doubleTap", (I, D) => { !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && k(D) }), i("transitionEnd", () => { e.zoom.enabled && e.params.zoom.enabled && E() }), i("slideChange", () => { e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && E() }), Object.assign(e.zoom, { enable: A, disable: z, in: O, out: C, toggle: k }) } function Lf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ controller: { control: void 0, inverse: !1, by: "slide" } }), e.controller = { control: void 0 }; function r(d, c) { const u = function () { let h, g, y; return (v, _) => { for (g = -1, h = v.length; h - g > 1;)y = h + g >> 1, v[y] <= _ ? g = y : h = y; return h } }(); this.x = d, this.y = c, this.lastIndex = d.length - 1; let f, p; return this.interpolate = function (h) { return h ? (p = u(this.x, h), f = p - 1, (h - this.x[f]) * (this.y[p] - this.y[f]) / (this.x[p] - this.x[f]) + this.y[f]) : 0 }, this } function s(d) { e.controller.spline = e.params.loop ? new r(e.slidesGrid, d.slidesGrid) : new r(e.snapGrid, d.snapGrid) } function a(d, c) { const u = e.controller.control; let f, p; const m = e.constructor; function h(g) { if (g.destroyed) return; const y = e.rtlTranslate ? -e.translate : e.translate; e.params.controller.by === "slide" && (s(g), p = -e.controller.spline.interpolate(-y)), (!p || e.params.controller.by === "container") && (f = (g.maxTranslate() - g.minTranslate()) / (e.maxTranslate() - e.minTranslate()), (Number.isNaN(f) || !Number.isFinite(f)) && (f = 1), p = (y - e.minTranslate()) * f + g.minTranslate()), e.params.controller.inverse && (p = g.maxTranslate() - p), g.updateProgress(p), g.setTranslate(p, e), g.updateActiveIndex(), g.updateSlidesClasses() } if (Array.isArray(u)) for (let g = 0; g < u.length; g += 1)u[g] !== c && u[g] instanceof m && h(u[g]); else u instanceof m && c !== u && h(u) } function o(d, c) { const u = e.constructor, f = e.controller.control; let p; function m(h) { h.destroyed || (h.setTransition(d, e), d !== 0 && (h.transitionStart(), h.params.autoHeight && pr(() => { h.updateAutoHeight() }), ms(h.wrapperEl, () => { f && h.transitionEnd() }))) } if (Array.isArray(f)) for (p = 0; p < f.length; p += 1)f[p] !== c && f[p] instanceof u && m(f[p]); else f instanceof u && c !== f && m(f) } function l() { e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) } i("beforeInit", () => { if (typeof window < "u" && (typeof e.params.controller.control == "string" || e.params.controller.control instanceof HTMLElement)) { const d = document.querySelector(e.params.controller.control); if (d && d.swiper) e.controller.control = d.swiper; else if (d) { const c = u => { e.controller.control = u.detail[0], e.update(), d.removeEventListener("init", c) }; d.addEventListener("init", c) } return } e.controller.control = e.params.controller.control }), i("update", () => { l() }), i("resize", () => { l() }), i("observerUpdate", () => { l() }), i("setTranslate", (d, c, u) => { !e.controller.control || e.controller.control.destroyed || e.controller.setTranslate(c, u) }), i("setTransition", (d, c, u) => { !e.controller.control || e.controller.control.destroyed || e.controller.setTransition(c, u) }), Object.assign(e.controller, { setTranslate: a, setTransition: o }) } function kf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group", id: null } }), e.a11y = { clicked: !1 }; let r = null; function s(b) { const A = r; A.length !== 0 && (A.innerHTML = "", A.innerHTML = b) } const a = b => (Array.isArray(b) ? b : [b]).filter(A => !!A); function o(b) { b === void 0 && (b = 16); const A = () => Math.round(16 * Math.random()).toString(16); return "x".repeat(b).replace(/x/g, A) } function l(b) { b = a(b), b.forEach(A => { A.setAttribute("tabIndex", "0") }) } function d(b) { b = a(b), b.forEach(A => { A.setAttribute("tabIndex", "-1") }) } function c(b, A) { b = a(b), b.forEach(z => { z.setAttribute("role", A) }) } function u(b, A) { b = a(b), b.forEach(z => { z.setAttribute("aria-roledescription", A) }) } function f(b, A) { b = a(b), b.forEach(z => { z.setAttribute("aria-controls", A) }) } function p(b, A) { b = a(b), b.forEach(z => { z.setAttribute("aria-label", A) }) } function m(b, A) { b = a(b), b.forEach(z => { z.setAttribute("id", A) }) } function h(b, A) { b = a(b), b.forEach(z => { z.setAttribute("aria-live", A) }) } function g(b) { b = a(b), b.forEach(A => { A.setAttribute("aria-disabled", !0) }) } function y(b) { b = a(b), b.forEach(A => { A.setAttribute("aria-disabled", !1) }) } function v(b) { if (b.keyCode !== 13 && b.keyCode !== 32) return; const A = e.params.a11y, z = b.target; e.pagination && e.pagination.el && (z === e.pagination.el || e.pagination.el.contains(b.target)) && !b.target.matches(fi(e.params.pagination.bulletClass)) || (e.navigation && e.navigation.nextEl && z === e.navigation.nextEl && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? s(A.lastSlideMessage) : s(A.nextSlideMessage)), e.navigation && e.navigation.prevEl && z === e.navigation.prevEl && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? s(A.firstSlideMessage) : s(A.prevSlideMessage)), e.pagination && z.matches(fi(e.params.pagination.bulletClass)) && z.click()) } function _() { if (e.params.loop || e.params.rewind || !e.navigation) return; const { nextEl: b, prevEl: A } = e.navigation; A && (e.isBeginning ? (g(A), d(A)) : (y(A), l(A))), b && (e.isEnd ? (g(b), d(b)) : (y(b), l(b))) } function w() { return e.pagination && e.pagination.bullets && e.pagination.bullets.length } function S() { return w() && e.params.pagination.clickable } function x() { const b = e.params.a11y; w() && e.pagination.bullets.forEach(A => { e.params.pagination.clickable && (l(A), e.params.pagination.renderBullet || (c(A, "button"), p(A, b.paginationBulletMessage.replace(/\{\{index\}\}/, Cs(A) + 1)))), A.matches(fi(e.params.pagination.bulletActiveClass)) ? A.setAttribute("aria-current", "true") : A.removeAttribute("aria-current") }) } const P = (b, A, z) => { l(b), b.tagName !== "BUTTON" && (c(b, "button"), b.addEventListener("keydown", v)), p(b, z), f(b, A) }, L = () => { e.a11y.clicked = !0 }, M = () => { requestAnimationFrame(() => { requestAnimationFrame(() => { e.destroyed || (e.a11y.clicked = !1) }) }) }, E = b => { if (e.a11y.clicked) return; const A = b.target.closest(`.${e.params.slideClass}, swiper-slide`); if (!A || !e.slides.includes(A)) return; const z = e.slides.indexOf(A) === e.activeIndex, I = e.params.watchSlidesProgress && e.visibleSlides && e.visibleSlides.includes(A); z || I || b.sourceCapabilities && b.sourceCapabilities.firesTouchEvents || (e.isHorizontal() ? e.el.scrollLeft = 0 : e.el.scrollTop = 0, e.slideTo(e.slides.indexOf(A), 0)) }, O = () => { const b = e.params.a11y; b.itemRoleDescriptionMessage && u(e.slides, b.itemRoleDescriptionMessage), b.slideRole && c(e.slides, b.slideRole); const A = e.slides.length; b.slideLabelMessage && e.slides.forEach((z, I) => { const D = e.params.loop ? parseInt(z.getAttribute("data-swiper-slide-index"), 10) : I, R = b.slideLabelMessage.replace(/\{\{index\}\}/, D + 1).replace(/\{\{slidesLength\}\}/, A); p(z, R) }) }, C = () => { const b = e.params.a11y; e.el.append(r); const A = e.el; b.containerRoleDescriptionMessage && u(A, b.containerRoleDescriptionMessage), b.containerMessage && p(A, b.containerMessage); const z = e.wrapperEl, I = b.id || z.getAttribute("id") || `swiper-wrapper-${o(16)}`, D = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite"; m(z, I), h(z, D), O(); let { nextEl: R, prevEl: T } = e.navigation ? e.navigation : {}; R = a(R), T = a(T), R && R.forEach(N => P(N, I, b.nextSlideMessage)), T && T.forEach(N => P(N, I, b.prevSlideMessage)), S() && a(e.pagination.el).forEach(ie => { ie.addEventListener("keydown", v) }), e.el.addEventListener("focus", E, !0), e.el.addEventListener("pointerdown", L, !0), e.el.addEventListener("pointerup", M, !0) }; function k() { r && r.remove(); let { nextEl: b, prevEl: A } = e.navigation ? e.navigation : {}; b = a(b), A = a(A), b && b.forEach(z => z.removeEventListener("keydown", v)), A && A.forEach(z => z.removeEventListener("keydown", v)), S() && a(e.pagination.el).forEach(I => { I.removeEventListener("keydown", v) }), e.el.removeEventListener("focus", E, !0), e.el.removeEventListener("pointerdown", L, !0), e.el.removeEventListener("pointerup", M, !0) } i("beforeInit", () => { r = At("span", e.params.a11y.notificationClass), r.setAttribute("aria-live", "assertive"), r.setAttribute("aria-atomic", "true") }), i("afterInit", () => { e.params.a11y.enabled && C() }), i("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => { e.params.a11y.enabled && O() }), i("fromEdge toEdge afterInit lock unlock", () => { e.params.a11y.enabled && _() }), i("paginationUpdate", () => { e.params.a11y.enabled && x() }), i("destroy", () => { e.params.a11y.enabled && k() }) } function Of(n) { let { swiper: e, extendParams: t, on: i } = n; t({ history: { enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1 } }); let r = !1, s = {}; const a = p => p.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), o = p => { const m = ye(); let h; p ? h = new URL(p) : h = m.location; const g = h.pathname.slice(1).split("/").filter(w => w !== ""), y = g.length, v = g[y - 2], _ = g[y - 1]; return { key: v, value: _ } }, l = (p, m) => { const h = ye(); if (!r || !e.params.history.enabled) return; let g; e.params.url ? g = new URL(e.params.url) : g = h.location; const y = e.slides[m]; let v = a(y.getAttribute("data-history")); if (e.params.history.root.length > 0) { let w = e.params.history.root; w[w.length - 1] === "/" && (w = w.slice(0, w.length - 1)), v = `${w}/${p ? `${p}/` : ""}${v}` } else g.pathname.includes(p) || (v = `${p ? `${p}/` : ""}${v}`); e.params.history.keepQuery && (v += g.search); const _ = h.history.state; _ && _.value === v || (e.params.history.replaceState ? h.history.replaceState({ value: v }, null, v) : h.history.pushState({ value: v }, null, v)) }, d = (p, m, h) => { if (m) for (let g = 0, y = e.slides.length; g < y; g += 1) { const v = e.slides[g]; if (a(v.getAttribute("data-history")) === m) { const w = e.getSlideIndex(v); e.slideTo(w, p, h) } } else e.slideTo(0, p, h) }, c = () => { s = o(e.params.url), d(e.params.speed, s.value, !1) }, u = () => { const p = ye(); if (e.params.history) { if (!p.history || !p.history.pushState) { e.params.history.enabled = !1, e.params.hashNavigation.enabled = !0; return } if (r = !0, s = o(e.params.url), !s.key && !s.value) { e.params.history.replaceState || p.addEventListener("popstate", c); return } d(0, s.value, e.params.runCallbacksOnInit), e.params.history.replaceState || p.addEventListener("popstate", c) } }, f = () => { const p = ye(); e.params.history.replaceState || p.removeEventListener("popstate", c) }; i("init", () => { e.params.history.enabled && u() }), i("destroy", () => { e.params.history.enabled && f() }), i("transitionEnd _freeModeNoMomentumRelease", () => { r && l(e.params.history.key, e.activeIndex) }), i("slideChange", () => { r && e.params.cssMode && l(e.params.history.key, e.activeIndex) }) } function If(n) { let { swiper: e, extendParams: t, emit: i, on: r } = n, s = !1; const a = ft(), o = ye(); t({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1, getSlideIndex(f, p) { if (e.virtual && e.params.virtual.enabled) { const m = e.slides.filter(g => g.getAttribute("data-hash") === p)[0]; return m ? parseInt(m.getAttribute("data-swiper-slide-index"), 10) : 0 } return e.getSlideIndex(We(e.slidesEl, `.${e.params.slideClass}[data-hash="${p}"], swiper-slide[data-hash="${p}"]`)[0]) } } }); const l = () => { i("hashChange"); const f = a.location.hash.replace("#", ""), p = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${e.activeIndex}"]`) : e.slides[e.activeIndex], m = p ? p.getAttribute("data-hash") : ""; if (f !== m) { const h = e.params.hashNavigation.getSlideIndex(e, f); if (typeof h > "u" || Number.isNaN(h)) return; e.slideTo(h) } }, d = () => { if (!s || !e.params.hashNavigation.enabled) return; const f = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${e.activeIndex}"]`) : e.slides[e.activeIndex], p = f ? f.getAttribute("data-hash") || f.getAttribute("data-history") : ""; e.params.hashNavigation.replaceState && o.history && o.history.replaceState ? (o.history.replaceState(null, null, `#${p}` || ""), i("hashSet")) : (a.location.hash = p || "", i("hashSet")) }, c = () => { if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return; s = !0; const f = a.location.hash.replace("#", ""); if (f) { const m = e.params.hashNavigation.getSlideIndex(e, f); e.slideTo(m || 0, 0, e.params.runCallbacksOnInit, !0) } e.params.hashNavigation.watchState && o.addEventListener("hashchange", l) }, u = () => { e.params.hashNavigation.watchState && o.removeEventListener("hashchange", l) }; r("init", () => { e.params.hashNavigation.enabled && c() }), r("destroy", () => { e.params.hashNavigation.enabled && u() }), r("transitionEnd _freeModeNoMomentumRelease", () => { s && d() }), r("slideChange", () => { s && e.params.cssMode && d() }) } function Df(n) { let { swiper: e, extendParams: t, on: i, emit: r, params: s } = n; e.autoplay = { running: !1, paused: !1, timeLeft: 0 }, t({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !1, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); let a, o, l = s && s.autoplay ? s.autoplay.delay : 3e3, d = s && s.autoplay ? s.autoplay.delay : 3e3, c, u = new Date().getTime(), f, p, m, h, g, y, v; function _(D) { !e || e.destroyed || !e.wrapperEl || D.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", _), !v && E()) } const w = () => { if (e.destroyed || !e.autoplay.running) return; e.autoplay.paused ? f = !0 : f && (d = c, f = !1); const D = e.autoplay.paused ? c : u + d - new Date().getTime(); e.autoplay.timeLeft = D, r("autoplayTimeLeft", D, D / l), o = requestAnimationFrame(() => { w() }) }, S = () => { let D; return e.virtual && e.params.virtual.enabled ? D = e.slides.filter(T => T.classList.contains("swiper-slide-active"))[0] : D = e.slides[e.activeIndex], D ? parseInt(D.getAttribute("data-swiper-autoplay"), 10) : void 0 }, x = D => { if (e.destroyed || !e.autoplay.running) return; cancelAnimationFrame(o), w(); let R = typeof D > "u" ? e.params.autoplay.delay : D; l = e.params.autoplay.delay, d = e.params.autoplay.delay; const T = S(); !Number.isNaN(T) && T > 0 && typeof D > "u" && (R = T, l = T, d = T), c = R; const N = e.params.speed, ie = () => { !e || e.destroyed || (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev(N, !0, !0), r("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, N, !0, !0), r("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext(N, !0, !0), r("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, N, !0, !0), r("autoplay")), e.params.cssMode && (u = new Date().getTime(), requestAnimationFrame(() => { x() }))) }; return R > 0 ? (clearTimeout(a), a = setTimeout(() => { ie() }, R)) : requestAnimationFrame(() => { ie() }), R }, P = () => { u = new Date().getTime(), e.autoplay.running = !0, x(), r("autoplayStart") }, L = () => { e.autoplay.running = !1, clearTimeout(a), cancelAnimationFrame(o), r("autoplayStop") }, M = (D, R) => { if (e.destroyed || !e.autoplay.running) return; clearTimeout(a), D || (y = !0); const T = () => { r("autoplayPause"), e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", _) : E() }; if (e.autoplay.paused = !0, R) { g && (c = e.params.autoplay.delay), g = !1, T(); return } c = (c || e.params.autoplay.delay) - (new Date().getTime() - u), !(e.isEnd && c < 0 && !e.params.loop) && (c < 0 && (c = 0), T()) }, E = () => { e.isEnd && c < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (u = new Date().getTime(), y ? (y = !1, x(c)) : x(), e.autoplay.paused = !1, r("autoplayResume")) }, O = () => { if (e.destroyed || !e.autoplay.running) return; const D = ft(); D.visibilityState === "hidden" && (y = !0, M(!0)), D.visibilityState === "visible" && E() }, C = D => { D.pointerType === "mouse" && (y = !0, v = !0, !(e.animating || e.autoplay.paused) && M(!0)) }, k = D => { D.pointerType === "mouse" && (v = !1, e.autoplay.paused && E()) }, b = () => { e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", C), e.el.addEventListener("pointerleave", k)) }, A = () => { e.el.removeEventListener("pointerenter", C), e.el.removeEventListener("pointerleave", k) }, z = () => { ft().addEventListener("visibilitychange", O) }, I = () => { ft().removeEventListener("visibilitychange", O) }; i("init", () => { e.params.autoplay.enabled && (b(), z(), P()) }), i("destroy", () => { A(), I(), e.autoplay.running && L() }), i("_freeModeStaticRelease", () => { (m || y) && E() }), i("_freeModeNoMomentumRelease", () => { e.params.autoplay.disableOnInteraction ? L() : M(!0, !0) }), i("beforeTransitionStart", (D, R, T) => { e.destroyed || !e.autoplay.running || (T || !e.params.autoplay.disableOnInteraction ? M(!0, !0) : L()) }), i("sliderFirstMove", () => { if (!(e.destroyed || !e.autoplay.running)) { if (e.params.autoplay.disableOnInteraction) { L(); return } p = !0, m = !1, y = !1, h = setTimeout(() => { y = !0, m = !0, M(!0) }, 200) } }), i("touchEnd", () => { if (!(e.destroyed || !e.autoplay.running || !p)) { if (clearTimeout(h), clearTimeout(a), e.params.autoplay.disableOnInteraction) { m = !1, p = !1; return } m && e.params.cssMode && E(), m = !1, p = !1 } }), i("slideChange", () => { e.destroyed || !e.autoplay.running || (g = !0) }), Object.assign(e.autoplay, { start: P, stop: L, pause: M, resume: E }) } function zf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let r = !1, s = !1; e.thumbs = { swiper: null }; function a() { const d = e.thumbs.swiper; if (!d || d.destroyed) return; const c = d.clickedIndex, u = d.clickedSlide; if (u && u.classList.contains(e.params.thumbs.slideThumbActiveClass) || typeof c > "u" || c === null) return; let f; d.params.loop ? f = parseInt(d.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : f = c, e.params.loop ? e.slideToLoop(f) : e.slideTo(f) } function o() { const { thumbs: d } = e.params; if (r) return !1; r = !0; const c = e.constructor; if (d.swiper instanceof c) e.thumbs.swiper = d.swiper, Object.assign(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), e.thumbs.swiper.update(); else if (es(d.swiper)) { const u = Object.assign({}, d.swiper); Object.assign(u, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), e.thumbs.swiper = new c(u), s = !0 } return e.thumbs.swiper.el.classList.add(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", a), !0 } function l(d) { const c = e.thumbs.swiper; if (!c || c.destroyed) return; const u = c.params.slidesPerView === "auto" ? c.slidesPerViewDynamic() : c.params.slidesPerView; let f = 1; const p = e.params.thumbs.slideThumbActiveClass; if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (f = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (f = 1), f = Math.floor(f), c.slides.forEach(g => g.classList.remove(p)), c.params.loop || c.params.virtual && c.params.virtual.enabled) for (let g = 0; g < f; g += 1)We(c.slidesEl, `[data-swiper-slide-index="${e.realIndex + g}"]`).forEach(y => { y.classList.add(p) }); else for (let g = 0; g < f; g += 1)c.slides[e.realIndex + g] && c.slides[e.realIndex + g].classList.add(p); const m = e.params.thumbs.autoScrollOffset, h = m && !c.params.loop; if (e.realIndex !== c.realIndex || h) { const g = c.activeIndex; let y, v; if (c.params.loop) { const _ = c.slides.filter(w => w.getAttribute("data-swiper-slide-index") === `${e.realIndex}`)[0]; y = c.slides.indexOf(_), v = e.activeIndex > e.previousIndex ? "next" : "prev" } else y = e.realIndex, v = y > e.previousIndex ? "next" : "prev"; h && (y += v === "next" ? m : -1 * m), c.visibleSlidesIndexes && c.visibleSlidesIndexes.indexOf(y) < 0 && (c.params.centeredSlides ? y > g ? y = y - Math.floor(u / 2) + 1 : y = y + Math.floor(u / 2) - 1 : y > g && c.params.slidesPerGroup, c.slideTo(y, d ? 0 : void 0)) } } i("beforeInit", () => { const { thumbs: d } = e.params; if (!(!d || !d.swiper)) if (typeof d.swiper == "string" || d.swiper instanceof HTMLElement) { const c = ft(), u = () => { const p = typeof d.swiper == "string" ? c.querySelector(d.swiper) : d.swiper; if (p && p.swiper) d.swiper = p.swiper, o(), l(!0); else if (p) { const m = h => { d.swiper = h.detail[0], p.removeEventListener("init", m), o(), l(!0), d.swiper.update(), e.update() }; p.addEventListener("init", m) } return p }, f = () => { if (e.destroyed) return; u() || requestAnimationFrame(f) }; requestAnimationFrame(f) } else o(), l(!0) }), i("slideChange update resize observerUpdate", () => { l() }), i("setTransition", (d, c) => { const u = e.thumbs.swiper; !u || u.destroyed || u.setTransition(c) }), i("beforeDestroy", () => { const d = e.thumbs.swiper; !d || d.destroyed || s && d.destroy() }), Object.assign(e.thumbs, { init: o, update: l }) } function Rf(n) { let { swiper: e, extendParams: t, emit: i, once: r } = n; t({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }); function s() { if (e.params.cssMode) return; const l = e.getTranslate(); e.setTranslate(l), e.setTransition(0), e.touchEventsData.velocities.length = 0, e.freeMode.onTouchEnd({ currentPos: e.rtl ? e.translate : -e.translate }) } function a() { if (e.params.cssMode) return; const { touchEventsData: l, touches: d } = e; l.velocities.length === 0 && l.velocities.push({ position: d[e.isHorizontal() ? "startX" : "startY"], time: l.touchStartTime }), l.velocities.push({ position: d[e.isHorizontal() ? "currentX" : "currentY"], time: Rt() }) } function o(l) { let { currentPos: d } = l; if (e.params.cssMode) return; const { params: c, wrapperEl: u, rtlTranslate: f, snapGrid: p, touchEventsData: m } = e, g = Rt() - m.touchStartTime; if (d < -e.minTranslate()) { e.slideTo(e.activeIndex); return } if (d > -e.maxTranslate()) { e.slides.length < p.length ? e.slideTo(p.length - 1) : e.slideTo(e.slides.length - 1); return } if (c.freeMode.momentum) { if (m.velocities.length > 1) { const L = m.velocities.pop(), M = m.velocities.pop(), E = L.position - M.position, O = L.time - M.time; e.velocity = E / O, e.velocity /= 2, Math.abs(e.velocity) < c.freeMode.minimumVelocity && (e.velocity = 0), (O > 150 || Rt() - L.time > 300) && (e.velocity = 0) } else e.velocity = 0; e.velocity *= c.freeMode.momentumVelocityRatio, m.velocities.length = 0; let y = 1e3 * c.freeMode.momentumRatio; const v = e.velocity * y; let _ = e.translate + v; f && (_ = -_); let w = !1, S; const x = Math.abs(e.velocity) * 20 * c.freeMode.momentumBounceRatio; let P; if (_ < e.maxTranslate()) c.freeMode.momentumBounce ? (_ + e.maxTranslate() < -x && (_ = e.maxTranslate() - x), S = e.maxTranslate(), w = !0, m.allowMomentumBounce = !0) : _ = e.maxTranslate(), c.loop && c.centeredSlides && (P = !0); else if (_ > e.minTranslate()) c.freeMode.momentumBounce ? (_ - e.minTranslate() > x && (_ = e.minTranslate() + x), S = e.minTranslate(), w = !0, m.allowMomentumBounce = !0) : _ = e.minTranslate(), c.loop && c.centeredSlides && (P = !0); else if (c.freeMode.sticky) { let L; for (let M = 0; M < p.length; M += 1)if (p[M] > -_) { L = M; break } Math.abs(p[L] - _) < Math.abs(p[L - 1] - _) || e.swipeDirection === "next" ? _ = p[L] : _ = p[L - 1], _ = -_ } if (P && r("transitionEnd", () => { e.loopFix() }), e.velocity !== 0) { if (f ? y = Math.abs((-_ - e.translate) / e.velocity) : y = Math.abs((_ - e.translate) / e.velocity), c.freeMode.sticky) { const L = Math.abs((f ? -_ : _) - e.translate), M = e.slidesSizesGrid[e.activeIndex]; L < M ? y = c.speed : L < 2 * M ? y = c.speed * 1.5 : y = c.speed * 2.5 } } else if (c.freeMode.sticky) { e.slideToClosest(); return } c.freeMode.momentumBounce && w ? (e.updateProgress(S), e.setTransition(y), e.setTranslate(_), e.transitionStart(!0, e.swipeDirection), e.animating = !0, ms(u, () => { !e || e.destroyed || !m.allowMomentumBounce || (i("momentumBounce"), e.setTransition(c.speed), setTimeout(() => { e.setTranslate(S), ms(u, () => { !e || e.destroyed || e.transitionEnd() }) }, 0)) })) : e.velocity ? (i("_freeModeNoMomentumRelease"), e.updateProgress(_), e.setTransition(y), e.setTranslate(_), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, ms(u, () => { !e || e.destroyed || e.transitionEnd() }))) : e.updateProgress(_), e.updateActiveIndex(), e.updateSlidesClasses() } else if (c.freeMode.sticky) { e.slideToClosest(); return } else c.freeMode && i("_freeModeNoMomentumRelease"); (!c.freeMode.momentum || g >= c.longSwipesMs) && (i("_freeModeStaticRelease"), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses()) } Object.assign(e, { freeMode: { onTouchStart: s, onTouchMove: a, onTouchEnd: o } }) } function $f(n) { let { swiper: e, extendParams: t, on: i } = n; t({ grid: { rows: 1, fill: "column" } }); let r, s, a, o; const l = () => { let h = e.params.spaceBetween; return typeof h == "string" && h.indexOf("%") >= 0 ? h = parseFloat(h.replace("%", "")) / 100 * e.size : typeof h == "string" && (h = parseFloat(h)), h }, d = h => { const { slidesPerView: g } = e.params, { rows: y, fill: v } = e.params.grid, _ = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : h.length; a = Math.floor(_ / y), Math.floor(_ / y) === _ / y ? r = _ : r = Math.ceil(_ / y) * y, g !== "auto" && v === "row" && (r = Math.max(r, g * y)), s = r / y }, c = () => { e.slides && e.slides.forEach(h => { h.swiperSlideGridSet && (h.style.height = "", h.style[e.getDirectionLabel("margin-top")] = "") }) }, u = (h, g, y) => { const { slidesPerGroup: v } = e.params, _ = l(), { rows: w, fill: S } = e.params.grid, x = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : y.length; let P, L, M; if (S === "row" && v > 1) { const E = Math.floor(h / (v * w)), O = h - w * v * E, C = E === 0 ? v : Math.min(Math.ceil((x - E * w * v) / w), v); M = Math.floor(O / C), L = O - M * C + E * v, P = L + M * r / w, g.style.order = P } else S === "column" ? (L = Math.floor(h / w), M = h - L * w, (L > a || L === a && M === w - 1) && (M += 1, M >= w && (M = 0, L += 1))) : (M = Math.floor(h / s), L = h - M * s); g.row = M, g.column = L, g.style.height = `calc((100% - ${(w - 1) * _}px) / ${w})`, g.style[e.getDirectionLabel("margin-top")] = M !== 0 ? _ && `${_}px` : "", g.swiperSlideGridSet = !0 }, f = (h, g) => { const { centeredSlides: y, roundLengths: v } = e.params, _ = l(), { rows: w } = e.params.grid; if (e.virtualSize = (h + _) * r, e.virtualSize = Math.ceil(e.virtualSize / w) - _, e.params.cssMode || (e.wrapperEl.style[e.getDirectionLabel("width")] = `${e.virtualSize + _}px`), y) { const S = []; for (let x = 0; x < g.length; x += 1) { let P = g[x]; v && (P = Math.floor(P)), g[x] < e.virtualSize + g[0] && S.push(P) } g.splice(0, g.length), g.push(...S) } }, p = () => { o = e.params.grid && e.params.grid.rows > 1 }, m = () => { const { params: h, el: g } = e, y = h.grid && h.grid.rows > 1; o && !y ? (g.classList.remove(`${h.containerModifierClass}grid`, `${h.containerModifierClass}grid-column`), a = 1, e.emitContainerClasses()) : !o && y && (g.classList.add(`${h.containerModifierClass}grid`), h.grid.fill === "column" && g.classList.add(`${h.containerModifierClass}grid-column`), e.emitContainerClasses()), o = y }; i("init", p), i("update", m), e.grid = { initSlides: d, unsetSlides: c, updateSlide: u, updateWrapperSize: f } } function Bf(n) { const e = this, { params: t, slidesEl: i } = e; t.loop && e.loopDestroy(); const r = s => { if (typeof s == "string") { const a = document.createElement("div"); a.innerHTML = s, i.append(a.children[0]), a.innerHTML = "" } else i.append(s) }; if (typeof n == "object" && "length" in n) for (let s = 0; s < n.length; s += 1)n[s] && r(n[s]); else r(n); e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update() } function qf(n) { const e = this, { params: t, activeIndex: i, slidesEl: r } = e; t.loop && e.loopDestroy(); let s = i + 1; const a = o => { if (typeof o == "string") { const l = document.createElement("div"); l.innerHTML = o, r.prepend(l.children[0]), l.innerHTML = "" } else r.prepend(o) }; if (typeof n == "object" && "length" in n) { for (let o = 0; o < n.length; o += 1)n[o] && a(n[o]); s = i + n.length } else a(n); e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update(), e.slideTo(s, 0, !1) } function Ff(n, e) { const t = this, { params: i, activeIndex: r, slidesEl: s } = t; let a = r; i.loop && (a -= t.loopedSlides, t.loopDestroy(), t.recalcSlides()); const o = t.slides.length; if (n <= 0) { t.prependSlide(e); return } if (n >= o) { t.appendSlide(e); return } let l = a > n ? a + 1 : a; const d = []; for (let c = o - 1; c >= n; c -= 1) { const u = t.slides[c]; u.remove(), d.unshift(u) } if (typeof e == "object" && "length" in e) { for (let c = 0; c < e.length; c += 1)e[c] && s.append(e[c]); l = a > n ? a + e.length : a } else s.append(e); for (let c = 0; c < d.length; c += 1)s.append(d[c]); t.recalcSlides(), i.loop && t.loopCreate(), (!i.observer || t.isElement) && t.update(), i.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1) } function Nf(n) { const e = this, { params: t, activeIndex: i } = e; let r = i; t.loop && (r -= e.loopedSlides, e.loopDestroy()); let s = r, a; if (typeof n == "object" && "length" in n) { for (let o = 0; o < n.length; o += 1)a = n[o], e.slides[a] && e.slides[a].remove(), a < s && (s -= 1); s = Math.max(s, 0) } else a = n, e.slides[a] && e.slides[a].remove(), a < s && (s -= 1), s = Math.max(s, 0); e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update(), t.loop ? e.slideTo(s + e.loopedSlides, 0, !1) : e.slideTo(s, 0, !1) } function Yf() { const n = this, e = []; for (let t = 0; t < n.slides.length; t += 1)e.push(t); n.removeSlide(e) } function Hf(n) { let { swiper: e } = n; Object.assign(e, { appendSlide: Bf.bind(e), prependSlide: qf.bind(e), addSlide: Ff.bind(e), removeSlide: Nf.bind(e), removeAllSlides: Yf.bind(e) }) } function Nr(n) { const { effect: e, swiper: t, on: i, setTranslate: r, setTransition: s, overwriteParams: a, perspective: o, recreateShadows: l, getEffectParams: d } = n; i("beforeInit", () => { if (t.params.effect !== e) return; t.classNames.push(`${t.params.containerModifierClass}${e}`), o && o() && t.classNames.push(`${t.params.containerModifierClass}3d`); const u = a ? a() : {}; Object.assign(t.params, u), Object.assign(t.originalParams, u) }), i("setTranslate", () => { t.params.effect === e && r() }), i("setTransition", (u, f) => { t.params.effect === e && s(f) }), i("transitionEnd", () => { if (t.params.effect === e && l) { if (!d || !d().slideShadows) return; t.slides.forEach(u => { u.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(f => f.remove()) }), l() } }); let c; i("virtualUpdate", () => { t.params.effect === e && (t.slides.length || (c = !0), requestAnimationFrame(() => { c && t.slides && t.slides.length && (r(), c = !1) })) }) } function As(n, e) { const t = mr(e); return t !== e && (t.style.backfaceVisibility = "hidden", t.style["-webkit-backface-visibility"] = "hidden"), t } function Mn(n) { let { swiper: e, duration: t, transformElements: i, allSlides: r } = n; const { activeIndex: s } = e, a = o => o.parentElement ? o.parentElement : e.slides.filter(d => d.shadowRoot && d.shadowRoot === o.parentNode)[0]; if (e.params.virtualTranslate && t !== 0) { let o = !1, l; r ? l = i : l = i.filter(d => { const c = d.classList.contains("swiper-slide-transform") ? a(d) : d; return e.getSlideIndex(c) === s }), l.forEach(d => { ms(d, () => { if (o || !e || e.destroyed) return; o = !0, e.animating = !1; const c = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); e.wrapperEl.dispatchEvent(c) }) }) } } function Vf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ fadeEffect: { crossFade: !1 } }), Nr({ effect: "fade", swiper: e, on: i, setTranslate: () => { const { slides: a } = e, o = e.params.fadeEffect; for (let l = 0; l < a.length; l += 1) { const d = e.slides[l]; let u = -d.swiperSlideOffset; e.params.virtualTranslate || (u -= e.translate); let f = 0; e.isHorizontal() || (f = u, u = 0); const p = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(d.progress), 0) : 1 + Math.min(Math.max(d.progress, -1), 0), m = As(o, d); m.style.opacity = p, m.style.transform = `translate3d(${u}px, ${f}px, 0px)` } }, setTransition: a => { const o = e.slides.map(l => mr(l)); o.forEach(l => { l.style.transitionDuration = `${a}ms` }), Mn({ swiper: e, duration: a, transformElements: o, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) } function Gf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }); const r = (l, d, c) => { let u = c ? l.querySelector(".swiper-slide-shadow-left") : l.querySelector(".swiper-slide-shadow-top"), f = c ? l.querySelector(".swiper-slide-shadow-right") : l.querySelector(".swiper-slide-shadow-bottom"); u || (u = At("div", `swiper-slide-shadow-cube swiper-slide-shadow-${c ? "left" : "top"}`.split(" ")), l.append(u)), f || (f = At("div", `swiper-slide-shadow-cube swiper-slide-shadow-${c ? "right" : "bottom"}`.split(" ")), l.append(f)), u && (u.style.opacity = Math.max(-d, 0)), f && (f.style.opacity = Math.max(d, 0)) }; Nr({ effect: "cube", swiper: e, on: i, setTranslate: () => { const { el: l, wrapperEl: d, slides: c, width: u, height: f, rtlTranslate: p, size: m, browser: h } = e, g = e.params.cubeEffect, y = e.isHorizontal(), v = e.virtual && e.params.virtual.enabled; let _ = 0, w; g.shadow && (y ? (w = e.wrapperEl.querySelector(".swiper-cube-shadow"), w || (w = At("div", "swiper-cube-shadow"), e.wrapperEl.append(w)), w.style.height = `${u}px`) : (w = l.querySelector(".swiper-cube-shadow"), w || (w = At("div", "swiper-cube-shadow"), l.append(w)))); for (let x = 0; x < c.length; x += 1) { const P = c[x]; let L = x; v && (L = parseInt(P.getAttribute("data-swiper-slide-index"), 10)); let M = L * 90, E = Math.floor(M / 360); p && (M = -M, E = Math.floor(-M / 360)); const O = Math.max(Math.min(P.progress, 1), -1); let C = 0, k = 0, b = 0; L % 4 === 0 ? (C = -E * 4 * m, b = 0) : (L - 1) % 4 === 0 ? (C = 0, b = -E * 4 * m) : (L - 2) % 4 === 0 ? (C = m + E * 4 * m, b = m) : (L - 3) % 4 === 0 && (C = -m, b = 3 * m + m * 4 * E), p && (C = -C), y || (k = C, C = 0); const A = `rotateX(${y ? 0 : -M}deg) rotateY(${y ? M : 0}deg) translate3d(${C}px, ${k}px, ${b}px)`; O <= 1 && O > -1 && (_ = L * 90 + O * 90, p && (_ = -L * 90 - O * 90), e.browser && e.browser.isSafari && Math.abs(_) / 90 % 2 === 1 && (_ += .001)), P.style.transform = A, g.slideShadows && r(P, O, y) } if (d.style.transformOrigin = `50% 50% -${m / 2}px`, d.style["-webkit-transform-origin"] = `50% 50% -${m / 2}px`, g.shadow) if (y) w.style.transform = `translate3d(0px, ${u / 2 + g.shadowOffset}px, ${-u / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${g.shadowScale})`; else { const x = Math.abs(_) - Math.floor(Math.abs(_) / 90) * 90, P = 1.5 - (Math.sin(x * 2 * Math.PI / 360) / 2 + Math.cos(x * 2 * Math.PI / 360) / 2), L = g.shadowScale, M = g.shadowScale / P, E = g.shadowOffset; w.style.transform = `scale3d(${L}, 1, ${M}) translate3d(0px, ${f / 2 + E}px, ${-f / 2 / M}px) rotateX(-89.99deg)` } const S = (h.isSafari || h.isWebView) && h.needPerspectiveFix ? -m / 2 : 0; d.style.transform = `translate3d(0px,0,${S}px) rotateX(${e.isHorizontal() ? 0 : _}deg) rotateY(${e.isHorizontal() ? -_ : 0}deg)`, d.style.setProperty("--swiper-cube-translate-z", `${S}px`) }, setTransition: l => { const { el: d, slides: c } = e; if (c.forEach(u => { u.style.transitionDuration = `${l}ms`, u.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(f => { f.style.transitionDuration = `${l}ms` }) }), e.params.cubeEffect.shadow && !e.isHorizontal()) { const u = d.querySelector(".swiper-cube-shadow"); u && (u.style.transitionDuration = `${l}ms`) } }, recreateShadows: () => { const l = e.isHorizontal(); e.slides.forEach(d => { const c = Math.max(Math.min(d.progress, 1), -1); r(d, c, l) }) }, getEffectParams: () => e.params.cubeEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) } function Fr(n, e, t) { const i = `swiper-slide-shadow${t ? `-${t}` : ""}${n ? ` swiper-slide-shadow-${n}` : ""}`, r = mr(e); let s = r.querySelector(`.${i.split(" ").join(".")}`); return s || (s = At("div", i.split(" ")), r.append(s)), s } function Xf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ flipEffect: { slideShadows: !0, limitRotation: !0 } }); const r = (l, d) => { let c = e.isHorizontal() ? l.querySelector(".swiper-slide-shadow-left") : l.querySelector(".swiper-slide-shadow-top"), u = e.isHorizontal() ? l.querySelector(".swiper-slide-shadow-right") : l.querySelector(".swiper-slide-shadow-bottom"); c || (c = Fr("flip", l, e.isHorizontal() ? "left" : "top")), u || (u = Fr("flip", l, e.isHorizontal() ? "right" : "bottom")), c && (c.style.opacity = Math.max(-d, 0)), u && (u.style.opacity = Math.max(d, 0)) }; Nr({ effect: "flip", swiper: e, on: i, setTranslate: () => { const { slides: l, rtlTranslate: d } = e, c = e.params.flipEffect; for (let u = 0; u < l.length; u += 1) { const f = l[u]; let p = f.progress; e.params.flipEffect.limitRotation && (p = Math.max(Math.min(f.progress, 1), -1)); const m = f.swiperSlideOffset; let g = -180 * p, y = 0, v = e.params.cssMode ? -m - e.translate : -m, _ = 0; e.isHorizontal() ? d && (g = -g) : (_ = v, v = 0, y = -g, g = 0), e.browser && e.browser.isSafari && (Math.abs(g) / 90 % 2 === 1 && (g += .001), Math.abs(y) / 90 % 2 === 1 && (y += .001)), f.style.zIndex = -Math.abs(Math.round(p)) + l.length, c.slideShadows && r(f, p); const w = `translate3d(${v}px, ${_}px, 0px) rotateX(${y}deg) rotateY(${g}deg)`, S = As(c, f); S.style.transform = w } }, setTransition: l => { const d = e.slides.map(c => mr(c)); d.forEach(c => { c.style.transitionDuration = `${l}ms`, c.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(u => { u.style.transitionDuration = `${l}ms` }) }), Mn({ swiper: e, duration: l, transformElements: d }) }, recreateShadows: () => { e.params.flipEffect, e.slides.forEach(l => { let d = l.progress; e.params.flipEffect.limitRotation && (d = Math.max(Math.min(l.progress, 1), -1)), r(l, d) }) }, getEffectParams: () => e.params.flipEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) } function Wf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0 } }), Nr({ effect: "coverflow", swiper: e, on: i, setTranslate: () => { const { width: a, height: o, slides: l, slidesSizesGrid: d } = e, c = e.params.coverflowEffect, u = e.isHorizontal(), f = e.translate, p = u ? -f + a / 2 : -f + o / 2, m = u ? c.rotate : -c.rotate, h = c.depth; for (let g = 0, y = l.length; g < y; g += 1) { const v = l[g], _ = d[g], w = v.swiperSlideOffset, S = (p - w - _ / 2) / _, x = typeof c.modifier == "function" ? c.modifier(S) : S * c.modifier; let P = u ? m * x : 0, L = u ? 0 : m * x, M = -h * Math.abs(x), E = c.stretch; typeof E == "string" && E.indexOf("%") !== -1 && (E = parseFloat(c.stretch) / 100 * _); let O = u ? 0 : E * x, C = u ? E * x : 0, k = 1 - (1 - c.scale) * Math.abs(x); Math.abs(C) < .001 && (C = 0), Math.abs(O) < .001 && (O = 0), Math.abs(M) < .001 && (M = 0), Math.abs(P) < .001 && (P = 0), Math.abs(L) < .001 && (L = 0), Math.abs(k) < .001 && (k = 0), e.browser && e.browser.isSafari && (Math.abs(P) / 90 % 2 === 1 && (P += .001), Math.abs(L) / 90 % 2 === 1 && (L += .001)); const b = `translate3d(${C}px,${O}px,${M}px)  rotateX(${L}deg) rotateY(${P}deg) scale(${k})`, A = As(c, v); if (A.style.transform = b, v.style.zIndex = -Math.abs(Math.round(x)) + 1, c.slideShadows) { let z = u ? v.querySelector(".swiper-slide-shadow-left") : v.querySelector(".swiper-slide-shadow-top"), I = u ? v.querySelector(".swiper-slide-shadow-right") : v.querySelector(".swiper-slide-shadow-bottom"); z || (z = Fr("coverflow", v, u ? "left" : "top")), I || (I = Fr("coverflow", v, u ? "right" : "bottom")), z && (z.style.opacity = x > 0 ? x : 0), I && (I.style.opacity = -x > 0 ? -x : 0) } } }, setTransition: a => { e.slides.map(l => mr(l)).forEach(l => { l.style.transitionDuration = `${a}ms`, l.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(d => { d.style.transitionDuration = `${a}ms` }) }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) } function jf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ creativeEffect: { limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const r = o => typeof o == "string" ? o : `${o}px`; Nr({ effect: "creative", swiper: e, on: i, setTranslate: () => { const { slides: o, wrapperEl: l, slidesSizesGrid: d } = e, c = e.params.creativeEffect, { progressMultiplier: u } = c, f = e.params.centeredSlides; if (f) { const p = d[0] / 2 - e.params.slidesOffsetBefore || 0; l.style.transform = `translateX(calc(50% - ${p}px))` } for (let p = 0; p < o.length; p += 1) { const m = o[p], h = m.progress, g = Math.min(Math.max(m.progress, -c.limitProgress), c.limitProgress); let y = g; f || (y = Math.min(Math.max(m.originalProgress, -c.limitProgress), c.limitProgress)); const v = m.swiperSlideOffset, _ = [e.params.cssMode ? -v - e.translate : -v, 0, 0], w = [0, 0, 0]; let S = !1; e.isHorizontal() || (_[1] = _[0], _[0] = 0); let x = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; g < 0 ? (x = c.next, S = !0) : g > 0 && (x = c.prev, S = !0), _.forEach((k, b) => { _[b] = `calc(${k}px + (${r(x.translate[b])} * ${Math.abs(g * u)}))` }), w.forEach((k, b) => { let A = x.rotate[b] * Math.abs(g * u); e.browser && e.browser.isSafari && Math.abs(A) / 90 % 2 === 1 && (A += .001), w[b] = A }), m.style.zIndex = -Math.abs(Math.round(h)) + o.length; const P = _.join(", "), L = `rotateX(${w[0]}deg) rotateY(${w[1]}deg) rotateZ(${w[2]}deg)`, M = y < 0 ? `scale(${1 + (1 - x.scale) * y * u})` : `scale(${1 - (1 - x.scale) * y * u})`, E = y < 0 ? 1 + (1 - x.opacity) * y * u : 1 - (1 - x.opacity) * y * u, O = `translate3d(${P}) ${L} ${M}`; if (S && x.shadow || !S) { let k = m.querySelector(".swiper-slide-shadow"); if (!k && x.shadow && (k = Fr("creative", m)), k) { const b = c.shadowPerProgress ? g * (1 / c.limitProgress) : g; k.style.opacity = Math.min(Math.max(Math.abs(b), 0), 1) } } const C = As(c, m); C.style.transform = O, C.style.opacity = E, x.origin && (C.style.transformOrigin = x.origin) } }, setTransition: o => { const l = e.slides.map(d => mr(d)); l.forEach(d => { d.style.transitionDuration = `${o}ms`, d.querySelectorAll(".swiper-slide-shadow").forEach(c => { c.style.transitionDuration = `${o}ms` }) }), Mn({ swiper: e, duration: o, transformElements: l, allSlides: !0 }) }, perspective: () => e.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode }) }) } function Uf(n) {
	let { swiper: e, extendParams: t, on: i } = n; t({ cardsEffect: { slideShadows: !0, rotate: !0, perSlideRotate: 2, perSlideOffset: 8 } }), Nr({
		effect: "cards", swiper: e, on: i, setTranslate: () => {
			const { slides: a, activeIndex: o, rtlTranslate: l } = e, d = e.params.cardsEffect, { startTranslate: c, isTouched: u } = e.touchEventsData, f = l ? -e.translate : e.translate; for (let p = 0; p < a.length; p += 1) {
				const m = a[p], h = m.progress, g = Math.min(Math.max(h, -4), 4); let y = m.swiperSlideOffset; e.params.centeredSlides && !e.params.cssMode && (e.wrapperEl.style.transform = `translateX(${e.minTranslate()}px)`), e.params.centeredSlides && e.params.cssMode && (y -= a[0].swiperSlideOffset); let v = e.params.cssMode ? -y - e.translate : -y, _ = 0; const w = -100 * Math.abs(g); let S = 1, x = -d.perSlideRotate * g, P = d.perSlideOffset - Math.abs(g) * .75; const L = e.virtual && e.params.virtual.enabled ? e.virtual.from + p : p, M = (L === o || L === o - 1) && g > 0 && g < 1 && (u || e.params.cssMode) && f < c, E = (L === o || L === o + 1) && g < 0 && g > -1 && (u || e.params.cssMode) && f > c; if (M || E) { const b = (1 - Math.abs((Math.abs(g) - .5) / .5)) ** .5; x += -28 * g * b, S += -.5 * b, P += 96 * b, _ = `${-25 * b * Math.abs(g)}%` } if (g < 0 ? v = `calc(${v}px ${l ? "-" : "+"} (${P * Math.abs(g)}%))` : g > 0 ? v = `calc(${v}px ${l ? "-" : "+"} (-${P * Math.abs(g)}%))` : v = `${v}px`, !e.isHorizontal()) { const b = _; _ = v, v = b } const O = g < 0 ? `${1 + (1 - S) * g}` : `${1 - (1 - S) * g}`, C = `
        translate3d(${v}, ${_}, ${w}px)
        rotateZ(${d.rotate ? l ? -x : x : 0}deg)
        scale(${O})
      `; if (d.slideShadows) { let b = m.querySelector(".swiper-slide-shadow"); b || (b = Fr("cards", m)), b && (b.style.opacity = Math.min(Math.max((Math.abs(g) - .5) / .5, 0), 1)) } m.style.zIndex = -Math.abs(Math.round(h)) + a.length; const k = As(d, m); k.style.transform = C
			}
		}, setTransition: a => { const o = e.slides.map(l => mr(l)); o.forEach(l => { l.style.transitionDuration = `${a}ms`, l.querySelectorAll(".swiper-slide-shadow").forEach(d => { d.style.transitionDuration = `${a}ms` }) }), Mn({ swiper: e, duration: a, transformElements: o }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode })
	})
} const Kf = [Sf, xf, Tf, Ef, Mf, Cf, Pf, Af, Lf, kf, Of, If, Df, zf, Rf, $f, Hf, Vf, Gf, Xf, Wf, jf, Uf]; Ne.use(Kf); let is, rs, bi; document.querySelector(".house-slider__swiper-galery") && (bi = new Ne(".house-slider__swiper-galery", { direction: vd(), spaceBetween: 7, slidesPerView: _d(), freeMode: !1, watchSlidesProgress: !0, navigation: { nextEl: ".house-slider__swiper-button-next", prevEl: ".house-slider__swiper-button-prev" } }), new Ne(".house-slider__swiper-thumbnail", { watchOverflow: !0, watchSlidesVisibility: !0, watchSlidesProgress: !0, preventInteractionOnTransition: !0, direction: "horizontal", spaceBetween: 10, navigation: { nextEl: ".house-slider__button-next", prevEl: ".house-slider__button-prev" }, thumbs: { swiper: bi } })); document.querySelectorAll(".MyResultsPreviewSwiper") && new Ne(".MyResultsPreviewSwiper", { direction: "horizontal", loop: !0, preventClicks: !1, grabCursor: !0, preventClicksPropagation: !1, pagination: { clickable: !0, el: ".swiper-pagination" } }); document.querySelector(".myOfferSwiper") && new Ne(".myOfferSwiper", { direction: "horizontal", loop: !0, preventClicks: !1, preventClicksPropagation: !1, navigation: { nextEl: ".offer__swiper-button-next", prevEl: ".offer__swiper-button-prev" } }); document.querySelector(".myProjectsSwiper") && (is = new Ne(".myProjectsSwiper", { direction: "horizontal", loop: !0, slidesPerView: yd(), spaceBetween: bd(), navigation: { nextEl: ".projects__swiper-button-next", prevEl: ".projects__swiper-button-prev" } })); document.querySelector(".myHeroSwiper") && (rs = new Ne(".myHeroSwiper", { direction: "horizontal", loop: !0, slidesPerView: wd(), autoplay: { delay: 3e3 }, spaceBetween: 5 })); window.addEventListener("resize", () => { rs && (rs.params.slidesPerView = wd(), rs.params.autoplay = { delay: 3e3 }, rs.update()), is && (is.params.slidesPerView = yd(), is.params.spaceBetween = bd(), is.update()), bi && (bi.params.direction = vd(), bi.params.slidesPerView = _d(), bi.params.thumbs = { swiper: bi }, bi.update()) }); function vd() { return window.innerWidth <= 1500 ? "horizontal" : "vertical" } function _d() { return window.innerWidth <= 739 && window.innerWidth > 539 ? 3 : window.innerWidth <= 539 ? 2 : 4 } function yd() { return window.innerWidth <= 739 ? 1 : window.innerWidth <= 920 ? 2 : window.innerWidth <= 1300 ? 3 : 4 } function wd() { return window.innerWidth <= 920 && window.innerWidth > 650 ? 3 : window.innerWidth <= 650 ? 2 : 4 } function bd() { return window.innerWidth <= 1e3 ? 20 : window.innerWidth > 1e3 ? 40 : 0 } function Zf(n) { if (Array.isArray(n)) { for (var e = 0, t = Array(n.length); e < n.length; e++)t[e] = n[e]; return t } else return Array.from(n) } var Ka = !1; if (typeof window < "u") { var qo = { get passive() { Ka = !0 } }; window.addEventListener("testPassive", null, qo), window.removeEventListener("testPassive", null, qo) } var vn = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1), or = [], _n = !1, Sd = -1, gs = void 0, Ki = void 0, vs = void 0, xd = function (e) { return or.some(function (t) { return !!(t.options.allowTouchMove && t.options.allowTouchMove(e)) }) }, yn = function (e) { var t = e || window.event; return xd(t.target) || t.touches.length > 1 ? !0 : (t.preventDefault && t.preventDefault(), !1) }, Qf = function (e) { if (vs === void 0) { var t = !!e && e.reserveScrollBarGap === !0, i = window.innerWidth - document.documentElement.clientWidth; if (t && i > 0) { var r = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"), 10); vs = document.body.style.paddingRight, document.body.style.paddingRight = r + i + "px" } } gs === void 0 && (gs = document.body.style.overflow, document.body.style.overflow = "hidden") }, Jf = function () { vs !== void 0 && (document.body.style.paddingRight = vs, vs = void 0), gs !== void 0 && (document.body.style.overflow = gs, gs = void 0) }, ep = function () { return window.requestAnimationFrame(function () { if (Ki === void 0) { Ki = { position: document.body.style.position, top: document.body.style.top, left: document.body.style.left }; var e = window, t = e.scrollY, i = e.scrollX, r = e.innerHeight; document.body.style.position = "fixed", document.body.style.top = -t, document.body.style.left = -i, setTimeout(function () { return window.requestAnimationFrame(function () { var s = r - window.innerHeight; s && t >= r && (document.body.style.top = -(t + s)) }) }, 300) } }) }, tp = function () { if (Ki !== void 0) { var e = -parseInt(document.body.style.top, 10), t = -parseInt(document.body.style.left, 10); document.body.style.position = Ki.position, document.body.style.top = Ki.top, document.body.style.left = Ki.left, window.scrollTo(t, e), Ki = void 0 } }, ip = function (e) { return e ? e.scrollHeight - e.scrollTop <= e.clientHeight : !1 }, rp = function (e, t) { var i = e.targetTouches[0].clientY - Sd; return xd(e.target) ? !1 : t && t.scrollTop === 0 && i > 0 || ip(t) && i < 0 ? yn(e) : (e.stopPropagation(), !0) }, wn = function (e, t) { if (!e) { console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."); return } if (!or.some(function (r) { return r.targetElement === e })) { var i = { targetElement: e, options: t || {} }; or = [].concat(Zf(or), [i]), vn ? ep() : Qf(t), vn && (e.ontouchstart = function (r) { r.targetTouches.length === 1 && (Sd = r.targetTouches[0].clientY) }, e.ontouchmove = function (r) { r.targetTouches.length === 1 && rp(r, e) }, _n || (document.addEventListener("touchmove", yn, Ka ? { passive: !1 } : void 0), _n = !0)) } }, Td = function (e) { if (!e) { console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices."); return } or = or.filter(function (t) { return t.targetElement !== e }), vn && (e.ontouchstart = null, e.ontouchmove = null, _n && or.length === 0 && (document.removeEventListener("touchmove", yn, Ka ? { passive: !1 } : void 0), _n = !1)), vn ? tp() : Jf() }; if (document.querySelector("[data-menu]")) {
	let r = function () {
		n && n.getAttribute("data-menu") === "open" ? (n.dataset.menu = "close", Td(n), e.innerHTML = `
				<svg class="header__img-icon" >
					<use xlink: href = "./src/Images/sprite.svg#menu" />
				</svg>`) : n && (window.scrollTo({ top: 0, behavior: "smooth" }), n.dataset.menu = "open", wn(n), e.innerHTML = `
				<svg class="header__img-icon">
					<use xlink:href="./src/Images/sprite.svg#close" />
				</svg>`)
	}; var op = r; const n = document.querySelector("[data-menu]"), e = document.querySelector("[data-menu-open]"), t = document.querySelector("[data-menu-close]"); document.querySelectorAll(".header__item").forEach(s => {
		s.addEventListener("click", () => {
			n && (n.dataset.menu = "open", wn(n), e.innerHTML = `
					<svg width="32px" height="32px">
						<use xlink:href="./src/Images/sprite.svg#close" />
					</svg>`)
		})
	}), e.addEventListener("click", r), t.addEventListener("click", r)
} function Ed(n) { const e = n.querySelector(".filter__dropdown"); if (!e) return; const t = e.getBoundingClientRect(); window.innerWidth - t.right, t.left >= t.width ? (e.style.right = "0", e.style.left = "auto") : (e.style.left = "0", e.style.right = "auto") } function Md() { document.querySelectorAll("[data-dropdown]").forEach(e => { e.classList.contains("active") && Ed(e) }) } window.addEventListener("resize", Md); document.addEventListener("click", n => { const e = n.target.matches("[data-dropdown-button]"); if (!e && n.target.closest("[data-dropdown]") != null) return; let t; e && (t = n.target.closest("[data-dropdown]"), t.classList.toggle("active"), t.classList.contains("active") && Ed(t)), document.querySelectorAll("[data-dropdown].active").forEach(i => { if (i !== t) return i.classList.remove("active") }), Md() }); document.addEventListener("click", n => { n.target.matches("[data-dropdown-button]") && n.target.closest("[data-dropdown-card]") && n.target.closest("[data-dropdown-card]").classList.toggle("active") }); if (document.querySelector(".filter__dropdown-inputs-size")) { const n = document.querySelectorAll(".filter__dropdown-inputs-size input"), e = document.querySelectorAll(".filter__dropdown-range-size input"), t = document.querySelector(".filter__dropdown-slider-size .filter__dropdown-slider-progress-size"), i = document.querySelectorAll(".filter__dropdown-inputs-price input"), r = document.querySelectorAll(".filter__dropdown-range-price input"), s = document.querySelector(".filter__dropdown-slider-price .filter__dropdown-slider-progress-price"); let a = 2, o = 1e3; e.forEach(l => { l.addEventListener("input", d => { let c = parseInt(e[0].value), u = parseInt(e[1].value); u - c >= a && u <= 400 && c >= 35 && (d.target.className === "filter__dropdown-range-number filter__dropdown-number-min range-number-size-min" ? (n[0].value = c, t.style.left = c / n[0].max * 100 + "%") : (n[1].value = u, t.style.right = 100 - u / n[1].max * 100 + "%")) }) }), n.forEach(l => { l.addEventListener("input", d => { let c = parseInt(n[0].value), u = parseInt(n[1].value); if (u - c < a) d.target.className === "filter__dropdown-range-input-min range-size-min" ? n[0].value = u - a : n[1].value = c + a; else { let p = function (g, y, v) { return (g - y) / (v - y) * 100 }; var f = p; const m = 35, h = 400; e[0].value = c, e[1].value = u, t.style.left = Math.round(p(e[0].value, m, h)) + "%", t.style.right = 100 - Math.round(p(e[1].value, m, h)) + "%" } }) }), r.forEach(l => { l.addEventListener("input", d => { let c = parseInt(r[0].value), u = parseInt(r[1].value); u - c >= o && u <= 2269e4 && c >= 147e4 && (d.target.className === "filter__dropdown-range-number filter__dropdown-number-min range-number-price-min" ? (i[0].value = c, s.style.left = c / i[0].max * 100 + "%") : (i[1].value = u, s.style.right = 100 - u / i[1].max * 100 + "%")) }) }), i.forEach(l => { l.addEventListener("input", d => { let c = parseInt(i[0].value), u = parseInt(i[1].value); if (u - c < o) d.target.className === "filter__dropdown-range-input-min range-price-min" ? i[0].value = u - o : i[1].value = c + o; else { let p = function (g, y, v) { return (g - y) / (v - y) * 100 }; var f = p; const m = 147e4, h = 2269e4; r[0].value = c, r[1].value = u, s.style.left = Math.round(p(r[0].value, m, h)) + "%", s.style.right = 100 - Math.round(p(r[1].value, m, h)) + "%" } }) }) } document.querySelector(".filter__options-item") && (document.addEventListener("DOMContentLoaded", function () { document.querySelectorAll(".filter__options-item").forEach(e => { const t = e.querySelectorAll(".filter__dropdown-input"), i = e.querySelectorAll(".filter__dropdown-inputs-size input"), r = e.querySelectorAll(".filter__dropdown-range-size input"), s = e.querySelector(".filter__dropdown-slider-progress-size"), a = e.querySelectorAll(".filter__dropdown-inputs-price input"), o = e.querySelectorAll(".filter__dropdown-range-price input"), l = e.querySelector(".filter__dropdown-slider-progress-price"), d = e.querySelector(".filter__option-name span"), c = e.querySelector(".filter__reset-button"), u = e.querySelector(".filter__button-submit"); a.forEach(f => { f.addEventListener("input", function () { let p = a[0].getAttribute("data-price-range-min"), m = a[1].getAttribute("data-price-range-max"); a[0].value !== p || a[1].value !== m ? (d.closest(".filter__options-item").querySelector(".filter__dropdown_position") && (d.closest(".filter__options-item").querySelector(".filter__dropdown_position").style.left = "unset", window.addEventListener("resize", () => { window.innerWidth > 739 && (d.closest(".filter__options-item").querySelector(".filter__dropdown_position").style.right = "24px") }), window.innerWidth > 739 && (d.closest(".filter__options-item").querySelector(".filter__dropdown_position").style.right = "24px")), d.closest(".filter__options-item").querySelector("[data-reset-button]").style.display = "flex") : (d.closest(".filter__options-item").querySelector(".filter__dropdown_position") && (d.closest(".filter__options-item").querySelector(".filter__dropdown_position").style.left = "unset", d.closest(".filter__options-item").querySelector(".filter__dropdown_position").style.right = "0px"), d.closest(".filter__options-item").querySelector("[data-reset-button]").style.display = "none") }) }), i.forEach(f => { f.addEventListener("input", function () { let p = i[0].getAttribute("data-size-range-min"), m = i[1].getAttribute("data-size-range-max"); i[0].value !== p || i[1].value !== m ? d.closest(".filter__options-item").querySelector("[data-reset-button]").style.display = "flex" : d.closest(".filter__options-item").querySelector("[data-reset-button]").style.display = "none" }) }), t.forEach(f => { f.addEventListener("change", function () { let p = 0; t.forEach(m => { m.checked && p++ }), p > 0 ? d.closest(".filter__options-item").querySelector("[data-reset-button]").style.display = "flex" : d.closest(".filter__options-item").querySelector("[data-reset-button]").style.display = "none", d.innerHTML = p > 0 ? `<strong>:</strong> ${p}` : "" }) }); try { c.addEventListener("click", function () { t.forEach(f => { f.checked = !1 }), d.closest(".filter__options-item").querySelector("[data-reset-button]").style.display = "none", d.innerHTML = ""; try { s.style.left = "0", s.style.right = "0", r[0].value = i[0].getAttribute("data-size-range-min"), i[0].value = i[0].getAttribute("data-size-range-min"), r[1].value = i[1].getAttribute("data-size-range-max"), i[1].value = i[1].getAttribute("data-size-range-max") } catch { } try { l.style.left = "0", l.style.right = "0", o[0].value = a[0].getAttribute("data-price-range-min"), a[0].value = a[0].getAttribute("data-price-range-min"), o[1].value = a[1].getAttribute("data-price-range-max"), a[1].value = a[1].getAttribute("data-price-range-max") } catch { } }) } catch { } try { u.addEventListener("click", function () { document.querySelectorAll(".filter__dropdown-input").forEach(v => { v.checked = !1 }), document.querySelectorAll("[data-reset-button]").forEach(v => { v.style.display = "none" }), document.querySelectorAll(".filter__option-name span").forEach(v => { v.innerHTML = "" }); const f = document.querySelectorAll(".filter__dropdown-inputs-size input"), p = document.querySelectorAll(".filter__dropdown-range-size input"), m = document.querySelector(".filter__dropdown-slider-progress-size"), h = document.querySelectorAll(".filter__dropdown-inputs-price input"), g = document.querySelectorAll(".filter__dropdown-range-price input"), y = document.querySelector(".filter__dropdown-slider-progress-price"); m.style.left = "0", m.style.right = "0", p[0].value = f[0].getAttribute("data-size-range-min"), f[0].value = f[0].getAttribute("data-size-range-min"), p[1].value = f[1].getAttribute("data-size-range-max"), f[1].value = f[1].getAttribute("data-size-range-max"), y.style.left = "0", y.style.right = "0", g[0].value = h[0].getAttribute("data-price-range-min"), h[0].value = h[0].getAttribute("data-price-range-min"), g[1].value = h[1].getAttribute("data-price-range-max"), h[1].value = h[1].getAttribute("data-price-range-max") }) } catch { } }) }), document.addEventListener("DOMContentLoaded", () => { const n = document.querySelector(".filter__dropdown-item"), e = Array.from(n.children), t = document.createElement("button"); t.setAttribute("type", "button"), t.classList.add("filter__show-button"); let i; window.innerWidth < 740 ? i = 6 : i = 9999; let r = !1; e.forEach((s, a) => { a >= i && (s.style.display = "none") }), e.length > i && (t.textContent = "Показать все", n.parentNode.insertBefore(t, n.nextSibling), t.addEventListener("click", () => { e.forEach((s, a) => { a >= i && (s.style.display = r ? "none" : "") }), t.textContent = r ? "Показать все" : "Скрыть", r = !r })) })); if (document.querySelector(".filter__options-item")) { let r = function () { n && n.getAttribute("data-search") === "open" ? (n.dataset.search = "close", Td(n)) : n && (n.dataset.search = "open", wn(n)) }; var lp = r; const n = document.querySelector("[data-search]"), e = document.querySelector("[data-search-open]"), t = document.querySelector("[data-search-close]"); document.querySelectorAll(".filter__options-item").forEach(s => { s.addEventListener("click", () => { n && (n.dataset.search = "open", wn(n)) }) }), e.addEventListener("click", r), t.addEventListener("click", r) } document.addEventListener("click", n => { n.target.matches("[data-dropdown-table-button='1']") && (n.target.classList.add("active"), document.querySelector("[data-dropdown-table-button='2']").classList.remove("active"), document.querySelector("[data-dropdown-table='1']").style.display = "block", document.querySelector("[data-dropdown-table='2']").style.display = "none"), n.target.matches("[data-dropdown-table-button='2']") && (n.target.classList.add("active"), document.querySelector("[data-dropdown-table-button='1']").classList.remove("active"), document.querySelector("[data-dropdown-table='2']").style.display = "block", document.querySelector("[data-dropdown-table='1']").style.display = "none") }); class sp { constructor(e) { document.querySelectorAll(e).forEach(i => { if (i.querySelectorAll("img").length > 1) { const r = document.createElement("div"); r.classList.add("hvr"); const s = document.createElement("div"); s.classList.add("hvr__images"), r.appendChild(s); const a = document.createElement("div"); a.classList.add("hvr__sectors"), s.appendChild(a); const o = document.createElement("div"); o.classList.add("hvr__dots"), r.appendChild(o), i.parentNode.insertBefore(r, i), s.prepend(i); const l = r.querySelectorAll("img"); l.forEach(() => { a.insertAdjacentHTML("afterbegin", '<div class="hvr__sector"></div>'), o.insertAdjacentHTML("afterbegin", '<div class="hvr__dot"></div>') }), o.firstChild.classList.add("hvr__dot--active"); const d = function (c) { const u = [...a.children].indexOf(c); l.forEach((f, p) => { u == p ? f.style.display = "block" : f.style.display = "none" }), r.querySelectorAll(".hvr__dot").forEach((f, p) => { u == p ? f.classList.add("hvr__dot--active") : f.classList.remove("hvr__dot--active") }) }; a.addEventListener("mouseover", function (c) { c.target.matches(".hvr__sector") && d(c.target) }), a.addEventListener("touchmove", function (c) { const u = c.changedTouches[0], f = document.elementFromPoint(u.clientX, u.clientY); f.matches(".hvr__sector") && d(f) }) } }) } } new sp(".images"); const Fo = document.querySelector(".navigation"); let np = 170; window.addEventListener("scroll", () => { (window.pageYOffset || document.documentElement.scrollTop) > np ? Fo.classList.add("navigation__move") : Fo.classList.remove("navigation__move") }); const ap = document.querySelectorAll(".overlay__close-button"), Di = document.querySelector(".overlay-box"); Di.style.display = "none"; if (document.querySelector("[consultation-overlay]")) { const n = document.querySelector("[consultation-overlay]"), e = document.getElementById("consultation-overlay"); n.addEventListener("click", () => { e.style.display = "flex", Di.style.display = "unset", document.body.style.overflow = "hidden", document.querySelector(".header").style.filter = "blur(4px)", document.querySelector(".main").style.filter = "blur(4px)", document.querySelector(".footer").style.filter = "blur(4px)", document.querySelector(".navigation").style.filter = "blur(4px)" }), e.addEventListener("click", t => { t.target === e && (e.style.display = "none", Di.style.display = "none", document.body.style.overflow = "unset", document.querySelector(".header").style.filter = "unset", document.querySelector(".main").style.filter = "unset", document.querySelector(".footer").style.filter = "unset", document.querySelector(".navigation").style.filter = "unset") }) } if (document.querySelector("[project-overlay]")) { const n = document.querySelector("[project-overlay]"), e = document.getElementById("project-overlay"); n.addEventListener("click", () => { e.style.display = "flex", Di.style.display = "unset", document.body.style.overflow = "hidden", document.querySelector(".header").style.filter = "blur(4px)", document.querySelector(".main").style.filter = "blur(4px)", document.querySelector(".footer").style.filter = "blur(4px)", document.querySelector(".navigation").style.filter = "blur(4px)" }), e.addEventListener("click", t => { t.target === e && (e.style.display = "none", Di.style.display = "none", document.body.style.overflow = "unset", document.querySelector(".header").style.filter = "unset", document.querySelector(".main").style.filter = "unset", document.querySelector(".footer").style.filter = "unset", document.querySelector(".navigation").style.filter = "unset") }) } if (document.querySelector("[header-overlay]")) { const n = document.querySelector("[header-overlay]"), e = document.getElementById("header-overlay"); n.addEventListener("click", () => { e.style.display = "flex", Di.style.display = "unset", document.body.style.overflow = "hidden", document.querySelector(".header").style.filter = "blur(4px)", document.querySelector(".main").style.filter = "blur(4px)", document.querySelector(".footer").style.filter = "blur(4px)", document.querySelector(".navigation").style.filter = "blur(4px)" }), e.addEventListener("click", t => { t.target === e && (e.style.display = "none", Di.style.display = "none", document.body.style.overflow = "unset", document.querySelector(".header").style.filter = "unset", document.querySelector(".main").style.filter = "unset", document.querySelector(".footer").style.filter = "unset", document.querySelector(".navigation").style.filter = "unset") }) } ap.forEach(n => { n.addEventListener("click", e => { document.querySelectorAll(".overlay").forEach(t => { t.style.display = "none" }), Di.style.display = "none", document.body.style.overflow = "unset", document.querySelector(".header").style.filter = "unset", document.querySelector(".main").style.filter = "unset", document.querySelector(".footer").style.filter = "unset", document.querySelector(".navigation").style.filter = "unset" }) }); if (document.querySelector(".header__items nav")) { let i = function (s, a) { if (s && a) a.appendChild(s); else return }, r = function (s, a) { if (s && a) a.appendChild(s); else return }; var dp = i, cp = r; const n = document.querySelectorAll(".header__item")[3], e = document.querySelector(".header__items nav"), t = document.querySelector(".header__button"); window.innerWidth < 740 && i(t, e), window.addEventListener("resize", () => { window.innerWidth < 740 ? i(t, e) : r(t, n) }) }
