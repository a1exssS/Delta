(function () { const e = document.createElement("link").relList; if (e && e.supports && e.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) i(r); new MutationObserver(r => { for (const s of r) if (s.type === "childList") for (const a of s.addedNodes) a.tagName === "LINK" && a.rel === "modulepreload" && i(a) }).observe(document, { childList: !0, subtree: !0 }); function t(r) { const s = {}; return r.integrity && (s.integrity = r.integrity), r.referrerPolicy && (s.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? s.credentials = "include" : r.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s } function i(r) { if (r.ep) return; r.ep = !0; const s = t(r); fetch(r.href, s) } })(); function di(n) { if (n === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); return n } function qo(n, e) { n.prototype = Object.create(e.prototype), n.prototype.constructor = n, n.__proto__ = e }/*!
 * GSAP 3.12.4
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var At = { autoSleep: 120, force3D: "auto", nullTargetWarn: 1, units: { lineHeight: "" } }, Ir = { duration: .5, overwrite: !1, delay: 0 }, Ea, Qe, ve, $t = 1e8, le = 1 / $t, Zn = Math.PI * 2, Cd = Zn / 4, Pd = 0, Yo = Math.sqrt, Ld = Math.cos, Ad = Math.sin, He = function (e) { return typeof e == "string" }, _e = function (e) { return typeof e == "function" }, mi = function (e) { return typeof e == "number" }, Ma = function (e) { return typeof e > "u" }, ai = function (e) { return typeof e == "object" }, gt = function (e) { return e !== !1 }, Ca = function () { return typeof window < "u" }, Os = function (e) { return _e(e) || He(e) }, Ho = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function () { }, Je = Array.isArray, Qn = /(?:-?\.?\d|\.)+/gi, Vo = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g, Tr = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g, Ln = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi, Go = /[+-]=-?[.\d]+/, Xo = /[^,'"\[\]\s]+/gi, kd = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i, me, Dt, Jn, Pa, kt = {}, nn = {}, Wo, jo = function (e) { return (nn = lr(e, kt)) && wt }, La = function (e, t) { return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()") }, _s = function (e, t) { return !t && console.warn(e) }, Uo = function (e, t) { return e && (kt[e] = t) && nn && (nn[e] = t) || kt }, ys = function () { return 0 }, Od = { suppressEvents: !0, isStart: !0, kill: !1 }, Xs = { suppressEvents: !0, kill: !1 }, Dd = { suppressEvents: !0 }, Aa = {}, Pi = [], ea = {}, Ko, Tt = {}, An = {}, Ja = 30, Ws = [], ka = "", Oa = function (e) { var t = e[0], i, r; if (ai(t) || _e(t) || (e = [e]), !(i = (t._gsap || {}).harness)) { for (r = Ws.length; r-- && !Ws[r].targetTest(t);); i = Ws[r] } for (r = e.length; r--;)e[r] && (e[r]._gsap || (e[r]._gsap = new wl(e[r], i))) || e.splice(r, 1); return e }, Ji = function (e) { return e._gsap || Oa(Bt(e))[0]._gsap }, Zo = function (e, t, i) { return (i = e[t]) && _e(i) ? e[t]() : Ma(i) && e.getAttribute && e.getAttribute(t) || i }, vt = function (e, t) { return (e = e.split(",")).forEach(t) || e }, xe = function (e) { return Math.round(e * 1e5) / 1e5 || 0 }, Ye = function (e) { return Math.round(e * 1e7) / 1e7 || 0 }, Pr = function (e, t) { var i = t.charAt(0), r = parseFloat(t.substr(2)); return e = parseFloat(e), i === "+" ? e + r : i === "-" ? e - r : i === "*" ? e * r : e / r }, Id = function (e, t) { for (var i = t.length, r = 0; e.indexOf(t[r]) < 0 && ++r < i;); return r < i }, an = function () { var e = Pi.length, t = Pi.slice(0), i, r; for (ea = {}, Pi.length = 0, i = 0; i < e; i++)r = t[i], r && r._lazy && (r.render(r._lazy[0], r._lazy[1], !0)._lazy = 0) }, Qo = function (e, t, i, r) { Pi.length && !Qe && an(), e.render(t, i, r || Qe && t < 0 && (e._initted || e._startAt)), Pi.length && !Qe && an() }, Jo = function (e) { var t = parseFloat(e); return (t || t === 0) && (e + "").match(Xo).length < 2 ? t : He(e) ? e.trim() : e }, el = function (e) { return e }, Nt = function (e, t) { for (var i in t) i in e || (e[i] = t[i]); return e }, zd = function (e) { return function (t, i) { for (var r in i) r in t || r === "duration" && e || r === "ease" || (t[r] = i[r]) } }, lr = function (e, t) { for (var i in t) e[i] = t[i]; return e }, eo = function n(e, t) { for (var i in t) i !== "__proto__" && i !== "constructor" && i !== "prototype" && (e[i] = ai(t[i]) ? n(e[i] || (e[i] = {}), t[i]) : t[i]); return e }, on = function (e, t) { var i = {}, r; for (r in e) r in t || (i[r] = e[r]); return i }, ss = function (e) { var t = e.parent || me, i = e.keyframes ? zd(Je(e.keyframes)) : Nt; if (gt(e.inherit)) for (; t;)i(e, t.vars.defaults), t = t.parent || t._dp; return e }, Rd = function (e, t) { for (var i = e.length, r = i === t.length; r && i-- && e[i] === t[i];); return i < 0 }, tl = function (e, t, i, r, s) { i === void 0 && (i = "_first"), r === void 0 && (r = "_last"); var a = e[r], o; if (s) for (o = t[s]; a && a[s] > o;)a = a._prev; return a ? (t._next = a._next, a._next = t) : (t._next = e[i], e[i] = t), t._next ? t._next._prev = t : e[r] = t, t._prev = a, t.parent = t._dp = e, t }, xn = function (e, t, i, r) { i === void 0 && (i = "_first"), r === void 0 && (r = "_last"); var s = t._prev, a = t._next; s ? s._next = a : e[i] === t && (e[i] = a), a ? a._prev = s : e[r] === t && (e[r] = s), t._next = t._prev = t.parent = null }, ki = function (e, t) { e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0 }, er = function (e, t) { if (e && (!t || t._end > e._dur || t._start < 0)) for (var i = e; i;)i._dirty = 1, i = i.parent; return e }, $d = function (e) { for (var t = e.parent; t && t.parent;)t._dirty = 1, t.totalDuration(), t = t.parent; return e }, ta = function (e, t, i, r) { return e._startAt && (Qe ? e._startAt.revert(Xs) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, r)) }, Bd = function n(e) { return !e || e._ts && n(e.parent) }, to = function (e) { return e._repeat ? zr(e._tTime, e = e.duration() + e._rDelay) * e : 0 }, zr = function (e, t) { var i = Math.floor(e /= t); return e && i === e ? i - 1 : i }, ln = function (e, t) { return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur) }, Sn = function (e) { return e._end = Ye(e._start + (e._tDur / Math.abs(e._ts || e._rts || le) || 0)) }, Tn = function (e, t) { var i = e._dp; return i && i.smoothChildTiming && e._ts && (e._start = Ye(i._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), Sn(e), i._dirty || er(i, e)), e }, il = function (e, t) { var i; if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (i = ln(e.rawTime(), t), (!t._dur || Ps(0, t.totalDuration(), i) - t._tTime > le) && t.render(i, !0)), er(e, t)._dp && e._initted && e._time >= e._dur && e._ts) { if (e._dur < e.duration()) for (i = e; i._dp;)i.rawTime() >= 0 && i.totalTime(i._tTime), i = i._dp; e._zTime = -le } }, ti = function (e, t, i, r) { return t.parent && ki(t), t._start = Ye((mi(i) ? i : i || e !== me ? Ot(e, i, t) : e._time) + t._delay), t._end = Ye(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), tl(e, t, "_first", "_last", e._sort ? "_start" : 0), ia(t) || (e._recent = t), r || il(e, t), e._ts < 0 && Tn(e, e._tTime), e }, rl = function (e, t) { return (kt.ScrollTrigger || La("scrollTrigger", t)) && kt.ScrollTrigger.create(t, e) }, sl = function (e, t, i, r, s) { if (Ia(e, t, s), !e._initted) return 1; if (!i && e._pt && !Qe && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && Ko !== Mt.frame) return Pi.push(e), e._lazy = [s, r], 1 }, Fd = function n(e) { var t = e.parent; return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || n(t)) }, ia = function (e) { var t = e.data; return t === "isFromStart" || t === "isStart" }, Nd = function (e, t, i, r) { var s = e.ratio, a = t < 0 || !t && (!e._start && Fd(e) && !(!e._initted && ia(e)) || (e._ts < 0 || e._dp._ts < 0) && !ia(e)) ? 0 : 1, o = e._rDelay, l = 0, c, d, u; if (o && e._repeat && (l = Ps(0, e._tDur, t), d = zr(l, o), e._yoyo && d & 1 && (a = 1 - a), d !== zr(e._tTime, o) && (s = 1 - a, e.vars.repeatRefresh && e._initted && e.invalidate())), a !== s || Qe || r || e._zTime === le || !t && e._zTime) { if (!e._initted && sl(e, t, r, i, l)) return; for (u = e._zTime, e._zTime = t || (i ? le : 0), i || (i = t && !u), e.ratio = a, e._from && (a = 1 - a), e._time = 0, e._tTime = l, c = e._pt; c;)c.r(a, c.d), c = c._next; t < 0 && ta(e, t, i, !0), e._onUpdate && !i && Pt(e, "onUpdate"), l && e._repeat && !i && e.parent && Pt(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === a && (a && ki(e, 1), !i && !Qe && (Pt(e, a ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom())) } else e._zTime || (e._zTime = t) }, qd = function (e, t, i) { var r; if (i > t) for (r = e._first; r && r._start <= i;) { if (r.data === "isPause" && r._start > t) return r; r = r._next } else for (r = e._last; r && r._start >= i;) { if (r.data === "isPause" && r._start < t) return r; r = r._prev } }, Rr = function (e, t, i, r) { var s = e._repeat, a = Ye(t) || 0, o = e._tTime / e._tDur; return o && !r && (e._time *= a / e._dur), e._dur = a, e._tDur = s ? s < 0 ? 1e10 : Ye(a * (s + 1) + e._rDelay * s) : a, o > 0 && !r && Tn(e, e._tTime = e._tDur * o), e.parent && Sn(e), i || er(e.parent, e), e }, io = function (e) { return e instanceof dt ? er(e) : Rr(e, e._dur) }, Yd = { _start: 0, endTime: ys, totalDuration: ys }, Ot = function n(e, t, i) { var r = e.labels, s = e._recent || Yd, a = e.duration() >= $t ? s.endTime(!1) : e._dur, o, l, c; return He(t) && (isNaN(t) || t in r) ? (l = t.charAt(0), c = t.substr(-1) === "%", o = t.indexOf("="), l === "<" || l === ">" ? (o >= 0 && (t = t.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (o < 0 ? s : i).totalDuration() / 100 : 1)) : o < 0 ? (t in r || (r[t] = a), r[t]) : (l = parseFloat(t.charAt(o - 1) + t.substr(o + 1)), c && i && (l = l / 100 * (Je(i) ? i[0] : i).totalDuration()), o > 1 ? n(e, t.substr(0, o - 1), i) + l : a + l)) : t == null ? a : +t }, ns = function (e, t, i) { var r = mi(t[1]), s = (r ? 2 : 1) + (e < 2 ? 0 : 1), a = t[s], o, l; if (r && (a.duration = t[1]), a.parent = i, e) { for (o = a, l = i; l && !("immediateRender" in o);)o = l.vars.defaults || {}, l = gt(l.vars.inherit) && l.parent; a.immediateRender = gt(o.immediateRender), e < 2 ? a.runBackwards = 1 : a.startAt = t[s - 1] } return new Me(t[0], a, t[s + 1]) }, zi = function (e, t) { return e || e === 0 ? t(e) : t }, Ps = function (e, t, i) { return i < e ? e : i > t ? t : i }, Ze = function (e, t) { return !He(e) || !(t = kd.exec(e)) ? "" : t[1] }, Hd = function (e, t, i) { return zi(i, function (r) { return Ps(e, t, r) }) }, ra = [].slice, nl = function (e, t) { return e && ai(e) && "length" in e && (!t && !e.length || e.length - 1 in e && ai(e[0])) && !e.nodeType && e !== Dt }, Vd = function (e, t, i) { return i === void 0 && (i = []), e.forEach(function (r) { var s; return He(r) && !t || nl(r, 1) ? (s = i).push.apply(s, Bt(r)) : i.push(r) }) || i }, Bt = function (e, t, i) { return ve && !t && ve.selector ? ve.selector(e) : He(e) && !i && (Jn || !$r()) ? ra.call((t || Pa).querySelectorAll(e), 0) : Je(e) ? Vd(e, i) : nl(e) ? ra.call(e, 0) : e ? [e] : [] }, sa = function (e) { return e = Bt(e)[0] || _s("Invalid scope") || {}, function (t) { var i = e.current || e.nativeElement || e; return Bt(t, i.querySelectorAll ? i : i === e ? _s("Invalid scope") || Pa.createElement("div") : e) } }, al = function (e) { return e.sort(function () { return .5 - Math.random() }) }, ol = function (e) { if (_e(e)) return e; var t = ai(e) ? e : { each: e }, i = tr(t.ease), r = t.from || 0, s = parseFloat(t.base) || 0, a = {}, o = r > 0 && r < 1, l = isNaN(r) || o, c = t.axis, d = r, u = r; return He(r) ? d = u = { center: .5, edges: .5, end: 1 }[r] || 0 : !o && l && (d = r[0], u = r[1]), function (f, p, g) { var h = (g || t).length, m = a[h], y, _, v, w, x, S, P, A, M; if (!m) { if (M = t.grid === "auto" ? 0 : (t.grid || [1, $t])[1], !M) { for (P = -$t; P < (P = g[M++].getBoundingClientRect().left) && M < h;); M < h && M-- } for (m = a[h] = [], y = l ? Math.min(M, h) * d - .5 : r % M, _ = M === $t ? 0 : l ? h * u / M - .5 : r / M | 0, P = 0, A = $t, S = 0; S < h; S++)v = S % M - y, w = _ - (S / M | 0), m[S] = x = c ? Math.abs(c === "y" ? w : v) : Yo(v * v + w * w), x > P && (P = x), x < A && (A = x); r === "random" && al(m), m.max = P - A, m.min = A, m.v = h = (parseFloat(t.amount) || parseFloat(t.each) * (M > h ? h - 1 : c ? c === "y" ? h / M : M : Math.max(M, h / M)) || 0) * (r === "edges" ? -1 : 1), m.b = h < 0 ? s - h : s, m.u = Ze(t.amount || t.each) || 0, i = i && h < 0 ? vl(i) : i } return h = (m[f] - m.min) / m.max || 0, Ye(m.b + (i ? i(h) : h) * m.v) + m.u } }, na = function (e) { var t = Math.pow(10, ((e + "").split(".")[1] || "").length); return function (i) { var r = Ye(Math.round(parseFloat(i) / e) * e * t); return (r - r % 1) / t + (mi(i) ? 0 : Ze(i)) } }, ll = function (e, t) { var i = Je(e), r, s; return !i && ai(e) && (r = i = e.radius || $t, e.values ? (e = Bt(e.values), (s = !mi(e[0])) && (r *= r)) : e = na(e.increment)), zi(t, i ? _e(e) ? function (a) { return s = e(a), Math.abs(s - a) <= r ? s : a } : function (a) { for (var o = parseFloat(s ? a.x : a), l = parseFloat(s ? a.y : 0), c = $t, d = 0, u = e.length, f, p; u--;)s ? (f = e[u].x - o, p = e[u].y - l, f = f * f + p * p) : f = Math.abs(e[u] - o), f < c && (c = f, d = u); return d = !r || c <= r ? e[d] : a, s || d === a || mi(a) ? d : d + Ze(a) } : na(e)) }, dl = function (e, t, i, r) { return zi(Je(e) ? !t : i === !0 ? !!(i = 0) : !r, function () { return Je(e) ? e[~~(Math.random() * e.length)] : (i = i || 1e-5) && (r = i < 1 ? Math.pow(10, (i + "").length - 2) : 1) && Math.floor(Math.round((e - i / 2 + Math.random() * (t - e + i * .99)) / i) * i * r) / r }) }, Gd = function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; return function (r) { return t.reduce(function (s, a) { return a(s) }, r) } }, Xd = function (e, t) { return function (i) { return e(parseFloat(i)) + (t || Ze(i)) } }, Wd = function (e, t, i) { return ul(e, t, 0, 1, i) }, cl = function (e, t, i) { return zi(i, function (r) { return e[~~t(r)] }) }, jd = function n(e, t, i) { var r = t - e; return Je(e) ? cl(e, n(0, e.length), t) : zi(i, function (s) { return (r + (s - e) % r) % r + e }) }, Ud = function n(e, t, i) { var r = t - e, s = r * 2; return Je(e) ? cl(e, n(0, e.length - 1), t) : zi(i, function (a) { return a = (s + (a - e) % s) % s || 0, e + (a > r ? s - a : a) }) }, ws = function (e) { for (var t = 0, i = "", r, s, a, o; ~(r = e.indexOf("random(", t));)a = e.indexOf(")", r), o = e.charAt(r + 7) === "[", s = e.substr(r + 7, a - r - 7).match(o ? Xo : Qn), i += e.substr(t, r - t) + dl(o ? s : +s[0], o ? 0 : +s[1], +s[2] || 1e-5), t = a + 1; return i + e.substr(t, e.length - t) }, ul = function (e, t, i, r, s) { var a = t - e, o = r - i; return zi(s, function (l) { return i + ((l - e) / a * o || 0) }) }, Kd = function n(e, t, i, r) { var s = isNaN(e + t) ? 0 : function (p) { return (1 - p) * e + p * t }; if (!s) { var a = He(e), o = {}, l, c, d, u, f; if (i === !0 && (r = 1) && (i = null), a) e = { p: e }, t = { p: t }; else if (Je(e) && !Je(t)) { for (d = [], u = e.length, f = u - 2, c = 1; c < u; c++)d.push(n(e[c - 1], e[c])); u--, s = function (g) { g *= u; var h = Math.min(f, ~~g); return d[h](g - h) }, i = t } else r || (e = lr(Je(e) ? [] : {}, e)); if (!d) { for (l in t) Da.call(o, e, l, "get", t[l]); s = function (g) { return $a(g, o) || (a ? e.p : e) } } } return zi(i, s) }, ro = function (e, t, i) { var r = e.labels, s = $t, a, o, l; for (a in r) o = r[a] - t, o < 0 == !!i && o && s > (o = Math.abs(o)) && (l = a, s = o); return l }, Pt = function (e, t, i) { var r = e.vars, s = r[t], a = ve, o = e._ctx, l, c, d; if (s) return l = r[t + "Params"], c = r.callbackScope || e, i && Pi.length && an(), o && (ve = o), d = l ? s.apply(c, l) : s.call(c), ve = a, d }, Ur = function (e) { return ki(e), e.scrollTrigger && e.scrollTrigger.kill(!!Qe), e.progress() < 1 && Pt(e, "onInterrupt"), e }, Er, fl = [], pl = function (e) { if (Ca() && e) { e = !e.name && e.default || e; var t = e.name, i = _e(e), r = t && !i && e.init ? function () { this._props = [] } : e, s = { init: ys, render: $a, add: Da, kill: fc, modifier: uc, rawVars: 0 }, a = { targetTest: 0, get: 0, getSetter: Ra, aliases: {}, register: 0 }; if ($r(), e !== r) { if (Tt[t]) return; Nt(r, Nt(on(e, s), a)), lr(r.prototype, lr(s, on(e, a))), Tt[r.prop = t] = r, e.targetTest && (Ws.push(r), Aa[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin" } Uo(t, r), e.register && e.register(wt, r, _t) } else e && fl.push(e) }, oe = 255, Kr = { aqua: [0, oe, oe], lime: [0, oe, 0], silver: [192, 192, 192], black: [0, 0, 0], maroon: [128, 0, 0], teal: [0, 128, 128], blue: [0, 0, oe], navy: [0, 0, 128], white: [oe, oe, oe], olive: [128, 128, 0], yellow: [oe, oe, 0], orange: [oe, 165, 0], gray: [128, 128, 128], purple: [128, 0, 128], green: [0, 128, 0], red: [oe, 0, 0], pink: [oe, 192, 203], cyan: [0, oe, oe], transparent: [oe, oe, oe, 0] }, kn = function (e, t, i) { return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (i - t) * e * 6 : e < .5 ? i : e * 3 < 2 ? t + (i - t) * (2 / 3 - e) * 6 : t) * oe + .5 | 0 }, hl = function (e, t, i) { var r = e ? mi(e) ? [e >> 16, e >> 8 & oe, e & oe] : 0 : Kr.black, s, a, o, l, c, d, u, f, p, g; if (!r) { if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), Kr[e]) r = Kr[e]; else if (e.charAt(0) === "#") { if (e.length < 6 && (s = e.charAt(1), a = e.charAt(2), o = e.charAt(3), e = "#" + s + s + a + a + o + o + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return r = parseInt(e.substr(1, 6), 16), [r >> 16, r >> 8 & oe, r & oe, parseInt(e.substr(7), 16) / 255]; e = parseInt(e.substr(1), 16), r = [e >> 16, e >> 8 & oe, e & oe] } else if (e.substr(0, 3) === "hsl") { if (r = g = e.match(Qn), !t) l = +r[0] % 360 / 360, c = +r[1] / 100, d = +r[2] / 100, a = d <= .5 ? d * (c + 1) : d + c - d * c, s = d * 2 - a, r.length > 3 && (r[3] *= 1), r[0] = kn(l + 1 / 3, s, a), r[1] = kn(l, s, a), r[2] = kn(l - 1 / 3, s, a); else if (~e.indexOf("=")) return r = e.match(Vo), i && r.length < 4 && (r[3] = 1), r } else r = e.match(Qn) || Kr.transparent; r = r.map(Number) } return t && !g && (s = r[0] / oe, a = r[1] / oe, o = r[2] / oe, u = Math.max(s, a, o), f = Math.min(s, a, o), d = (u + f) / 2, u === f ? l = c = 0 : (p = u - f, c = d > .5 ? p / (2 - u - f) : p / (u + f), l = u === s ? (a - o) / p + (a < o ? 6 : 0) : u === a ? (o - s) / p + 2 : (s - a) / p + 4, l *= 60), r[0] = ~~(l + .5), r[1] = ~~(c * 100 + .5), r[2] = ~~(d * 100 + .5)), i && r.length < 4 && (r[3] = 1), r }, ml = function (e) { var t = [], i = [], r = -1; return e.split(Li).forEach(function (s) { var a = s.match(Tr) || []; t.push.apply(t, a), i.push(r += a.length + 1) }), t.c = i, t }, so = function (e, t, i) { var r = "", s = (e + r).match(Li), a = t ? "hsla(" : "rgba(", o = 0, l, c, d, u; if (!s) return e; if (s = s.map(function (f) { return (f = hl(f, t, 1)) && a + (t ? f[0] + "," + f[1] + "%," + f[2] + "%," + f[3] : f.join(",")) + ")" }), i && (d = ml(e), l = i.c, l.join(r) !== d.c.join(r))) for (c = e.replace(Li, "1").split(Tr), u = c.length - 1; o < u; o++)r += c[o] + (~l.indexOf(o) ? s.shift() || a + "0,0,0,0)" : (d.length ? d : s.length ? s : i).shift()); if (!c) for (c = e.split(Li), u = c.length - 1; o < u; o++)r += c[o] + s[o]; return r + c[u] }, Li = function () { var n = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b", e; for (e in Kr) n += "|" + e + "\\b"; return new RegExp(n + ")", "gi") }(), Zd = /hsl[a]?\(/, gl = function (e) { var t = e.join(" "), i; if (Li.lastIndex = 0, Li.test(t)) return i = Zd.test(t), e[1] = so(e[1], i), e[0] = so(e[0], i, ml(e[1])), !0 }, bs, Mt = function () { var n = Date.now, e = 500, t = 33, i = n(), r = i, s = 1e3 / 240, a = s, o = [], l, c, d, u, f, p, g = function h(m) { var y = n() - r, _ = m === !0, v, w, x, S; if (y > e && (i += y - t), r += y, x = r - i, v = x - a, (v > 0 || _) && (S = ++u.frame, f = x - u.time * 1e3, u.time = x = x / 1e3, a += v + (v >= s ? 4 : s - v), w = 1), _ || (l = c(h)), w) for (p = 0; p < o.length; p++)o[p](x, f, S, m) }; return u = { time: 0, frame: 0, tick: function () { g(!0) }, deltaRatio: function (m) { return f / (1e3 / (m || 60)) }, wake: function () { Wo && (!Jn && Ca() && (Dt = Jn = window, Pa = Dt.document || {}, kt.gsap = wt, (Dt.gsapVersions || (Dt.gsapVersions = [])).push(wt.version), jo(nn || Dt.GreenSockGlobals || !Dt.gsap && Dt || {}), d = Dt.requestAnimationFrame, fl.forEach(pl)), l && u.sleep(), c = d || function (m) { return setTimeout(m, a - u.time * 1e3 + 1 | 0) }, bs = 1, g(2)) }, sleep: function () { (d ? Dt.cancelAnimationFrame : clearTimeout)(l), bs = 0, c = ys }, lagSmoothing: function (m, y) { e = m || 1 / 0, t = Math.min(y || 33, e) }, fps: function (m) { s = 1e3 / (m || 240), a = u.time * 1e3 + s }, add: function (m, y, _) { var v = y ? function (w, x, S, P) { m(w, x, S, P), u.remove(v) } : m; return u.remove(m), o[_ ? "unshift" : "push"](v), $r(), v }, remove: function (m, y) { ~(y = o.indexOf(m)) && o.splice(y, 1) && p >= y && p-- }, _listeners: o }, u }(), $r = function () { return !bs && Mt.wake() }, J = {}, Qd = /^[\d.\-M][\d.\-,\s]/, Jd = /["']/g, ec = function (e) { for (var t = {}, i = e.substr(1, e.length - 3).split(":"), r = i[0], s = 1, a = i.length, o, l, c; s < a; s++)l = i[s], o = s !== a - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, o), t[r] = isNaN(c) ? c.replace(Jd, "").trim() : +c, r = l.substr(o + 1).trim(); return t }, tc = function (e) { var t = e.indexOf("(") + 1, i = e.indexOf(")"), r = e.indexOf("(", t); return e.substring(t, ~r && r < i ? e.indexOf(")", i + 1) : i) }, ic = function (e) { var t = (e + "").split("("), i = J[t[0]]; return i && t.length > 1 && i.config ? i.config.apply(null, ~e.indexOf("{") ? [ec(t[1])] : tc(e).split(",").map(Jo)) : J._CE && Qd.test(e) ? J._CE("", e) : i }, vl = function (e) { return function (t) { return 1 - e(1 - t) } }, _l = function n(e, t) { for (var i = e._first, r; i;)i instanceof dt ? n(i, t) : i.vars.yoyoEase && (!i._yoyo || !i._repeat) && i._yoyo !== t && (i.timeline ? n(i.timeline, t) : (r = i._ease, i._ease = i._yEase, i._yEase = r, i._yoyo = t)), i = i._next }, tr = function (e, t) { return e && (_e(e) ? e : J[e] || ic(e)) || t }, hr = function (e, t, i, r) { i === void 0 && (i = function (l) { return 1 - t(1 - l) }), r === void 0 && (r = function (l) { return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2 }); var s = { easeIn: t, easeOut: i, easeInOut: r }, a; return vt(e, function (o) { J[o] = kt[o] = s, J[a = o.toLowerCase()] = i; for (var l in s) J[a + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = J[o + "." + l] = s[l] }), s }, yl = function (e) { return function (t) { return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2 } }, On = function n(e, t, i) { var r = t >= 1 ? t : 1, s = (i || (e ? .3 : .45)) / (t < 1 ? t : 1), a = s / Zn * (Math.asin(1 / r) || 0), o = function (d) { return d === 1 ? 1 : r * Math.pow(2, -10 * d) * Ad((d - a) * s) + 1 }, l = e === "out" ? o : e === "in" ? function (c) { return 1 - o(1 - c) } : yl(o); return s = Zn / s, l.config = function (c, d) { return n(e, c, d) }, l }, Dn = function n(e, t) { t === void 0 && (t = 1.70158); var i = function (a) { return a ? --a * a * ((t + 1) * a + t) + 1 : 0 }, r = e === "out" ? i : e === "in" ? function (s) { return 1 - i(1 - s) } : yl(i); return r.config = function (s) { return n(e, s) }, r }; vt("Linear,Quad,Cubic,Quart,Quint,Strong", function (n, e) { var t = e < 5 ? e + 1 : e; hr(n + ",Power" + (t - 1), e ? function (i) { return Math.pow(i, t) } : function (i) { return i }, function (i) { return 1 - Math.pow(1 - i, t) }, function (i) { return i < .5 ? Math.pow(i * 2, t) / 2 : 1 - Math.pow((1 - i) * 2, t) / 2 }) }); J.Linear.easeNone = J.none = J.Linear.easeIn; hr("Elastic", On("in"), On("out"), On()); (function (n, e) { var t = 1 / e, i = 2 * t, r = 2.5 * t, s = function (o) { return o < t ? n * o * o : o < i ? n * Math.pow(o - 1.5 / e, 2) + .75 : o < r ? n * (o -= 2.25 / e) * o + .9375 : n * Math.pow(o - 2.625 / e, 2) + .984375 }; hr("Bounce", function (a) { return 1 - s(1 - a) }, s) })(7.5625, 2.75); hr("Expo", function (n) { return n ? Math.pow(2, 10 * (n - 1)) : 0 }); hr("Circ", function (n) { return -(Yo(1 - n * n) - 1) }); hr("Sine", function (n) { return n === 1 ? 1 : -Ld(n * Cd) + 1 }); hr("Back", Dn("in"), Dn("out"), Dn()); J.SteppedEase = J.steps = kt.SteppedEase = { config: function (e, t) { e === void 0 && (e = 1); var i = 1 / e, r = e + (t ? 0 : 1), s = t ? 1 : 0, a = 1 - le; return function (o) { return ((r * Ps(0, a, o) | 0) + s) * i } } }; Ir.ease = J["quad.out"]; vt("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function (n) { return ka += n + "," + n + "Params," }); var wl = function (e, t) { this.id = Pd++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Zo, this.set = t ? t.getSetter : Ra }, xs = function () { function n(t) { this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Rr(this, +t.duration, 1, 1), this.data = t.data, ve && (this._ctx = ve, ve.data.push(this)), bs || Mt.wake() } var e = n.prototype; return e.delay = function (i) { return i || i === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + i - this._delay), this._delay = i, this) : this._delay }, e.duration = function (i) { return arguments.length ? this.totalDuration(this._repeat > 0 ? i + (i + this._rDelay) * this._repeat : i) : this.totalDuration() && this._dur }, e.totalDuration = function (i) { return arguments.length ? (this._dirty = 0, Rr(this, this._repeat < 0 ? i : (i - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur }, e.totalTime = function (i, r) { if ($r(), !arguments.length) return this._tTime; var s = this._dp; if (s && s.smoothChildTiming && this._ts) { for (Tn(this, i), !s._dp || s.parent || il(s, this); s && s.parent;)s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0), s = s.parent; !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && i < this._tDur || this._ts < 0 && i > 0 || !this._tDur && !i) && ti(this._dp, this, this._start - this._delay) } return (this._tTime !== i || !this._dur && !r || this._initted && Math.abs(this._zTime) === le || !i && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = i), Qo(this, i, r)), this }, e.time = function (i, r) { return arguments.length ? this.totalTime(Math.min(this.totalDuration(), i + to(this)) % (this._dur + this._rDelay) || (i ? this._dur : 0), r) : this._time }, e.totalProgress = function (i, r) { return arguments.length ? this.totalTime(this.totalDuration() * i, r) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0 }, e.progress = function (i, r) { return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - i : i) + to(this), r) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0 }, e.iteration = function (i, r) { var s = this.duration() + this._rDelay; return arguments.length ? this.totalTime(this._time + (i - 1) * s, r) : this._repeat ? zr(this._tTime, s) + 1 : 1 }, e.timeScale = function (i, r) { if (!arguments.length) return this._rts === -le ? 0 : this._rts; if (this._rts === i) return this; var s = this.parent && this._ts ? ln(this.parent._time, this) : this._tTime; return this._rts = +i || 0, this._ts = this._ps || i === -le ? 0 : this._rts, this.totalTime(Ps(-Math.abs(this._delay), this._tDur, s), r !== !1), Sn(this), $d(this) }, e.paused = function (i) { return arguments.length ? (this._ps !== i && (this._ps = i, i ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : ($r(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== le && (this._tTime -= le)))), this) : this._ps }, e.startTime = function (i) { if (arguments.length) { this._start = i; var r = this.parent || this._dp; return r && (r._sort || !this.parent) && ti(r, this, i - this._delay), this } return this._start }, e.endTime = function (i) { return this._start + (gt(i) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1) }, e.rawTime = function (i) { var r = this.parent || this._dp; return r ? i && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? ln(r.rawTime(i), this) : this._tTime : this._tTime }, e.revert = function (i) { i === void 0 && (i = Dd); var r = Qe; return Qe = i, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(i), this.totalTime(-.01, i.suppressEvents)), this.data !== "nested" && i.kill !== !1 && this.kill(), Qe = r, this }, e.globalTime = function (i) { for (var r = this, s = arguments.length ? i : r.rawTime(); r;)s = r._start + s / (Math.abs(r._ts) || 1), r = r._dp; return !this.parent && this._sat ? this._sat.globalTime(i) : s }, e.repeat = function (i) { return arguments.length ? (this._repeat = i === 1 / 0 ? -2 : i, io(this)) : this._repeat === -2 ? 1 / 0 : this._repeat }, e.repeatDelay = function (i) { if (arguments.length) { var r = this._time; return this._rDelay = i, io(this), r ? this.time(r) : this } return this._rDelay }, e.yoyo = function (i) { return arguments.length ? (this._yoyo = i, this) : this._yoyo }, e.seek = function (i, r) { return this.totalTime(Ot(this, i), gt(r)) }, e.restart = function (i, r) { return this.play().totalTime(i ? -this._delay : 0, gt(r)) }, e.play = function (i, r) { return i != null && this.seek(i, r), this.reversed(!1).paused(!1) }, e.reverse = function (i, r) { return i != null && this.seek(i || this.totalDuration(), r), this.reversed(!0).paused(!1) }, e.pause = function (i, r) { return i != null && this.seek(i, r), this.paused(!0) }, e.resume = function () { return this.paused(!1) }, e.reversed = function (i) { return arguments.length ? (!!i !== this.reversed() && this.timeScale(-this._rts || (i ? -le : 0)), this) : this._rts < 0 }, e.invalidate = function () { return this._initted = this._act = 0, this._zTime = -le, this }, e.isActive = function () { var i = this.parent || this._dp, r = this._start, s; return !!(!i || this._ts && this._initted && i.isActive() && (s = i.rawTime(!0)) >= r && s < this.endTime(!0) - le) }, e.eventCallback = function (i, r, s) { var a = this.vars; return arguments.length > 1 ? (r ? (a[i] = r, s && (a[i + "Params"] = s), i === "onUpdate" && (this._onUpdate = r)) : delete a[i], this) : a[i] }, e.then = function (i) { var r = this; return new Promise(function (s) { var a = _e(i) ? i : el, o = function () { var c = r.then; r.then = null, _e(a) && (a = a(r)) && (a.then || a === r) && (r.then = c), s(a), r.then = c }; r._initted && r.totalProgress() === 1 && r._ts >= 0 || !r._tTime && r._ts < 0 ? o() : r._prom = o }) }, e.kill = function () { Ur(this) }, n }(); Nt(xs.prototype, { _time: 0, _start: 0, _end: 0, _tTime: 0, _tDur: 0, _dirty: 0, _repeat: 0, _yoyo: !1, parent: null, _initted: !1, _rDelay: 0, _ts: 1, _dp: 0, ratio: 0, _zTime: -le, _prom: 0, _ps: !1, _rts: 1 }); var dt = function (n) { qo(e, n); function e(i, r) { var s; return i === void 0 && (i = {}), s = n.call(this, i) || this, s.labels = {}, s.smoothChildTiming = !!i.smoothChildTiming, s.autoRemoveChildren = !!i.autoRemoveChildren, s._sort = gt(i.sortChildren), me && ti(i.parent || me, di(s), r), i.reversed && s.reverse(), i.paused && s.paused(!0), i.scrollTrigger && rl(di(s), i.scrollTrigger), s } var t = e.prototype; return t.to = function (r, s, a) { return ns(0, arguments, this), this }, t.from = function (r, s, a) { return ns(1, arguments, this), this }, t.fromTo = function (r, s, a, o) { return ns(2, arguments, this), this }, t.set = function (r, s, a) { return s.duration = 0, s.parent = this, ss(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new Me(r, s, Ot(this, a), 1), this }, t.call = function (r, s, a) { return ti(this, Me.delayedCall(0, r, s), a) }, t.staggerTo = function (r, s, a, o, l, c, d) { return a.duration = s, a.stagger = a.stagger || o, a.onComplete = c, a.onCompleteParams = d, a.parent = this, new Me(r, a, Ot(this, l)), this }, t.staggerFrom = function (r, s, a, o, l, c, d) { return a.runBackwards = 1, ss(a).immediateRender = gt(a.immediateRender), this.staggerTo(r, s, a, o, l, c, d) }, t.staggerFromTo = function (r, s, a, o, l, c, d, u) { return o.startAt = a, ss(o).immediateRender = gt(o.immediateRender), this.staggerTo(r, s, o, l, c, d, u) }, t.render = function (r, s, a) { var o = this._time, l = this._dirty ? this.totalDuration() : this._tDur, c = this._dur, d = r <= 0 ? 0 : Ye(r), u = this._zTime < 0 != r < 0 && (this._initted || !c), f, p, g, h, m, y, _, v, w, x, S, P; if (this !== me && d > l && r >= 0 && (d = l), d !== this._tTime || a || u) { if (o !== this._time && c && (d += this._time - o, r += this._time - o), f = d, w = this._start, v = this._ts, y = !v, u && (c || (o = this._zTime), (r || !s) && (this._zTime = r)), this._repeat) { if (S = this._yoyo, m = c + this._rDelay, this._repeat < -1 && r < 0) return this.totalTime(m * 100 + r, s, a); if (f = Ye(d % m), d === l ? (h = this._repeat, f = c) : (h = ~~(d / m), h && h === d / m && (f = c, h--), f > c && (f = c)), x = zr(this._tTime, m), !o && this._tTime && x !== h && this._tTime - x * m - this._dur <= 0 && (x = h), S && h & 1 && (f = c - f, P = 1), h !== x && !this._lock) { var A = S && x & 1, M = A === (S && h & 1); if (h < x && (A = !A), o = A ? 0 : d % c ? c : d, this._lock = 1, this.render(o || (P ? 0 : Ye(h * m)), s, !c)._lock = 0, this._tTime = d, !s && this.parent && Pt(this, "onRepeat"), this.vars.repeatRefresh && !P && (this.invalidate()._lock = 1), o && o !== this._time || y !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this; if (c = this._dur, l = this._tDur, M && (this._lock = 2, o = A ? c : -1e-4, this.render(o, !0), this.vars.repeatRefresh && !P && this.invalidate()), this._lock = 0, !this._ts && !y) return this; _l(this, P) } } if (this._hasPause && !this._forcing && this._lock < 2 && (_ = qd(this, Ye(o), Ye(f)), _ && (d -= f - (f = _._start))), this._tTime = d, this._time = f, this._act = !v, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = r, o = 0), !o && f && !s && !h && (Pt(this, "onStart"), this._tTime !== d)) return this; if (f >= o && r >= 0) for (p = this._first; p;) { if (g = p._next, (p._act || f >= p._start) && p._ts && _ !== p) { if (p.parent !== this) return this.render(r, s, a); if (p.render(p._ts > 0 ? (f - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (f - p._start) * p._ts, s, a), f !== this._time || !this._ts && !y) { _ = 0, g && (d += this._zTime = -le); break } } p = g } else { p = this._last; for (var E = r < 0 ? r : f; p;) { if (g = p._prev, (p._act || E <= p._end) && p._ts && _ !== p) { if (p.parent !== this) return this.render(r, s, a); if (p.render(p._ts > 0 ? (E - p._start) * p._ts : (p._dirty ? p.totalDuration() : p._tDur) + (E - p._start) * p._ts, s, a || Qe && (p._initted || p._startAt)), f !== this._time || !this._ts && !y) { _ = 0, g && (d += this._zTime = E ? -le : le); break } } p = g } } if (_ && !s && (this.pause(), _.render(f >= o ? 0 : -le)._zTime = f >= o ? 1 : -1, this._ts)) return this._start = w, Sn(this), this.render(r, s, a); this._onUpdate && !s && Pt(this, "onUpdate", !0), (d === l && this._tTime >= this.totalDuration() || !d && o) && (w === this._start || Math.abs(v) !== Math.abs(this._ts)) && (this._lock || ((r || !c) && (d === l && this._ts > 0 || !d && this._ts < 0) && ki(this, 1), !s && !(r < 0 && !o) && (d || o || !l) && (Pt(this, d === l && r >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(d < l && this.timeScale() > 0) && this._prom()))) } return this }, t.add = function (r, s) { var a = this; if (mi(s) || (s = Ot(this, s, r)), !(r instanceof xs)) { if (Je(r)) return r.forEach(function (o) { return a.add(o, s) }), this; if (He(r)) return this.addLabel(r, s); if (_e(r)) r = Me.delayedCall(0, r); else return this } return this !== r ? ti(this, r, s) : this }, t.getChildren = function (r, s, a, o) { r === void 0 && (r = !0), s === void 0 && (s = !0), a === void 0 && (a = !0), o === void 0 && (o = -$t); for (var l = [], c = this._first; c;)c._start >= o && (c instanceof Me ? s && l.push(c) : (a && l.push(c), r && l.push.apply(l, c.getChildren(!0, s, a)))), c = c._next; return l }, t.getById = function (r) { for (var s = this.getChildren(1, 1, 1), a = s.length; a--;)if (s[a].vars.id === r) return s[a] }, t.remove = function (r) { return He(r) ? this.removeLabel(r) : _e(r) ? this.killTweensOf(r) : (xn(this, r), r === this._recent && (this._recent = this._last), er(this)) }, t.totalTime = function (r, s) { return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Ye(Mt.time - (this._ts > 0 ? r / this._ts : (this.totalDuration() - r) / -this._ts))), n.prototype.totalTime.call(this, r, s), this._forcing = 0, this) : this._tTime }, t.addLabel = function (r, s) { return this.labels[r] = Ot(this, s), this }, t.removeLabel = function (r) { return delete this.labels[r], this }, t.addPause = function (r, s, a) { var o = Me.delayedCall(0, s || ys, a); return o.data = "isPause", this._hasPause = 1, ti(this, o, Ot(this, r)) }, t.removePause = function (r) { var s = this._first; for (r = Ot(this, r); s;)s._start === r && s.data === "isPause" && ki(s), s = s._next }, t.killTweensOf = function (r, s, a) { for (var o = this.getTweensOf(r, a), l = o.length; l--;)xi !== o[l] && o[l].kill(r, s); return this }, t.getTweensOf = function (r, s) { for (var a = [], o = Bt(r), l = this._first, c = mi(s), d; l;)l instanceof Me ? Id(l._targets, o) && (c ? (!xi || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && a.push(l) : (d = l.getTweensOf(o, s)).length && a.push.apply(a, d), l = l._next; return a }, t.tweenTo = function (r, s) { s = s || {}; var a = this, o = Ot(a, r), l = s, c = l.startAt, d = l.onStart, u = l.onStartParams, f = l.immediateRender, p, g = Me.to(a, Nt({ ease: s.ease || "none", lazy: !1, immediateRender: !1, time: o, overwrite: "auto", duration: s.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale()) || le, onStart: function () { if (a.pause(), !p) { var m = s.duration || Math.abs((o - (c && "time" in c ? c.time : a._time)) / a.timeScale()); g._dur !== m && Rr(g, m, 0, 1).render(g._time, !0, !0), p = 1 } d && d.apply(g, u || []) } }, s)); return f ? g.render(0) : g }, t.tweenFromTo = function (r, s, a) { return this.tweenTo(s, Nt({ startAt: { time: Ot(this, r) } }, a)) }, t.recent = function () { return this._recent }, t.nextLabel = function (r) { return r === void 0 && (r = this._time), ro(this, Ot(this, r)) }, t.previousLabel = function (r) { return r === void 0 && (r = this._time), ro(this, Ot(this, r), 1) }, t.currentLabel = function (r) { return arguments.length ? this.seek(r, !0) : this.previousLabel(this._time + le) }, t.shiftChildren = function (r, s, a) { a === void 0 && (a = 0); for (var o = this._first, l = this.labels, c; o;)o._start >= a && (o._start += r, o._end += r), o = o._next; if (s) for (c in l) l[c] >= a && (l[c] += r); return er(this) }, t.invalidate = function (r) { var s = this._first; for (this._lock = 0; s;)s.invalidate(r), s = s._next; return n.prototype.invalidate.call(this, r) }, t.clear = function (r) { r === void 0 && (r = !0); for (var s = this._first, a; s;)a = s._next, this.remove(s), s = a; return this._dp && (this._time = this._tTime = this._pTime = 0), r && (this.labels = {}), er(this) }, t.totalDuration = function (r) { var s = 0, a = this, o = a._last, l = $t, c, d, u; if (arguments.length) return a.timeScale((a._repeat < 0 ? a.duration() : a.totalDuration()) / (a.reversed() ? -r : r)); if (a._dirty) { for (u = a.parent; o;)c = o._prev, o._dirty && o.totalDuration(), d = o._start, d > l && a._sort && o._ts && !a._lock ? (a._lock = 1, ti(a, o, d - o._delay, 1)._lock = 0) : l = d, d < 0 && o._ts && (s -= d, (!u && !a._dp || u && u.smoothChildTiming) && (a._start += d / a._ts, a._time -= d, a._tTime -= d), a.shiftChildren(-d, !1, -1 / 0), l = 0), o._end > s && o._ts && (s = o._end), o = c; Rr(a, a === me && a._time > s ? a._time : s, 1, 1), a._dirty = 0 } return a._tDur }, e.updateRoot = function (r) { if (me._ts && (Qo(me, ln(r, me)), Ko = Mt.frame), Mt.frame >= Ja) { Ja += At.autoSleep || 120; var s = me._first; if ((!s || !s._ts) && At.autoSleep && Mt._listeners.length < 2) { for (; s && !s._ts;)s = s._next; s || Mt.sleep() } } }, e }(xs); Nt(dt.prototype, { _lock: 0, _hasPause: 0, _forcing: 0 }); var rc = function (e, t, i, r, s, a, o) { var l = new _t(this._pt, e, t, 0, 1, Ml, null, s), c = 0, d = 0, u, f, p, g, h, m, y, _; for (l.b = i, l.e = r, i += "", r += "", (y = ~r.indexOf("random(")) && (r = ws(r)), a && (_ = [i, r], a(_, e, t), i = _[0], r = _[1]), f = i.match(Ln) || []; u = Ln.exec(r);)g = u[0], h = r.substring(c, u.index), p ? p = (p + 1) % 5 : h.substr(-5) === "rgba(" && (p = 1), g !== f[d++] && (m = parseFloat(f[d - 1]) || 0, l._pt = { _next: l._pt, p: h || d === 1 ? h : ",", s: m, c: g.charAt(1) === "=" ? Pr(m, g) - m : parseFloat(g) - m, m: p && p < 4 ? Math.round : 0 }, c = Ln.lastIndex); return l.c = c < r.length ? r.substring(c, r.length) : "", l.fp = o, (Go.test(r) || y) && (l.e = 0), this._pt = l, l }, Da = function (e, t, i, r, s, a, o, l, c, d) { _e(r) && (r = r(s || 0, e, a)); var u = e[t], f = i !== "get" ? i : _e(u) ? c ? e[t.indexOf("set") || !_e(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : u, p = _e(u) ? c ? lc : Tl : za, g; if (He(r) && (~r.indexOf("random(") && (r = ws(r)), r.charAt(1) === "=" && (g = Pr(f, r) + (Ze(f) || 0), (g || g === 0) && (r = g))), !d || f !== r || aa) return !isNaN(f * r) && r !== "" ? (g = new _t(this._pt, e, t, +f || 0, r - (f || 0), typeof u == "boolean" ? cc : El, 0, p), c && (g.fp = c), o && g.modifier(o, this, e), this._pt = g) : (!u && !(t in e) && La(t, r), rc.call(this, e, t, f, r, p, l || At.stringFilter, c)) }, sc = function (e, t, i, r, s) { if (_e(e) && (e = as(e, s, t, i, r)), !ai(e) || e.style && e.nodeType || Je(e) || Ho(e)) return He(e) ? as(e, s, t, i, r) : e; var a = {}, o; for (o in e) a[o] = as(e[o], s, t, i, r); return a }, bl = function (e, t, i, r, s, a) { var o, l, c, d; if (Tt[e] && (o = new Tt[e]).init(s, o.rawVars ? t[e] : sc(t[e], r, s, a, i), i, r, a) !== !1 && (i._pt = l = new _t(i._pt, s, e, 0, 1, o.render, o, 0, o.priority), i !== Er)) for (c = i._ptLookup[i._targets.indexOf(s)], d = o._props.length; d--;)c[o._props[d]] = l; return o }, xi, aa, Ia = function n(e, t, i) { var r = e.vars, s = r.ease, a = r.startAt, o = r.immediateRender, l = r.lazy, c = r.onUpdate, d = r.runBackwards, u = r.yoyoEase, f = r.keyframes, p = r.autoRevert, g = e._dur, h = e._startAt, m = e._targets, y = e.parent, _ = y && y.data === "nested" ? y.vars.targets : m, v = e._overwrite === "auto" && !Ea, w = e.timeline, x, S, P, A, M, E, O, C, k, b, L, z, D; if (w && (!f || !s) && (s = "none"), e._ease = tr(s, Ir.ease), e._yEase = u ? vl(tr(u === !0 ? s : u, Ir.ease)) : 0, u && e._yoyo && !e._repeat && (u = e._yEase, e._yEase = e._ease, e._ease = u), e._from = !w && !!r.runBackwards, !w || f && !r.stagger) { if (C = m[0] ? Ji(m[0]).harness : 0, z = C && r[C.prop], x = on(r, Aa), h && (h._zTime < 0 && h.progress(1), t < 0 && d && o && !p ? h.render(-1, !0) : h.revert(d && g ? Xs : Od), h._lazy = 0), a) { if (ki(e._startAt = Me.set(m, Nt({ data: "isStart", overwrite: !1, parent: y, immediateRender: !0, lazy: !h && gt(l), startAt: null, delay: 0, onUpdate: c && function () { return Pt(e, "onUpdate") }, stagger: 0 }, a))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Qe || !o && !p) && e._startAt.revert(Xs), o && g && t <= 0 && i <= 0) { t && (e._zTime = t); return } } else if (d && g && !h) { if (t && (o = !1), P = Nt({ overwrite: !1, data: "isFromStart", lazy: o && !h && gt(l), immediateRender: o, stagger: 0, parent: y }, x), z && (P[C.prop] = z), ki(e._startAt = Me.set(m, P)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (Qe ? e._startAt.revert(Xs) : e._startAt.render(-1, !0)), e._zTime = t, !o) n(e._startAt, le, le); else if (!t) return } for (e._pt = e._ptCache = 0, l = g && gt(l) || l && !g, S = 0; S < m.length; S++) { if (M = m[S], O = M._gsap || Oa(m)[S]._gsap, e._ptLookup[S] = b = {}, ea[O.id] && Pi.length && an(), L = _ === m ? S : _.indexOf(M), C && (k = new C).init(M, z || x, e, L, _) !== !1 && (e._pt = A = new _t(e._pt, M, k.name, 0, 1, k.render, k, 0, k.priority), k._props.forEach(function (I) { b[I] = A }), k.priority && (E = 1)), !C || z) for (P in x) Tt[P] && (k = bl(P, x, e, L, M, _)) ? k.priority && (E = 1) : b[P] = A = Da.call(e, M, P, "get", x[P], L, _, 0, r.stringFilter); e._op && e._op[S] && e.kill(M, e._op[S]), v && e._pt && (xi = e, me.killTweensOf(M, b, e.globalTime(t)), D = !e.parent, xi = 0), e._pt && l && (ea[O.id] = 1) } E && Cl(e), e._onInit && e._onInit(e) } e._onUpdate = c, e._initted = (!e._op || e._pt) && !D, f && t <= 0 && w.render($t, !0, !0) }, nc = function (e, t, i, r, s, a, o, l) { var c = (e._pt && e._ptCache || (e._ptCache = {}))[t], d, u, f, p; if (!c) for (c = e._ptCache[t] = [], f = e._ptLookup, p = e._targets.length; p--;) { if (d = f[p][t], d && d.d && d.d._pt) for (d = d.d._pt; d && d.p !== t && d.fp !== t;)d = d._next; if (!d) return aa = 1, e.vars[t] = "+=0", Ia(e, o), aa = 0, l ? _s(t + " not eligible for reset") : 1; c.push(d) } for (p = c.length; p--;)u = c[p], d = u._pt || u, d.s = (r || r === 0) && !s ? r : d.s + (r || 0) + a * d.c, d.c = i - d.s, u.e && (u.e = xe(i) + Ze(u.e)), u.b && (u.b = d.s + Ze(u.b)) }, ac = function (e, t) { var i = e[0] ? Ji(e[0]).harness : 0, r = i && i.aliases, s, a, o, l; if (!r) return t; s = lr({}, t); for (a in r) if (a in s) for (l = r[a].split(","), o = l.length; o--;)s[l[o]] = s[a]; return s }, oc = function (e, t, i, r) { var s = t.ease || r || "power1.inOut", a, o; if (Je(t)) o = i[e] || (i[e] = []), t.forEach(function (l, c) { return o.push({ t: c / (t.length - 1) * 100, v: l, e: s }) }); else for (a in t) o = i[a] || (i[a] = []), a === "ease" || o.push({ t: parseFloat(e), v: t[a], e: s }) }, as = function (e, t, i, r, s) { return _e(e) ? e.call(t, i, r, s) : He(e) && ~e.indexOf("random(") ? ws(e) : e }, xl = ka + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert", Sl = {}; vt(xl + ",id,stagger,delay,duration,paused,scrollTrigger", function (n) { return Sl[n] = 1 }); var Me = function (n) { qo(e, n); function e(i, r, s, a) { var o; typeof r == "number" && (s.duration = r, r = s, s = null), o = n.call(this, a ? r : ss(r)) || this; var l = o.vars, c = l.duration, d = l.delay, u = l.immediateRender, f = l.stagger, p = l.overwrite, g = l.keyframes, h = l.defaults, m = l.scrollTrigger, y = l.yoyoEase, _ = r.parent || me, v = (Je(i) || Ho(i) ? mi(i[0]) : "length" in r) ? [i] : Bt(i), w, x, S, P, A, M, E, O; if (o._targets = v.length ? Oa(v) : _s("GSAP target " + i + " not found. https://gsap.com", !At.nullTargetWarn) || [], o._ptLookup = [], o._overwrite = p, g || f || Os(c) || Os(d)) { if (r = o.vars, w = o.timeline = new dt({ data: "nested", defaults: h || {}, targets: _ && _.data === "nested" ? _.vars.targets : v }), w.kill(), w.parent = w._dp = di(o), w._start = 0, f || Os(c) || Os(d)) { if (P = v.length, E = f && ol(f), ai(f)) for (A in f) ~xl.indexOf(A) && (O || (O = {}), O[A] = f[A]); for (x = 0; x < P; x++)S = on(r, Sl), S.stagger = 0, y && (S.yoyoEase = y), O && lr(S, O), M = v[x], S.duration = +as(c, di(o), x, M, v), S.delay = (+as(d, di(o), x, M, v) || 0) - o._delay, !f && P === 1 && S.delay && (o._delay = d = S.delay, o._start += d, S.delay = 0), w.to(M, S, E ? E(x, M, v) : 0), w._ease = J.none; w.duration() ? c = d = 0 : o.timeline = 0 } else if (g) { ss(Nt(w.vars.defaults, { ease: "none" })), w._ease = tr(g.ease || r.ease || "none"); var C = 0, k, b, L; if (Je(g)) g.forEach(function (z) { return w.to(v, z, ">") }), w.duration(); else { S = {}; for (A in g) A === "ease" || A === "easeEach" || oc(A, g[A], S, g.easeEach); for (A in S) for (k = S[A].sort(function (z, D) { return z.t - D.t }), C = 0, x = 0; x < k.length; x++)b = k[x], L = { ease: b.e, duration: (b.t - (x ? k[x - 1].t : 0)) / 100 * c }, L[A] = b.v, w.to(v, L, C), C += L.duration; w.duration() < c && w.to({}, { duration: c - w.duration() }) } } c || o.duration(c = w.duration()) } else o.timeline = 0; return p === !0 && !Ea && (xi = di(o), me.killTweensOf(v), xi = 0), ti(_, di(o), s), r.reversed && o.reverse(), r.paused && o.paused(!0), (u || !c && !g && o._start === Ye(_._time) && gt(u) && Bd(di(o)) && _.data !== "nested") && (o._tTime = -le, o.render(Math.max(0, -d) || 0)), m && rl(di(o), m), o } var t = e.prototype; return t.render = function (r, s, a) { var o = this._time, l = this._tDur, c = this._dur, d = r < 0, u = r > l - le && !d ? l : r < le ? 0 : r, f, p, g, h, m, y, _, v, w; if (!c) Nd(this, r, s, a); else if (u !== this._tTime || !r || a || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== d) { if (f = u, v = this.timeline, this._repeat) { if (h = c + this._rDelay, this._repeat < -1 && d) return this.totalTime(h * 100 + r, s, a); if (f = Ye(u % h), u === l ? (g = this._repeat, f = c) : (g = ~~(u / h), g && g === Ye(u / h) && (f = c, g--), f > c && (f = c)), y = this._yoyo && g & 1, y && (w = this._yEase, f = c - f), m = zr(this._tTime, h), f === o && !a && this._initted && g === m) return this._tTime = u, this; g !== m && (v && this._yEase && _l(v, y), this.vars.repeatRefresh && !y && !this._lock && this._time !== c && this._initted && (this._lock = a = 1, this.render(Ye(h * g), !0).invalidate()._lock = 0)) } if (!this._initted) { if (sl(this, d ? r : f, a, s, u)) return this._tTime = 0, this; if (o !== this._time && !(a && this.vars.repeatRefresh && g !== m)) return this; if (c !== this._dur) return this.render(r, s, a) } if (this._tTime = u, this._time = f, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = _ = (w || this._ease)(f / c), this._from && (this.ratio = _ = 1 - _), f && !o && !s && !g && (Pt(this, "onStart"), this._tTime !== u)) return this; for (p = this._pt; p;)p.r(_, p.d), p = p._next; v && v.render(r < 0 ? r : !f && y ? -le : v._dur * v._ease(f / this._dur), s, a) || this._startAt && (this._zTime = r), this._onUpdate && !s && (d && ta(this, r, s, a), Pt(this, "onUpdate")), this._repeat && g !== m && this.vars.onRepeat && !s && this.parent && Pt(this, "onRepeat"), (u === this._tDur || !u) && this._tTime === u && (d && !this._onUpdate && ta(this, r, !0, !0), (r || !c) && (u === this._tDur && this._ts > 0 || !u && this._ts < 0) && ki(this, 1), !s && !(d && !o) && (u || o || y) && (Pt(this, u === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom())) } return this }, t.targets = function () { return this._targets }, t.invalidate = function (r) { return (!r || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(r), n.prototype.invalidate.call(this, r) }, t.resetTo = function (r, s, a, o, l) { bs || Mt.wake(), this._ts || this.play(); var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts), d; return this._initted || Ia(this, c), d = this._ease(c / this._dur), nc(this, r, s, a, o, d, c, l) ? this.resetTo(r, s, a, o, 1) : (Tn(this, 0), this.parent || tl(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0)) }, t.kill = function (r, s) { if (s === void 0 && (s = "all"), !r && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? Ur(this) : this; if (this.timeline) { var a = this.timeline.totalDuration(); return this.timeline.killTweensOf(r, s, xi && xi.vars.overwrite !== !0)._first || Ur(this), this.parent && a !== this.timeline.totalDuration() && Rr(this, this._dur * this.timeline._tDur / a, 0, 1), this } var o = this._targets, l = r ? Bt(r) : o, c = this._ptLookup, d = this._pt, u, f, p, g, h, m, y; if ((!s || s === "all") && Rd(o, l)) return s === "all" && (this._pt = 0), Ur(this); for (u = this._op = this._op || [], s !== "all" && (He(s) && (h = {}, vt(s, function (_) { return h[_] = 1 }), s = h), s = ac(o, s)), y = o.length; y--;)if (~l.indexOf(o[y])) { f = c[y], s === "all" ? (u[y] = s, g = f, p = {}) : (p = u[y] = u[y] || {}, g = s); for (h in g) m = f && f[h], m && ((!("kill" in m.d) || m.d.kill(h) === !0) && xn(this, m, "_pt"), delete f[h]), p !== "all" && (p[h] = 1) } return this._initted && !this._pt && d && Ur(this), this }, e.to = function (r, s) { return new e(r, s, arguments[2]) }, e.from = function (r, s) { return ns(1, arguments) }, e.delayedCall = function (r, s, a, o) { return new e(s, 0, { immediateRender: !1, lazy: !1, overwrite: !1, delay: r, onComplete: s, onReverseComplete: s, onCompleteParams: a, onReverseCompleteParams: a, callbackScope: o }) }, e.fromTo = function (r, s, a) { return ns(2, arguments) }, e.set = function (r, s) { return s.duration = 0, s.repeatDelay || (s.repeat = 0), new e(r, s) }, e.killTweensOf = function (r, s, a) { return me.killTweensOf(r, s, a) }, e }(xs); Nt(Me.prototype, { _targets: [], _lazy: 0, _startAt: 0, _op: 0, _onInit: 0 }); vt("staggerTo,staggerFrom,staggerFromTo", function (n) { Me[n] = function () { var e = new dt, t = ra.call(arguments, 0); return t.splice(n === "staggerFromTo" ? 5 : 4, 0, 0), e[n].apply(e, t) } }); var za = function (e, t, i) { return e[t] = i }, Tl = function (e, t, i) { return e[t](i) }, lc = function (e, t, i, r) { return e[t](r.fp, i) }, dc = function (e, t, i) { return e.setAttribute(t, i) }, Ra = function (e, t) { return _e(e[t]) ? Tl : Ma(e[t]) && e.setAttribute ? dc : za }, El = function (e, t) { return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t) }, cc = function (e, t) { return t.set(t.t, t.p, !!(t.s + t.c * e), t) }, Ml = function (e, t) { var i = t._pt, r = ""; if (!e && t.b) r = t.b; else if (e === 1 && t.e) r = t.e; else { for (; i;)r = i.p + (i.m ? i.m(i.s + i.c * e) : Math.round((i.s + i.c * e) * 1e4) / 1e4) + r, i = i._next; r += t.c } t.set(t.t, t.p, r, t) }, $a = function (e, t) { for (var i = t._pt; i;)i.r(e, i.d), i = i._next }, uc = function (e, t, i, r) { for (var s = this._pt, a; s;)a = s._next, s.p === r && s.modifier(e, t, i), s = a }, fc = function (e) { for (var t = this._pt, i, r; t;)r = t._next, t.p === e && !t.op || t.op === e ? xn(this, t, "_pt") : t.dep || (i = 1), t = r; return !i }, pc = function (e, t, i, r) { r.mSet(e, t, r.m.call(r.tween, i, r.mt), r) }, Cl = function (e) { for (var t = e._pt, i, r, s, a; t;) { for (i = t._next, r = s; r && r.pr > t.pr;)r = r._next; (t._prev = r ? r._prev : a) ? t._prev._next = t : s = t, (t._next = r) ? r._prev = t : a = t, t = i } e._pt = s }, _t = function () { function n(t, i, r, s, a, o, l, c, d) { this.t = i, this.s = s, this.c = a, this.p = r, this.r = o || El, this.d = l || this, this.set = c || za, this.pr = d || 0, this._next = t, t && (t._prev = this) } var e = n.prototype; return e.modifier = function (i, r, s) { this.mSet = this.mSet || this.set, this.set = pc, this.m = i, this.mt = s, this.tween = r }, n }(); vt(ka + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function (n) { return Aa[n] = 1 }); kt.TweenMax = kt.TweenLite = Me; kt.TimelineLite = kt.TimelineMax = dt; me = new dt({ sortChildren: !1, defaults: Ir, autoRemoveChildren: !0, id: "root", smoothChildTiming: !0 }); At.stringFilter = gl; var ir = [], js = {}, hc = [], no = 0, mc = 0, In = function (e) { return (js[e] || hc).map(function (t) { return t() }) }, oa = function () { var e = Date.now(), t = []; e - no > 2 && (In("matchMediaInit"), ir.forEach(function (i) { var r = i.queries, s = i.conditions, a, o, l, c; for (o in r) a = Dt.matchMedia(r[o]).matches, a && (l = 1), a !== s[o] && (s[o] = a, c = 1); c && (i.revert(), l && t.push(i)) }), In("matchMediaRevert"), t.forEach(function (i) { return i.onMatch(i, function (r) { return i.add(null, r) }) }), no = e, In("matchMedia")) }, Pl = function () { function n(t, i) { this.selector = i && sa(i), this.data = [], this._r = [], this.isReverted = !1, this.id = mc++, t && this.add(t) } var e = n.prototype; return e.add = function (i, r, s) { _e(i) && (s = r, r = i, i = _e); var a = this, o = function () { var c = ve, d = a.selector, u; return c && c !== a && c.data.push(a), s && (a.selector = sa(s)), ve = a, u = r.apply(a, arguments), _e(u) && a._r.push(u), ve = c, a.selector = d, a.isReverted = !1, u }; return a.last = o, i === _e ? o(a, function (l) { return a.add(null, l) }) : i ? a[i] = o : o }, e.ignore = function (i) { var r = ve; ve = null, i(this), ve = r }, e.getTweens = function () { var i = []; return this.data.forEach(function (r) { return r instanceof n ? i.push.apply(i, r.getTweens()) : r instanceof Me && !(r.parent && r.parent.data === "nested") && i.push(r) }), i }, e.clear = function () { this._r.length = this.data.length = 0 }, e.kill = function (i, r) { var s = this; if (i ? function () { for (var o = s.getTweens(), l = s.data.length, c; l--;)c = s.data[l], c.data === "isFlip" && (c.revert(), c.getChildren(!0, !0, !1).forEach(function (d) { return o.splice(o.indexOf(d), 1) })); for (o.map(function (d) { return { g: d._dur || d._delay || d._sat && !d._sat.vars.immediateRender ? d.globalTime(0) : -1 / 0, t: d } }).sort(function (d, u) { return u.g - d.g || -1 / 0 }).forEach(function (d) { return d.t.revert(i) }), l = s.data.length; l--;)c = s.data[l], c instanceof dt ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof Me) && c.revert && c.revert(i); s._r.forEach(function (d) { return d(i, s) }), s.isReverted = !0 }() : this.data.forEach(function (o) { return o.kill && o.kill() }), this.clear(), r) for (var a = ir.length; a--;)ir[a].id === this.id && ir.splice(a, 1) }, e.revert = function (i) { this.kill(i || {}) }, n }(), gc = function () { function n(t) { this.contexts = [], this.scope = t } var e = n.prototype; return e.add = function (i, r, s) { ai(i) || (i = { matches: i }); var a = new Pl(0, s || this.scope), o = a.conditions = {}, l, c, d; ve && !a.selector && (a.selector = ve.selector), this.contexts.push(a), r = a.add("onMatch", r), a.queries = i; for (c in i) c === "all" ? d = 1 : (l = Dt.matchMedia(i[c]), l && (ir.indexOf(a) < 0 && ir.push(a), (o[c] = l.matches) && (d = 1), l.addListener ? l.addListener(oa) : l.addEventListener("change", oa))); return d && r(a, function (u) { return a.add(null, u) }), this }, e.revert = function (i) { this.kill(i || {}) }, e.kill = function (i) { this.contexts.forEach(function (r) { return r.kill(i, !0) }) }, n }(), dn = { registerPlugin: function () { for (var e = arguments.length, t = new Array(e), i = 0; i < e; i++)t[i] = arguments[i]; t.forEach(function (r) { return pl(r) }) }, timeline: function (e) { return new dt(e) }, getTweensOf: function (e, t) { return me.getTweensOf(e, t) }, getProperty: function (e, t, i, r) { He(e) && (e = Bt(e)[0]); var s = Ji(e || {}).get, a = i ? el : Jo; return i === "native" && (i = ""), e && (t ? a((Tt[t] && Tt[t].get || s)(e, t, i, r)) : function (o, l, c) { return a((Tt[o] && Tt[o].get || s)(e, o, l, c)) }) }, quickSetter: function (e, t, i) { if (e = Bt(e), e.length > 1) { var r = e.map(function (d) { return wt.quickSetter(d, t, i) }), s = r.length; return function (d) { for (var u = s; u--;)r[u](d) } } e = e[0] || {}; var a = Tt[t], o = Ji(e), l = o.harness && (o.harness.aliases || {})[t] || t, c = a ? function (d) { var u = new a; Er._pt = 0, u.init(e, i ? d + i : d, Er, 0, [e]), u.render(1, u), Er._pt && $a(1, Er) } : o.set(e, l); return a ? c : function (d) { return c(e, l, i ? d + i : d, o, 1) } }, quickTo: function (e, t, i) { var r, s = wt.to(e, lr((r = {}, r[t] = "+=0.1", r.paused = !0, r), i || {})), a = function (l, c, d) { return s.resetTo(t, l, c, d) }; return a.tween = s, a }, isTweening: function (e) { return me.getTweensOf(e, !0).length > 0 }, defaults: function (e) { return e && e.ease && (e.ease = tr(e.ease, Ir.ease)), eo(Ir, e || {}) }, config: function (e) { return eo(At, e || {}) }, registerEffect: function (e) { var t = e.name, i = e.effect, r = e.plugins, s = e.defaults, a = e.extendTimeline; (r || "").split(",").forEach(function (o) { return o && !Tt[o] && !kt[o] && _s(t + " effect requires " + o + " plugin.") }), An[t] = function (o, l, c) { return i(Bt(o), Nt(l || {}, s), c) }, a && (dt.prototype[t] = function (o, l, c) { return this.add(An[t](o, ai(l) ? l : (c = l) && {}, this), c) }) }, registerEase: function (e, t) { J[e] = tr(t) }, parseEase: function (e, t) { return arguments.length ? tr(e, t) : J }, getById: function (e) { return me.getById(e) }, exportRoot: function (e, t) { e === void 0 && (e = {}); var i = new dt(e), r, s; for (i.smoothChildTiming = gt(e.smoothChildTiming), me.remove(i), i._dp = 0, i._time = i._tTime = me._time, r = me._first; r;)s = r._next, (t || !(!r._dur && r instanceof Me && r.vars.onComplete === r._targets[0])) && ti(i, r, r._start - r._delay), r = s; return ti(me, i, 0), i }, context: function (e, t) { return e ? new Pl(e, t) : ve }, matchMedia: function (e) { return new gc(e) }, matchMediaRefresh: function () { return ir.forEach(function (e) { var t = e.conditions, i, r; for (r in t) t[r] && (t[r] = !1, i = 1); i && e.revert() }) || oa() }, addEventListener: function (e, t) { var i = js[e] || (js[e] = []); ~i.indexOf(t) || i.push(t) }, removeEventListener: function (e, t) { var i = js[e], r = i && i.indexOf(t); r >= 0 && i.splice(r, 1) }, utils: { wrap: jd, wrapYoyo: Ud, distribute: ol, random: dl, snap: ll, normalize: Wd, getUnit: Ze, clamp: Hd, splitColor: hl, toArray: Bt, selector: sa, mapRange: ul, pipe: Gd, unitize: Xd, interpolate: Kd, shuffle: al }, install: jo, effects: An, ticker: Mt, updateRoot: dt.updateRoot, plugins: Tt, globalTimeline: me, core: { PropTween: _t, globals: Uo, Tween: Me, Timeline: dt, Animation: xs, getCache: Ji, _removeLinkedListItem: xn, reverting: function () { return Qe }, context: function (e) { return e && ve && (ve.data.push(e), e._ctx = ve), ve }, suppressOverwrites: function (e) { return Ea = e } } }; vt("to,from,fromTo,delayedCall,set,killTweensOf", function (n) { return dn[n] = Me[n] }); Mt.add(dt.updateRoot); Er = dn.to({}, { duration: 0 }); var vc = function (e, t) { for (var i = e._pt; i && i.p !== t && i.op !== t && i.fp !== t;)i = i._next; return i }, _c = function (e, t) { var i = e._targets, r, s, a; for (r in t) for (s = i.length; s--;)a = e._ptLookup[s][r], a && (a = a.d) && (a._pt && (a = vc(a, r)), a && a.modifier && a.modifier(t[r], e, i[s], r)) }, zn = function (e, t) { return { name: e, rawVars: 1, init: function (r, s, a) { a._onInit = function (o) { var l, c; if (He(s) && (l = {}, vt(s, function (d) { return l[d] = 1 }), s = l), t) { l = {}; for (c in s) l[c] = t(s[c]); s = l } _c(o, s) } } } }, wt = dn.registerPlugin({ name: "attr", init: function (e, t, i, r, s) { var a, o, l; this.tween = i; for (a in t) l = e.getAttribute(a) || "", o = this.add(e, "setAttribute", (l || 0) + "", t[a], r, s, 0, 0, a), o.op = a, o.b = l, this._props.push(a) }, render: function (e, t) { for (var i = t._pt; i;)Qe ? i.set(i.t, i.p, i.b, i) : i.r(e, i.d), i = i._next } }, { name: "endArray", init: function (e, t) { for (var i = t.length; i--;)this.add(e, i, e[i] || 0, t[i], 0, 0, 0, 0, 0, 1) } }, zn("roundProps", na), zn("modifiers"), zn("snap", ll)) || dn; Me.version = dt.version = wt.version = "3.12.4"; Wo = 1; Ca() && $r(); J.Power0; J.Power1; J.Power2; J.Power3; J.Power4; J.Linear; J.Quad; J.Cubic; J.Quart; J.Quint; J.Strong; J.Elastic; J.Back; J.SteppedEase; J.Bounce; J.Sine; J.Expo; J.Circ;/*!
 * CSSPlugin 3.12.4
 * https://gsap.com
 *
 * Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var ao, Si, Lr, Ba, Zi, oo, Fa, yc = function () { return typeof window < "u" }, gi = {}, Wi = 180 / Math.PI, Ar = Math.PI / 180, yr = Math.atan2, lo = 1e8, Na = /([A-Z])/g, wc = /(left|right|width|margin|padding|x)/i, bc = /[\s,\(]\S/, ii = { autoAlpha: "opacity,visibility", scale: "scaleX,scaleY", alpha: "opacity" }, la = function (e, t) { return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t) }, xc = function (e, t) { return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t) }, Sc = function (e, t) { return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t) }, Tc = function (e, t) { var i = t.s + t.c * e; t.set(t.t, t.p, ~~(i + (i < 0 ? -.5 : .5)) + t.u, t) }, Ll = function (e, t) { return t.set(t.t, t.p, e ? t.e : t.b, t) }, Al = function (e, t) { return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t) }, Ec = function (e, t, i) { return e.style[t] = i }, Mc = function (e, t, i) { return e.style.setProperty(t, i) }, Cc = function (e, t, i) { return e._gsap[t] = i }, Pc = function (e, t, i) { return e._gsap.scaleX = e._gsap.scaleY = i }, Lc = function (e, t, i, r, s) { var a = e._gsap; a.scaleX = a.scaleY = i, a.renderTransform(s, a) }, Ac = function (e, t, i, r, s) { var a = e._gsap; a[t] = i, a.renderTransform(s, a) }, ge = "transform", yt = ge + "Origin", kc = function n(e, t) { var i = this, r = this.target, s = r.style, a = r._gsap; if (e in gi && s) { if (this.tfm = this.tfm || {}, e !== "transform") e = ii[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function (o) { return i.tfm[o] = ci(r, o) }) : this.tfm[e] = a.x ? a[e] : ci(r, e), e === yt && (this.tfm.zOrigin = a.zOrigin); else return ii.transform.split(",").forEach(function (o) { return n.call(i, o, t) }); if (this.props.indexOf(ge) >= 0) return; a.svg && (this.svgo = r.getAttribute("data-svg-origin"), this.props.push(yt, t, "")), e = ge } (s || t) && this.props.push(e, t, s[e]) }, kl = function (e) { e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate")) }, Oc = function () { var e = this.props, t = this.target, i = t.style, r = t._gsap, s, a; for (s = 0; s < e.length; s += 3)e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? i[e[s]] = e[s + 2] : i.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(Na, "-$1").toLowerCase()); if (this.tfm) { for (a in this.tfm) r[a] = this.tfm[a]; r.svg && (r.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), s = Fa(), (!s || !s.isStart) && !i[ge] && (kl(i), r.zOrigin && i[yt] && (i[yt] += " " + r.zOrigin + "px", r.zOrigin = 0, r.renderTransform()), r.uncache = 1) } }, Ol = function (e, t) { var i = { target: e, props: [], revert: Oc, save: kc }; return e._gsap || wt.core.getCache(e), t && t.split(",").forEach(function (r) { return i.save(r) }), i }, Dl, da = function (e, t) { var i = Si.createElementNS ? Si.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : Si.createElement(e); return i && i.style ? i : Si.createElement(e) }, si = function n(e, t, i) { var r = getComputedStyle(e); return r[t] || r.getPropertyValue(t.replace(Na, "-$1").toLowerCase()) || r.getPropertyValue(t) || !i && n(e, Br(t) || t, 1) || "" }, co = "O,Moz,ms,Ms,Webkit".split(","), Br = function (e, t, i) { var r = t || Zi, s = r.style, a = 5; if (e in s && !i) return e; for (e = e.charAt(0).toUpperCase() + e.substr(1); a-- && !(co[a] + e in s);); return a < 0 ? null : (a === 3 ? "ms" : a >= 0 ? co[a] : "") + e }, ca = function () { yc() && window.document && (ao = window, Si = ao.document, Lr = Si.documentElement, Zi = da("div") || { style: {} }, da("div"), ge = Br(ge), yt = ge + "Origin", Zi.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", Dl = !!Br("perspective"), Fa = wt.core.reverting, Ba = 1) }, Rn = function n(e) { var t = da("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"), i = this.parentNode, r = this.nextSibling, s = this.style.cssText, a; if (Lr.appendChild(t), t.appendChild(this), this.style.display = "block", e) try { a = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = n } catch { } else this._gsapBBox && (a = this._gsapBBox()); return i && (r ? i.insertBefore(this, r) : i.appendChild(this)), Lr.removeChild(t), this.style.cssText = s, a }, uo = function (e, t) { for (var i = t.length; i--;)if (e.hasAttribute(t[i])) return e.getAttribute(t[i]) }, Il = function (e) { var t; try { t = e.getBBox() } catch { t = Rn.call(e, !0) } return t && (t.width || t.height) || e.getBBox === Rn || (t = Rn.call(e, !0)), t && !t.width && !t.x && !t.y ? { x: +uo(e, ["x", "cx", "x1"]) || 0, y: +uo(e, ["y", "cy", "y1"]) || 0, width: 0, height: 0 } : t }, zl = function (e) { return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && Il(e)) }, dr = function (e, t) { if (t) { var i = e.style, r; t in gi && t !== yt && (t = ge), i.removeProperty ? (r = t.substr(0, 2), (r === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), i.removeProperty(r === "--" ? t : t.replace(Na, "-$1").toLowerCase())) : i.removeAttribute(t) } }, Ti = function (e, t, i, r, s, a) { var o = new _t(e._pt, t, i, 0, 1, a ? Al : Ll); return e._pt = o, o.b = r, o.e = s, e._props.push(i), o }, fo = { deg: 1, rad: 1, turn: 1 }, Dc = { grid: 1, flex: 1 }, Oi = function n(e, t, i, r) { var s = parseFloat(i) || 0, a = (i + "").trim().substr((s + "").length) || "px", o = Zi.style, l = wc.test(t), c = e.tagName.toLowerCase() === "svg", d = (c ? "client" : "offset") + (l ? "Width" : "Height"), u = 100, f = r === "px", p = r === "%", g, h, m, y; if (r === a || !s || fo[r] || fo[a]) return s; if (a !== "px" && !f && (s = n(e, t, i, "px")), y = e.getCTM && zl(e), (p || a === "%") && (gi[t] || ~t.indexOf("adius"))) return g = y ? e.getBBox()[l ? "width" : "height"] : e[d], xe(p ? s / g * u : s / 100 * g); if (o[l ? "width" : "height"] = u + (f ? a : r), h = ~t.indexOf("adius") || r === "em" && e.appendChild && !c ? e : e.parentNode, y && (h = (e.ownerSVGElement || {}).parentNode), (!h || h === Si || !h.appendChild) && (h = Si.body), m = h._gsap, m && p && m.width && l && m.time === Mt.time && !m.uncache) return xe(s / m.width * u); if (p && (t === "height" || t === "width")) { var _ = e.style[t]; e.style[t] = u + r, g = e[d], _ ? e.style[t] = _ : dr(e, t) } else (p || a === "%") && !Dc[si(h, "display")] && (o.position = si(e, "position")), h === e && (o.position = "static"), h.appendChild(Zi), g = Zi[d], h.removeChild(Zi), o.position = "absolute"; return l && p && (m = Ji(h), m.time = Mt.time, m.width = h[d]), xe(f ? g * s / u : g && s ? u / g * s : 0) }, ci = function (e, t, i, r) { var s; return Ba || ca(), t in ii && t !== "transform" && (t = ii[t], ~t.indexOf(",") && (t = t.split(",")[0])), gi[t] && t !== "transform" ? (s = Ts(e, r), s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : un(si(e, yt)) + " " + s.zOrigin + "px") : (s = e.style[t], (!s || s === "auto" || r || ~(s + "").indexOf("calc(")) && (s = cn[t] && cn[t](e, t, i) || si(e, t) || Zo(e, t) || (t === "opacity" ? 1 : 0))), i && !~(s + "").trim().indexOf(" ") ? Oi(e, t, s, i) + i : s }, Ic = function (e, t, i, r) { if (!i || i === "none") { var s = Br(t, e, 1), a = s && si(e, s, 1); a && a !== i ? (t = s, i = a) : t === "borderColor" && (i = si(e, "borderTopColor")) } var o = new _t(this._pt, e.style, t, 0, 1, Ml), l = 0, c = 0, d, u, f, p, g, h, m, y, _, v, w, x; if (o.b = i, o.e = r, i += "", r += "", r === "auto" && (h = e.style[t], e.style[t] = r, r = si(e, t) || r, h ? e.style[t] = h : dr(e, t)), d = [i, r], gl(d), i = d[0], r = d[1], f = i.match(Tr) || [], x = r.match(Tr) || [], x.length) { for (; u = Tr.exec(r);)m = u[0], _ = r.substring(l, u.index), g ? g = (g + 1) % 5 : (_.substr(-5) === "rgba(" || _.substr(-5) === "hsla(") && (g = 1), m !== (h = f[c++] || "") && (p = parseFloat(h) || 0, w = h.substr((p + "").length), m.charAt(1) === "=" && (m = Pr(p, m) + w), y = parseFloat(m), v = m.substr((y + "").length), l = Tr.lastIndex - v.length, v || (v = v || At.units[t] || w, l === r.length && (r += v, o.e += v)), w !== v && (p = Oi(e, t, h, v) || 0), o._pt = { _next: o._pt, p: _ || c === 1 ? _ : ",", s: p, c: y - p, m: g && g < 4 || t === "zIndex" ? Math.round : 0 }); o.c = l < r.length ? r.substring(l, r.length) : "" } else o.r = t === "display" && r === "none" ? Al : Ll; return Go.test(r) && (o.e = 0), this._pt = o, o }, po = { top: "0%", bottom: "100%", left: "0%", right: "100%", center: "50%" }, zc = function (e) { var t = e.split(" "), i = t[0], r = t[1] || "50%"; return (i === "top" || i === "bottom" || r === "left" || r === "right") && (e = i, i = r, r = e), t[0] = po[i] || i, t[1] = po[r] || r, t.join(" ") }, Rc = function (e, t) { if (t.tween && t.tween._time === t.tween._dur) { var i = t.t, r = i.style, s = t.u, a = i._gsap, o, l, c; if (s === "all" || s === !0) r.cssText = "", l = 1; else for (s = s.split(","), c = s.length; --c > -1;)o = s[c], gi[o] && (l = 1, o = o === "transformOrigin" ? yt : ge), dr(i, o); l && (dr(i, ge), a && (a.svg && i.removeAttribute("transform"), Ts(i, 1), a.uncache = 1, kl(r))) } }, cn = { clearProps: function (e, t, i, r, s) { if (s.data !== "isFromStart") { var a = e._pt = new _t(e._pt, t, i, 0, 0, Rc); return a.u = r, a.pr = -10, a.tween = s, e._props.push(i), 1 } } }, Ss = [1, 0, 0, 1, 0, 0], Rl = {}, $l = function (e) { return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e }, ho = function (e) { var t = si(e, ge); return $l(t) ? Ss : t.substr(7).match(Vo).map(xe) }, qa = function (e, t) { var i = e._gsap || Ji(e), r = e.style, s = ho(e), a, o, l, c; return i.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, s = [l.a, l.b, l.c, l.d, l.e, l.f], s.join(",") === "1,0,0,1,0,0" ? Ss : s) : (s === Ss && !e.offsetParent && e !== Lr && !i.svg && (l = r.display, r.display = "block", a = e.parentNode, (!a || !e.offsetParent) && (c = 1, o = e.nextElementSibling, Lr.appendChild(e)), s = ho(e), l ? r.display = l : dr(e, "display"), c && (o ? a.insertBefore(e, o) : a ? a.appendChild(e) : Lr.removeChild(e))), t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s) }, ua = function (e, t, i, r, s, a) { var o = e._gsap, l = s || qa(e, !0), c = o.xOrigin || 0, d = o.yOrigin || 0, u = o.xOffset || 0, f = o.yOffset || 0, p = l[0], g = l[1], h = l[2], m = l[3], y = l[4], _ = l[5], v = t.split(" "), w = parseFloat(v[0]) || 0, x = parseFloat(v[1]) || 0, S, P, A, M; i ? l !== Ss && (P = p * m - g * h) && (A = w * (m / P) + x * (-h / P) + (h * _ - m * y) / P, M = w * (-g / P) + x * (p / P) - (p * _ - g * y) / P, w = A, x = M) : (S = Il(e), w = S.x + (~v[0].indexOf("%") ? w / 100 * S.width : w), x = S.y + (~(v[1] || v[0]).indexOf("%") ? x / 100 * S.height : x)), r || r !== !1 && o.smooth ? (y = w - c, _ = x - d, o.xOffset = u + (y * p + _ * h) - y, o.yOffset = f + (y * g + _ * m) - _) : o.xOffset = o.yOffset = 0, o.xOrigin = w, o.yOrigin = x, o.smooth = !!r, o.origin = t, o.originIsAbsolute = !!i, e.style[yt] = "0px 0px", a && (Ti(a, o, "xOrigin", c, w), Ti(a, o, "yOrigin", d, x), Ti(a, o, "xOffset", u, o.xOffset), Ti(a, o, "yOffset", f, o.yOffset)), e.setAttribute("data-svg-origin", w + " " + x) }, Ts = function (e, t) { var i = e._gsap || new wl(e); if ("x" in i && !t && !i.uncache) return i; var r = e.style, s = i.scaleX < 0, a = "px", o = "deg", l = getComputedStyle(e), c = si(e, yt) || "0", d, u, f, p, g, h, m, y, _, v, w, x, S, P, A, M, E, O, C, k, b, L, z, D, I, R, T, q, ie, N, Y, se; return d = u = f = h = m = y = _ = v = w = 0, p = g = 1, i.svg = !!(e.getCTM && zl(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (r[ge] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[ge] !== "none" ? l[ge] : "")), r.scale = r.rotate = r.translate = "none"), P = qa(e, i.svg), i.svg && (i.uncache ? (I = e.getBBox(), c = i.xOrigin - I.x + "px " + (i.yOrigin - I.y) + "px", D = "") : D = !t && e.getAttribute("data-svg-origin"), ua(e, D || c, !!D || i.originIsAbsolute, i.smooth !== !1, P)), x = i.xOrigin || 0, S = i.yOrigin || 0, P !== Ss && (O = P[0], C = P[1], k = P[2], b = P[3], d = L = P[4], u = z = P[5], P.length === 6 ? (p = Math.sqrt(O * O + C * C), g = Math.sqrt(b * b + k * k), h = O || C ? yr(C, O) * Wi : 0, _ = k || b ? yr(k, b) * Wi + h : 0, _ && (g *= Math.abs(Math.cos(_ * Ar))), i.svg && (d -= x - (x * O + S * k), u -= S - (x * C + S * b))) : (se = P[6], N = P[7], T = P[8], q = P[9], ie = P[10], Y = P[11], d = P[12], u = P[13], f = P[14], A = yr(se, ie), m = A * Wi, A && (M = Math.cos(-A), E = Math.sin(-A), D = L * M + T * E, I = z * M + q * E, R = se * M + ie * E, T = L * -E + T * M, q = z * -E + q * M, ie = se * -E + ie * M, Y = N * -E + Y * M, L = D, z = I, se = R), A = yr(-k, ie), y = A * Wi, A && (M = Math.cos(-A), E = Math.sin(-A), D = O * M - T * E, I = C * M - q * E, R = k * M - ie * E, Y = b * E + Y * M, O = D, C = I, k = R), A = yr(C, O), h = A * Wi, A && (M = Math.cos(A), E = Math.sin(A), D = O * M + C * E, I = L * M + z * E, C = C * M - O * E, z = z * M - L * E, O = D, L = I), m && Math.abs(m) + Math.abs(h) > 359.9 && (m = h = 0, y = 180 - y), p = xe(Math.sqrt(O * O + C * C + k * k)), g = xe(Math.sqrt(z * z + se * se)), A = yr(L, z), _ = Math.abs(A) > 2e-4 ? A * Wi : 0, w = Y ? 1 / (Y < 0 ? -Y : Y) : 0), i.svg && (D = e.getAttribute("transform"), i.forceCSS = e.setAttribute("transform", "") || !$l(si(e, ge)), D && e.setAttribute("transform", D))), Math.abs(_) > 90 && Math.abs(_) < 270 && (s ? (p *= -1, _ += h <= 0 ? 180 : -180, h += h <= 0 ? 180 : -180) : (g *= -1, _ += _ <= 0 ? 180 : -180)), t = t || i.uncache, i.x = d - ((i.xPercent = d && (!t && i.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-d) ? -50 : 0))) ? e.offsetWidth * i.xPercent / 100 : 0) + a, i.y = u - ((i.yPercent = u && (!t && i.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetHeight * i.yPercent / 100 : 0) + a, i.z = f + a, i.scaleX = xe(p), i.scaleY = xe(g), i.rotation = xe(h) + o, i.rotationX = xe(m) + o, i.rotationY = xe(y) + o, i.skewX = _ + o, i.skewY = v + o, i.transformPerspective = w + a, (i.zOrigin = parseFloat(c.split(" ")[2]) || !t && i.zOrigin || 0) && (r[yt] = un(c)), i.xOffset = i.yOffset = 0, i.force3D = At.force3D, i.renderTransform = i.svg ? Bc : Dl ? Bl : $c, i.uncache = 0, i }, un = function (e) { return (e = e.split(" "))[0] + " " + e[1] }, $n = function (e, t, i) { var r = Ze(t); return xe(parseFloat(t) + parseFloat(Oi(e, "x", i + "px", r))) + r }, $c = function (e, t) { t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, Bl(e, t) }, Gi = "0deg", Xr = "0px", Xi = ") ", Bl = function (e, t) { var i = t || this, r = i.xPercent, s = i.yPercent, a = i.x, o = i.y, l = i.z, c = i.rotation, d = i.rotationY, u = i.rotationX, f = i.skewX, p = i.skewY, g = i.scaleX, h = i.scaleY, m = i.transformPerspective, y = i.force3D, _ = i.target, v = i.zOrigin, w = "", x = y === "auto" && e && e !== 1 || y === !0; if (v && (u !== Gi || d !== Gi)) { var S = parseFloat(d) * Ar, P = Math.sin(S), A = Math.cos(S), M; S = parseFloat(u) * Ar, M = Math.cos(S), a = $n(_, a, P * M * -v), o = $n(_, o, -Math.sin(S) * -v), l = $n(_, l, A * M * -v + v) } m !== Xr && (w += "perspective(" + m + Xi), (r || s) && (w += "translate(" + r + "%, " + s + "%) "), (x || a !== Xr || o !== Xr || l !== Xr) && (w += l !== Xr || x ? "translate3d(" + a + ", " + o + ", " + l + ") " : "translate(" + a + ", " + o + Xi), c !== Gi && (w += "rotate(" + c + Xi), d !== Gi && (w += "rotateY(" + d + Xi), u !== Gi && (w += "rotateX(" + u + Xi), (f !== Gi || p !== Gi) && (w += "skew(" + f + ", " + p + Xi), (g !== 1 || h !== 1) && (w += "scale(" + g + ", " + h + Xi), _.style[ge] = w || "translate(0, 0)" }, Bc = function (e, t) { var i = t || this, r = i.xPercent, s = i.yPercent, a = i.x, o = i.y, l = i.rotation, c = i.skewX, d = i.skewY, u = i.scaleX, f = i.scaleY, p = i.target, g = i.xOrigin, h = i.yOrigin, m = i.xOffset, y = i.yOffset, _ = i.forceCSS, v = parseFloat(a), w = parseFloat(o), x, S, P, A, M; l = parseFloat(l), c = parseFloat(c), d = parseFloat(d), d && (d = parseFloat(d), c += d, l += d), l || c ? (l *= Ar, c *= Ar, x = Math.cos(l) * u, S = Math.sin(l) * u, P = Math.sin(l - c) * -f, A = Math.cos(l - c) * f, c && (d *= Ar, M = Math.tan(c - d), M = Math.sqrt(1 + M * M), P *= M, A *= M, d && (M = Math.tan(d), M = Math.sqrt(1 + M * M), x *= M, S *= M)), x = xe(x), S = xe(S), P = xe(P), A = xe(A)) : (x = u, A = f, S = P = 0), (v && !~(a + "").indexOf("px") || w && !~(o + "").indexOf("px")) && (v = Oi(p, "x", a, "px"), w = Oi(p, "y", o, "px")), (g || h || m || y) && (v = xe(v + g - (g * x + h * P) + m), w = xe(w + h - (g * S + h * A) + y)), (r || s) && (M = p.getBBox(), v = xe(v + r / 100 * M.width), w = xe(w + s / 100 * M.height)), M = "matrix(" + x + "," + S + "," + P + "," + A + "," + v + "," + w + ")", p.setAttribute("transform", M), _ && (p.style[ge] = M) }, Fc = function (e, t, i, r, s) { var a = 360, o = He(s), l = parseFloat(s) * (o && ~s.indexOf("rad") ? Wi : 1), c = l - r, d = r + c + "deg", u, f; return o && (u = s.split("_")[1], u === "short" && (c %= a, c !== c % (a / 2) && (c += c < 0 ? a : -a)), u === "cw" && c < 0 ? c = (c + a * lo) % a - ~~(c / a) * a : u === "ccw" && c > 0 && (c = (c - a * lo) % a - ~~(c / a) * a)), e._pt = f = new _t(e._pt, t, i, r, c, xc), f.e = d, f.u = "deg", e._props.push(i), f }, mo = function (e, t) { for (var i in t) e[i] = t[i]; return e }, Nc = function (e, t, i) { var r = mo({}, i._gsap), s = "perspective,force3D,transformOrigin,svgOrigin", a = i.style, o, l, c, d, u, f, p, g; r.svg ? (c = i.getAttribute("transform"), i.setAttribute("transform", ""), a[ge] = t, o = Ts(i, 1), dr(i, ge), i.setAttribute("transform", c)) : (c = getComputedStyle(i)[ge], a[ge] = t, o = Ts(i, 1), a[ge] = c); for (l in gi) c = r[l], d = o[l], c !== d && s.indexOf(l) < 0 && (p = Ze(c), g = Ze(d), u = p !== g ? Oi(i, l, c, g) : parseFloat(c), f = parseFloat(d), e._pt = new _t(e._pt, o, l, u, f - u, la), e._pt.u = g || 0, e._props.push(l)); mo(o, r) }; vt("padding,margin,Width,Radius", function (n, e) { var t = "Top", i = "Right", r = "Bottom", s = "Left", a = (e < 3 ? [t, i, r, s] : [t + s, t + i, r + i, r + s]).map(function (o) { return e < 2 ? n + o : "border" + o + n }); cn[e > 1 ? "border" + n : n] = function (o, l, c, d, u) { var f, p; if (arguments.length < 4) return f = a.map(function (g) { return ci(o, g, c) }), p = f.join(" "), p.split(f[0]).length === 5 ? f[0] : p; f = (d + "").split(" "), p = {}, a.forEach(function (g, h) { return p[g] = f[h] = f[h] || f[(h - 1) / 2 | 0] }), o.init(l, p, u) } }); var Fl = { name: "css", register: ca, targetTest: function (e) { return e.style && e.nodeType }, init: function (e, t, i, r, s) { var a = this._props, o = e.style, l = i.vars.startAt, c, d, u, f, p, g, h, m, y, _, v, w, x, S, P, A; Ba || ca(), this.styles = this.styles || Ol(e), A = this.styles.props, this.tween = i; for (h in t) if (h !== "autoRound" && (d = t[h], !(Tt[h] && bl(h, t, i, r, e, s)))) { if (p = typeof d, g = cn[h], p === "function" && (d = d.call(i, r, e, s), p = typeof d), p === "string" && ~d.indexOf("random(") && (d = ws(d)), g) g(this, e, h, d, i) && (P = 1); else if (h.substr(0, 2) === "--") c = (getComputedStyle(e).getPropertyValue(h) + "").trim(), d += "", Li.lastIndex = 0, Li.test(c) || (m = Ze(c), y = Ze(d)), y ? m !== y && (c = Oi(e, h, c, y) + y) : m && (d += m), this.add(o, "setProperty", c, d, r, s, 0, 0, h), a.push(h), A.push(h, 0, o[h]); else if (p !== "undefined") { if (l && h in l ? (c = typeof l[h] == "function" ? l[h].call(i, r, e, s) : l[h], He(c) && ~c.indexOf("random(") && (c = ws(c)), Ze(c + "") || c === "auto" || (c += At.units[h] || Ze(ci(e, h)) || ""), (c + "").charAt(1) === "=" && (c = ci(e, h))) : c = ci(e, h), f = parseFloat(c), _ = p === "string" && d.charAt(1) === "=" && d.substr(0, 2), _ && (d = d.substr(2)), u = parseFloat(d), h in ii && (h === "autoAlpha" && (f === 1 && ci(e, "visibility") === "hidden" && u && (f = 0), A.push("visibility", 0, o.visibility), Ti(this, o, "visibility", f ? "inherit" : "hidden", u ? "inherit" : "hidden", !u)), h !== "scale" && h !== "transform" && (h = ii[h], ~h.indexOf(",") && (h = h.split(",")[0]))), v = h in gi, v) { if (this.styles.save(h), w || (x = e._gsap, x.renderTransform && !t.parseTransform || Ts(e, t.parseTransform), S = t.smoothOrigin !== !1 && x.smooth, w = this._pt = new _t(this._pt, o, ge, 0, 1, x.renderTransform, x, 0, -1), w.dep = 1), h === "scale") this._pt = new _t(this._pt, x, "scaleY", x.scaleY, (_ ? Pr(x.scaleY, _ + u) : u) - x.scaleY || 0, la), this._pt.u = 0, a.push("scaleY", h), h += "X"; else if (h === "transformOrigin") { A.push(yt, 0, o[yt]), d = zc(d), x.svg ? ua(e, d, 0, S, 0, this) : (y = parseFloat(d.split(" ")[2]) || 0, y !== x.zOrigin && Ti(this, x, "zOrigin", x.zOrigin, y), Ti(this, o, h, un(c), un(d))); continue } else if (h === "svgOrigin") { ua(e, d, 1, S, 0, this); continue } else if (h in Rl) { Fc(this, x, h, f, _ ? Pr(f, _ + d) : d); continue } else if (h === "smoothOrigin") { Ti(this, x, "smooth", x.smooth, d); continue } else if (h === "force3D") { x[h] = d; continue } else if (h === "transform") { Nc(this, d, e); continue } } else h in o || (h = Br(h) || h); if (v || (u || u === 0) && (f || f === 0) && !bc.test(d) && h in o) m = (c + "").substr((f + "").length), u || (u = 0), y = Ze(d) || (h in At.units ? At.units[h] : m), m !== y && (f = Oi(e, h, c, y)), this._pt = new _t(this._pt, v ? x : o, h, f, (_ ? Pr(f, _ + u) : u) - f, !v && (y === "px" || h === "zIndex") && t.autoRound !== !1 ? Tc : la), this._pt.u = y || 0, m !== y && y !== "%" && (this._pt.b = c, this._pt.r = Sc); else if (h in o) Ic.call(this, e, h, c, _ ? _ + d : d); else if (h in e) this.add(e, h, c || e[h], _ ? _ + d : d, r, s); else if (h !== "parseTransform") { La(h, d); continue } v || (h in o ? A.push(h, 0, o[h]) : A.push(h, 1, c || e[h])), a.push(h) } } P && Cl(this) }, render: function (e, t) { if (t.tween._time || !Fa()) for (var i = t._pt; i;)i.r(e, i.d), i = i._next; else t.styles.revert() }, get: ci, aliases: ii, getSetter: function (e, t, i) { var r = ii[t]; return r && r.indexOf(",") < 0 && (t = r), t in gi && t !== yt && (e._gsap.x || ci(e, "x")) ? i && oo === i ? t === "scale" ? Pc : Cc : (oo = i || {}) && (t === "scale" ? Lc : Ac) : e.style && !Ma(e.style[t]) ? Ec : ~t.indexOf("-") ? Mc : Ra(e, t) }, core: { _removeProperty: dr, _getMatrix: qa } }; wt.utils.checkPrefix = Br; wt.core.getStyleSaver = Ol; (function (n, e, t, i) { var r = vt(n + "," + e + "," + t, function (s) { gi[s] = 1 }); vt(e, function (s) { At.units[s] = "deg", Rl[s] = 1 }), ii[r[13]] = n + "," + e, vt(i, function (s) { var a = s.split(":"); ii[a[1]] = r[a[0]] }) })("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY"); vt("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function (n) { At.units[n] = "px" }); wt.registerPlugin(Fl); var En = wt.registerPlugin(Fl) || wt; En.core.Tween; function go(n, e) { for (var t = 0; t < e.length; t++) { var i = e[t]; i.enumerable = i.enumerable || !1, i.configurable = !0, "value" in i && (i.writable = !0), Object.defineProperty(n, i.key, i) } } function qc(n, e, t) { return e && go(n.prototype, e), t && go(n, t), n }/*!
 * Observer 3.12.4
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var Xe, Us, Ct, Ei, Mi, kr, Nl, ji, os, ql, pi, jt, Yl, Hl = function () { return Xe || typeof window < "u" && (Xe = window.gsap) && Xe.registerPlugin && Xe }, Vl = 1, Mr = [], K = [], ni = [], ls = Date.now, fa = function (e, t) { return t }, Yc = function () { var e = os.core, t = e.bridge || {}, i = e._scrollers, r = e._proxies; i.push.apply(i, K), r.push.apply(r, ni), K = i, ni = r, fa = function (a, o) { return t[a](o) } }, Ai = function (e, t) { return ~ni.indexOf(e) && ni[ni.indexOf(e) + 1][t] }, ds = function (e) { return !!~ql.indexOf(e) }, st = function (e, t, i, r, s) { return e.addEventListener(t, i, { passive: !r, capture: !!s }) }, rt = function (e, t, i, r) { return e.removeEventListener(t, i, !!r) }, Ds = "scrollLeft", Is = "scrollTop", pa = function () { return pi && pi.isPressed || K.cache++ }, fn = function (e, t) { var i = function r(s) { if (s || s === 0) { Vl && (Ct.history.scrollRestoration = "manual"); var a = pi && pi.isPressed; s = r.v = Math.round(s) || (pi && pi.iOS ? 1 : 0), e(s), r.cacheID = K.cache, a && fa("ss", s) } else (t || K.cache !== r.cacheID || fa("ref")) && (r.cacheID = K.cache, r.v = e()); return r.v + r.offset }; return i.offset = 0, e && i }, ct = { s: Ds, p: "left", p2: "Left", os: "right", os2: "Right", d: "width", d2: "Width", a: "x", sc: fn(function (n) { return arguments.length ? Ct.scrollTo(n, Oe.sc()) : Ct.pageXOffset || Ei[Ds] || Mi[Ds] || kr[Ds] || 0 }) }, Oe = { s: Is, p: "top", p2: "Top", os: "bottom", os2: "Bottom", d: "height", d2: "Height", a: "y", op: ct, sc: fn(function (n) { return arguments.length ? Ct.scrollTo(ct.sc(), n) : Ct.pageYOffset || Ei[Is] || Mi[Is] || kr[Is] || 0 }) }, mt = function (e, t) { return (t && t._ctx && t._ctx.selector || Xe.utils.toArray)(e)[0] || (typeof e == "string" && Xe.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null) }, Di = function (e, t) { var i = t.s, r = t.sc; ds(e) && (e = Ei.scrollingElement || Mi); var s = K.indexOf(e), a = r === Oe.sc ? 1 : 2; !~s && (s = K.push(e) - 1), K[s + a] || st(e, "scroll", pa); var o = K[s + a], l = o || (K[s + a] = fn(Ai(e, i), !0) || (ds(e) ? r : fn(function (c) { return arguments.length ? e[i] = c : e[i] }))); return l.target = e, o || (l.smooth = Xe.getProperty(e, "scrollBehavior") === "smooth"), l }, ha = function (e, t, i) { var r = e, s = e, a = ls(), o = a, l = t || 50, c = Math.max(500, l * 3), d = function (g, h) { var m = ls(); h || m - a > l ? (s = r, r = g, o = a, a = m) : i ? r += g : r = s + (g - s) / (m - o) * (a - o) }, u = function () { s = r = i ? 0 : r, o = a = 0 }, f = function (g) { var h = o, m = s, y = ls(); return (g || g === 0) && g !== r && d(g), a === o || y - o > c ? 0 : (r + (i ? m : -m)) / ((i ? y : a) - h) * 1e3 }; return { update: d, reset: u, getVelocity: f } }, Wr = function (e, t) { return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e }, vo = function (e) { var t = Math.max.apply(Math, e), i = Math.min.apply(Math, e); return Math.abs(t) >= Math.abs(i) ? t : i }, Gl = function () { os = Xe.core.globals().ScrollTrigger, os && os.core && Yc() }, Xl = function (e) { return Xe = e || Hl(), !Us && Xe && typeof document < "u" && document.body && (Ct = window, Ei = document, Mi = Ei.documentElement, kr = Ei.body, ql = [Ct, Ei, Mi, kr], Xe.utils.clamp, Yl = Xe.core.context || function () { }, ji = "onpointerenter" in kr ? "pointer" : "mouse", Nl = Ce.isTouch = Ct.matchMedia && Ct.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in Ct || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, jt = Ce.eventTypes = ("ontouchstart" in Mi ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in Mi ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function () { return Vl = 0 }, 500), Gl(), Us = 1), Us }; ct.op = Oe; K.cache = 0; var Ce = function () { function n(t) { this.init(t) } var e = n.prototype; return e.init = function (i) { Us || Xl(Xe) || console.warn("Please gsap.registerPlugin(Observer)"), os || Gl(); var r = i.tolerance, s = i.dragMinimum, a = i.type, o = i.target, l = i.lineHeight, c = i.debounce, d = i.preventDefault, u = i.onStop, f = i.onStopDelay, p = i.ignore, g = i.wheelSpeed, h = i.event, m = i.onDragStart, y = i.onDragEnd, _ = i.onDrag, v = i.onPress, w = i.onRelease, x = i.onRight, S = i.onLeft, P = i.onUp, A = i.onDown, M = i.onChangeX, E = i.onChangeY, O = i.onChange, C = i.onToggleX, k = i.onToggleY, b = i.onHover, L = i.onHoverEnd, z = i.onMove, D = i.ignoreCheck, I = i.isNormalizer, R = i.onGestureStart, T = i.onGestureEnd, q = i.onWheel, ie = i.onEnable, N = i.onDisable, Y = i.onClick, se = i.scrollSpeed, de = i.capture, ne = i.allowClicks, De = i.lockAxis, Pe = i.onLockAxis; this.target = o = mt(o) || Mi, this.vars = i, p && (p = Xe.utils.toArray(p)), r = r || 1e-9, s = s || 0, g = g || 1, se = se || 1, a = a || "wheel,touch,pointer", c = c !== !1, l || (l = parseFloat(Ct.getComputedStyle(kr).lineHeight) || 22); var qt, Ie, et, W, ue, ze, Ve, $ = this, Le = 0, tt = 0, Ri = Di(o, ct), Se = Di(o, Oe), $i = Ri(), Bi = Se(), Yr = ~a.indexOf("touch") && !~a.indexOf("pointer") && jt[0] === "pointerdown", Ae = ds(o), we = o.ownerDocument || Ei, Yt = [0, 0, 0], Ht = [0, 0, 0], Fi = 0, oi = function () { return Fi = ls() }, Kt = function (H, re) { return ($.event = H) && p && ~p.indexOf(H.target) || re && Yr && H.pointerType !== "touch" || D && D(H, re) }, pt = function () { $._vx.reset(), $._vy.reset(), Ie.pause(), u && u($) }, Ni = function () { var H = $.deltaX = vo(Yt), re = $.deltaY = vo(Ht), Te = Math.abs(H) >= r, B = Math.abs(re) >= r; O && (Te || B) && O($, H, re, Yt, Ht), Te && (x && $.deltaX > 0 && x($), S && $.deltaX < 0 && S($), M && M($), C && $.deltaX < 0 != Le < 0 && C($), Le = $.deltaX, Yt[0] = Yt[1] = Yt[2] = 0), B && (A && $.deltaY > 0 && A($), P && $.deltaY < 0 && P($), E && E($), k && $.deltaY < 0 != tt < 0 && k($), tt = $.deltaY, Ht[0] = Ht[1] = Ht[2] = 0), (W || et) && (z && z($), et && (_($), et = !1), W = !1), ze && !(ze = !1) && Pe && Pe($), ue && (q($), ue = !1), qt = 0 }, gr = function (H, re, Te) { Yt[Te] += H, Ht[Te] += re, $._vx.update(H), $._vy.update(re), c ? qt || (qt = requestAnimationFrame(Ni)) : Ni() }, vr = function (H, re) { De && !Ve && ($.axis = Ve = Math.abs(H) > Math.abs(re) ? "x" : "y", ze = !0), Ve !== "y" && (Yt[2] += H, $._vx.update(H, !0)), Ve !== "x" && (Ht[2] += re, $._vy.update(re, !0)), c ? qt || (qt = requestAnimationFrame(Ni)) : Ni() }, qi = function (H) { if (!Kt(H, 1)) { H = Wr(H, d); var re = H.clientX, Te = H.clientY, B = re - $.x, j = Te - $.y, V = $.isDragging; $.x = re, $.y = Te, (V || Math.abs($.startX - re) >= s || Math.abs($.startY - Te) >= s) && (_ && (et = !0), V || ($.isDragging = !0), vr(B, j), V || m && m($)) } }, vi = $.onPress = function (G) { Kt(G, 1) || G && G.button || ($.axis = Ve = null, Ie.pause(), $.isPressed = !0, G = Wr(G), Le = tt = 0, $.startX = $.x = G.clientX, $.startY = $.y = G.clientY, $._vx.reset(), $._vy.reset(), st(I ? o : we, jt[1], qi, d, !0), $.deltaX = $.deltaY = 0, v && v($)) }, _i = $.onRelease = function (G) { if (!Kt(G, 1)) { rt(I ? o : we, jt[1], qi, !0); var H = !isNaN($.y - $.startY), re = $.isDragging, Te = re && (Math.abs($.x - $.startX) > 3 || Math.abs($.y - $.startY) > 3), B = Wr(G); !Te && H && ($._vx.reset(), $._vy.reset(), d && ne && Xe.delayedCall(.08, function () { if (ls() - Fi > 300 && !G.defaultPrevented) { if (G.target.click) G.target.click(); else if (we.createEvent) { var j = we.createEvent("MouseEvents"); j.initMouseEvent("click", !0, !0, Ct, 1, B.screenX, B.screenY, B.clientX, B.clientY, !1, !1, !1, !1, 0, null), G.target.dispatchEvent(j) } } })), $.isDragging = $.isGesturing = $.isPressed = !1, u && re && !I && Ie.restart(!0), y && re && y($), w && w($, Te) } }, ee = function (H) { return H.touches && H.touches.length > 1 && ($.isGesturing = !0) && R(H, $.isDragging) }, Yi = function () { return ($.isGesturing = !1) || T($) }, Vt = function (H) { if (!Kt(H)) { var re = Ri(), Te = Se(); gr((re - $i) * se, (Te - Bi) * se, 1), $i = re, Bi = Te, u && Ie.restart(!0) } }, Gt = function (H) { if (!Kt(H)) { H = Wr(H, d), q && (ue = !0); var re = (H.deltaMode === 1 ? l : H.deltaMode === 2 ? Ct.innerHeight : 1) * g; gr(H.deltaX * re, H.deltaY * re, 0), u && !I && Ie.restart(!0) } }, Xt = function (H) { if (!Kt(H)) { var re = H.clientX, Te = H.clientY, B = re - $.x, j = Te - $.y; $.x = re, $.y = Te, W = !0, u && Ie.restart(!0), (B || j) && vr(B, j) } }, Hi = function (H) { $.event = H, b($) }, _r = function (H) { $.event = H, L($) }, li = function (H) { return Kt(H) || Wr(H, d) && Y($) }; Ie = $._dc = Xe.delayedCall(f || .25, pt).pause(), $.deltaX = $.deltaY = 0, $._vx = ha(0, 50, !0), $._vy = ha(0, 50, !0), $.scrollX = Ri, $.scrollY = Se, $.isDragging = $.isGesturing = $.isPressed = !1, Yl(this), $.enable = function (G) { return $.isEnabled || (st(Ae ? we : o, "scroll", pa), a.indexOf("scroll") >= 0 && st(Ae ? we : o, "scroll", Vt, d, de), a.indexOf("wheel") >= 0 && st(o, "wheel", Gt, d, de), (a.indexOf("touch") >= 0 && Nl || a.indexOf("pointer") >= 0) && (st(o, jt[0], vi, d, de), st(we, jt[2], _i), st(we, jt[3], _i), ne && st(o, "click", oi, !1, !0), Y && st(o, "click", li), R && st(we, "gesturestart", ee), T && st(we, "gestureend", Yi), b && st(o, ji + "enter", Hi), L && st(o, ji + "leave", _r), z && st(o, ji + "move", Xt)), $.isEnabled = !0, G && G.type && vi(G), ie && ie($)), $ }, $.disable = function () { $.isEnabled && (Mr.filter(function (G) { return G !== $ && ds(G.target) }).length || rt(Ae ? we : o, "scroll", pa), $.isPressed && ($._vx.reset(), $._vy.reset(), rt(I ? o : we, jt[1], qi, !0)), rt(Ae ? we : o, "scroll", Vt, de), rt(o, "wheel", Gt, de), rt(o, jt[0], vi, de), rt(we, jt[2], _i), rt(we, jt[3], _i), rt(o, "click", oi, !0), rt(o, "click", li), rt(we, "gesturestart", ee), rt(we, "gestureend", Yi), rt(o, ji + "enter", Hi), rt(o, ji + "leave", _r), rt(o, ji + "move", Xt), $.isEnabled = $.isPressed = $.isDragging = !1, N && N($)) }, $.kill = $.revert = function () { $.disable(); var G = Mr.indexOf($); G >= 0 && Mr.splice(G, 1), pi === $ && (pi = 0) }, Mr.push($), I && ds(o) && (pi = $), $.enable(h) }, qc(n, [{ key: "velocityX", get: function () { return this._vx.getVelocity() } }, { key: "velocityY", get: function () { return this._vy.getVelocity() } }]), n }(); Ce.version = "3.12.4"; Ce.create = function (n) { return new Ce(n) }; Ce.register = Xl; Ce.getAll = function () { return Mr.slice() }; Ce.getById = function (n) { return Mr.filter(function (e) { return e.vars.id === n })[0] }; Hl() && Xe.registerPlugin(Ce);/*!
 * ScrollTrigger 3.12.4
 * https://gsap.com
 *
 * @license Copyright 2008-2023, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
*/var F, xr, Q, he, Ut, ce, Wl, pn, Es, Cr, Ks, zs, Ke, Mn, ma, at, _o, yo, Sr, jl, Bn, Ul, nt, Kl, Zl, Ql, yi, ga, Ya, Or, Ha, hn, va, Fn, Rs = 1, lt = Date.now, Nn = lt(), Ft = 0, Zr = 0, wo = function (e, t, i) { var r = St(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1); return i["_" + t + "Clamp"] = r, r ? e.substr(6, e.length - 7) : e }, bo = function (e, t) { return t && (!St(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e }, Hc = function n() { return Zr && requestAnimationFrame(n) }, xo = function () { return Mn = 1 }, So = function () { return Mn = 0 }, ei = function (e) { return e }, Qr = function (e) { return Math.round(e * 1e5) / 1e5 || 0 }, Jl = function () { return typeof window < "u" }, ed = function () { return F || Jl() && (F = window.gsap) && F.registerPlugin && F }, cr = function (e) { return !!~Wl.indexOf(e) }, td = function (e) { return (e === "Height" ? Ha : Q["inner" + e]) || Ut["client" + e] || ce["client" + e] }, id = function (e) { return Ai(e, "getBoundingClientRect") || (cr(e) ? function () { return rn.width = Q.innerWidth, rn.height = Ha, rn } : function () { return ui(e) }) }, Vc = function (e, t, i) { var r = i.d, s = i.d2, a = i.a; return (a = Ai(e, "getBoundingClientRect")) ? function () { return a()[r] } : function () { return (t ? td(s) : e["client" + s]) || 0 } }, Gc = function (e, t) { return !t || ~ni.indexOf(e) ? id(e) : function () { return rn } }, ri = function (e, t) { var i = t.s, r = t.d2, s = t.d, a = t.a; return Math.max(0, (i = "scroll" + r) && (a = Ai(e, i)) ? a() - id(e)()[s] : cr(e) ? (Ut[i] || ce[i]) - td(r) : e[i] - e["offset" + r]) }, $s = function (e, t) { for (var i = 0; i < Sr.length; i += 3)(!t || ~t.indexOf(Sr[i + 1])) && e(Sr[i], Sr[i + 1], Sr[i + 2]) }, St = function (e) { return typeof e == "string" }, ut = function (e) { return typeof e == "function" }, Zs = function (e) { return typeof e == "number" }, Ui = function (e) { return typeof e == "object" }, jr = function (e, t, i) { return e && e.progress(t ? 0 : 1) && i && e.pause() }, qn = function (e, t) { if (e.enabled) { var i = e._ctx ? e._ctx.add(function () { return t(e) }) : t(e); i && i.totalTime && (e.callbackAnimation = i) } }, wr = Math.abs, rd = "left", sd = "top", Va = "right", Ga = "bottom", rr = "width", sr = "height", cs = "Right", us = "Left", fs = "Top", ps = "Bottom", Ee = "padding", It = "margin", Fr = "Width", Xa = "Height", Be = "px", zt = function (e) { return Q.getComputedStyle(e) }, Xc = function (e) { var t = zt(e).position; e.style.position = t === "absolute" || t === "fixed" ? t : "relative" }, To = function (e, t) { for (var i in t) i in e || (e[i] = t[i]); return e }, ui = function (e, t) { var i = t && zt(e)[ma] !== "matrix(1, 0, 0, 1, 0, 0)" && F.to(e, { x: 0, y: 0, xPercent: 0, yPercent: 0, rotation: 0, rotationX: 0, rotationY: 0, scale: 1, skewX: 0, skewY: 0 }).progress(1), r = e.getBoundingClientRect(); return i && i.progress(0).kill(), r }, _a = function (e, t) { var i = t.d2; return e["offset" + i] || e["client" + i] || 0 }, nd = function (e) { var t = [], i = e.labels, r = e.duration(), s; for (s in i) t.push(i[s] / r); return t }, Wc = function (e) { return function (t) { return F.utils.snap(nd(e), t) } }, Wa = function (e) { var t = F.utils.snap(e), i = Array.isArray(e) && e.slice(0).sort(function (r, s) { return r - s }); return i ? function (r, s, a) { a === void 0 && (a = .001); var o; if (!s) return t(r); if (s > 0) { for (r -= a, o = 0; o < i.length; o++)if (i[o] >= r) return i[o]; return i[o - 1] } else for (o = i.length, r += a; o--;)if (i[o] <= r) return i[o]; return i[0] } : function (r, s, a) { a === void 0 && (a = .001); var o = t(r); return !s || Math.abs(o - r) < a || o - r < 0 == s < 0 ? o : t(s < 0 ? r - e : r + e) } }, jc = function (e) { return function (t, i) { return Wa(nd(e))(t, i.direction) } }, Bs = function (e, t, i, r) { return i.split(",").forEach(function (s) { return e(t, s, r) }) }, Ne = function (e, t, i, r, s) { return e.addEventListener(t, i, { passive: !r, capture: !!s }) }, Fe = function (e, t, i, r) { return e.removeEventListener(t, i, !!r) }, Fs = function (e, t, i) { i = i && i.wheelHandler, i && (e(t, "wheel", i), e(t, "touchmove", i)) }, Eo = { startColor: "green", endColor: "red", indent: 0, fontSize: "16px", fontWeight: "normal" }, Ns = { toggleActions: "play", anticipatePin: 0 }, mn = { top: 0, left: 0, center: .5, bottom: 1, right: 1 }, Qs = function (e, t) { if (St(e)) { var i = e.indexOf("="), r = ~i ? +(e.charAt(i - 1) + 1) * parseFloat(e.substr(i + 1)) : 0; ~i && (e.indexOf("%") > i && (r *= t / 100), e = e.substr(0, i - 1)), e = r + (e in mn ? mn[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0) } return e }, qs = function (e, t, i, r, s, a, o, l) { var c = s.startColor, d = s.endColor, u = s.fontSize, f = s.indent, p = s.fontWeight, g = he.createElement("div"), h = cr(i) || Ai(i, "pinType") === "fixed", m = e.indexOf("scroller") !== -1, y = h ? ce : i, _ = e.indexOf("start") !== -1, v = _ ? c : d, w = "border-color:" + v + ";font-size:" + u + ";color:" + v + ";font-weight:" + p + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;"; return w += "position:" + ((m || l) && h ? "fixed;" : "absolute;"), (m || l || !h) && (w += (r === Oe ? Va : Ga) + ":" + (a + parseFloat(f)) + "px;"), o && (w += "box-sizing:border-box;text-align:left;width:" + o.offsetWidth + "px;"), g._isStart = _, g.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), g.style.cssText = w, g.innerText = t || t === 0 ? e + "-" + t : e, y.children[0] ? y.insertBefore(g, y.children[0]) : y.appendChild(g), g._offset = g["offset" + r.op.d2], Js(g, 0, r, _), g }, Js = function (e, t, i, r) { var s = { display: "block" }, a = i[r ? "os2" : "p2"], o = i[r ? "p2" : "os2"]; e._isFlipped = r, s[i.a + "Percent"] = r ? -100 : 0, s[i.a] = r ? "1px" : 0, s["border" + a + Fr] = 1, s["border" + o + Fr] = 0, s[i.p] = t + "px", F.set(e, s) }, X = [], ya = {}, Ms, Mo = function () { return lt() - Ft > 34 && (Ms || (Ms = requestAnimationFrame(hi))) }, br = function () { (!nt || !nt.isPressed || nt.startX > ce.clientWidth) && (K.cache++, nt ? Ms || (Ms = requestAnimationFrame(hi)) : hi(), Ft || fr("scrollStart"), Ft = lt()) }, Yn = function () { Ql = Q.innerWidth, Zl = Q.innerHeight }, Jr = function () { K.cache++, !Ke && !Ul && !he.fullscreenElement && !he.webkitFullscreenElement && (!Kl || Ql !== Q.innerWidth || Math.abs(Q.innerHeight - Zl) > Q.innerHeight * .25) && pn.restart(!0) }, ur = {}, Uc = [], ad = function n() { return Fe(Z, "scrollEnd", n) || Qi(!0) }, fr = function (e) { return ur[e] && ur[e].map(function (t) { return t() }) || Uc }, xt = [], od = function (e) { for (var t = 0; t < xt.length; t += 5)(!e || xt[t + 4] && xt[t + 4].query === e) && (xt[t].style.cssText = xt[t + 1], xt[t].getBBox && xt[t].setAttribute("transform", xt[t + 2] || ""), xt[t + 3].uncache = 1) }, ja = function (e, t) { var i; for (at = 0; at < X.length; at++)i = X[at], i && (!t || i._ctx === t) && (e ? i.kill(1) : i.revert(!0, !0)); hn = !0, t && od(t), t || fr("revert") }, ld = function (e, t) { K.cache++, (t || !ot) && K.forEach(function (i) { return ut(i) && i.cacheID++ && (i.rec = 0) }), St(e) && (Q.history.scrollRestoration = Ya = e) }, ot, nr = 0, Co, Kc = function () { if (Co !== nr) { var e = Co = nr; requestAnimationFrame(function () { return e === nr && Qi(!0) }) } }, dd = function () { ce.appendChild(Or), Ha = !nt && Or.offsetHeight || Q.innerHeight, ce.removeChild(Or) }, Po = function (e) { return Es(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function (t) { return t.style.display = e ? "none" : "block" }) }, Qi = function (e, t) { if (Ft && !e && !hn) { Ne(Z, "scrollEnd", ad); return } dd(), ot = Z.isRefreshing = !0, K.forEach(function (r) { return ut(r) && ++r.cacheID && (r.rec = r()) }); var i = fr("refreshInit"); jl && Z.sort(), t || ja(), K.forEach(function (r) { ut(r) && (r.smooth && (r.target.style.scrollBehavior = "auto"), r(0)) }), X.slice(0).forEach(function (r) { return r.refresh() }), hn = !1, X.forEach(function (r) { if (r._subPinOffset && r.pin) { var s = r.vars.horizontal ? "offsetWidth" : "offsetHeight", a = r.pin[s]; r.revert(!0, 1), r.adjustPinSpacing(r.pin[s] - a), r.refresh() } }), va = 1, Po(!0), X.forEach(function (r) { var s = ri(r.scroller, r._dir), a = r.vars.end === "max" || r._endClamp && r.end > s, o = r._startClamp && r.start >= s; (a || o) && r.setPositions(o ? s - 1 : r.start, a ? Math.max(o ? s : r.start + 1, s) : r.end, !0) }), Po(!1), va = 0, i.forEach(function (r) { return r && r.render && r.render(-1) }), K.forEach(function (r) { ut(r) && (r.smooth && requestAnimationFrame(function () { return r.target.style.scrollBehavior = "smooth" }), r.rec && r(r.rec)) }), ld(Ya, 1), pn.pause(), nr++, ot = 2, hi(2), X.forEach(function (r) { return ut(r.vars.onRefresh) && r.vars.onRefresh(r) }), ot = Z.isRefreshing = !1, fr("refresh") }, wa = 0, en = 1, hs, hi = function (e) { if (e === 2 || !ot && !hn) { Z.isUpdating = !0, hs && hs.update(0); var t = X.length, i = lt(), r = i - Nn >= 50, s = t && X[0].scroll(); if (en = wa > s ? -1 : 1, ot || (wa = s), r && (Ft && !Mn && i - Ft > 200 && (Ft = 0, fr("scrollEnd")), Ks = Nn, Nn = i), en < 0) { for (at = t; at-- > 0;)X[at] && X[at].update(0, r); en = 1 } else for (at = 0; at < t; at++)X[at] && X[at].update(0, r); Z.isUpdating = !1 } Ms = 0 }, ba = [rd, sd, Ga, Va, It + ps, It + cs, It + fs, It + us, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"], tn = ba.concat([rr, sr, "boxSizing", "max" + Fr, "max" + Xa, "position", It, Ee, Ee + fs, Ee + cs, Ee + ps, Ee + us]), Zc = function (e, t, i) { Dr(i); var r = e._gsap; if (r.spacerIsNative) Dr(r.spacerState); else if (e._gsap.swappedIn) { var s = t.parentNode; s && (s.insertBefore(e, t), s.removeChild(t)) } e._gsap.swappedIn = !1 }, Hn = function (e, t, i, r) { if (!e._gsap.swappedIn) { for (var s = ba.length, a = t.style, o = e.style, l; s--;)l = ba[s], a[l] = i[l]; a.position = i.position === "absolute" ? "absolute" : "relative", i.display === "inline" && (a.display = "inline-block"), o[Ga] = o[Va] = "auto", a.flexBasis = i.flexBasis || "auto", a.overflow = "visible", a.boxSizing = "border-box", a[rr] = _a(e, ct) + Be, a[sr] = _a(e, Oe) + Be, a[Ee] = o[It] = o[sd] = o[rd] = "0", Dr(r), o[rr] = o["max" + Fr] = i[rr], o[sr] = o["max" + Xa] = i[sr], o[Ee] = i[Ee], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0 } }, Qc = /([A-Z])/g, Dr = function (e) { if (e) { var t = e.t.style, i = e.length, r = 0, s, a; for ((e.t._gsap || F.core.getCache(e.t)).uncache = 1; r < i; r += 2)a = e[r + 1], s = e[r], a ? t[s] = a : t[s] && t.removeProperty(s.replace(Qc, "-$1").toLowerCase()) } }, Ys = function (e) { for (var t = tn.length, i = e.style, r = [], s = 0; s < t; s++)r.push(tn[s], i[tn[s]]); return r.t = e, r }, Jc = function (e, t, i) { for (var r = [], s = e.length, a = i ? 8 : 0, o; a < s; a += 2)o = e[a], r.push(o, o in t ? t[o] : e[a + 1]); return r.t = e.t, r }, rn = { left: 0, top: 0 }, Lo = function (e, t, i, r, s, a, o, l, c, d, u, f, p, g) { ut(e) && (e = e(l)), St(e) && e.substr(0, 3) === "max" && (e = f + (e.charAt(4) === "=" ? Qs("0" + e.substr(3), i) : 0)); var h = p ? p.time() : 0, m, y, _; if (p && p.seek(0), isNaN(e) || (e = +e), Zs(e)) p && (e = F.utils.mapRange(p.scrollTrigger.start, p.scrollTrigger.end, 0, f, e)), o && Js(o, i, r, !0); else { ut(t) && (t = t(l)); var v = (e || "0").split(" "), w, x, S, P; _ = mt(t, l) || ce, w = ui(_) || {}, (!w || !w.left && !w.top) && zt(_).display === "none" && (P = _.style.display, _.style.display = "block", w = ui(_), P ? _.style.display = P : _.style.removeProperty("display")), x = Qs(v[0], w[r.d]), S = Qs(v[1] || "0", i), e = w[r.p] - c[r.p] - d + x + s - S, o && Js(o, S, r, i - S < 20 || o._isStart && S > 20), i -= i - S } if (g && (l[g] = e || -.001, e < 0 && (e = 0)), a) { var A = e + i, M = a._isStart; m = "scroll" + r.d2, Js(a, A, r, M && A > 20 || !M && (u ? Math.max(ce[m], Ut[m]) : a.parentNode[m]) <= A + 1), u && (c = ui(o), u && (a.style[r.op.p] = c[r.op.p] - r.op.m - a._offset + Be)) } return p && _ && (m = ui(_), p.seek(f), y = ui(_), p._caScrollDist = m[r.p] - y[r.p], e = e / p._caScrollDist * f), p && p.seek(h), p ? e : Math.round(e) }, eu = /(webkit|moz|length|cssText|inset)/i, Ao = function (e, t, i, r) { if (e.parentNode !== t) { var s = e.style, a, o; if (t === ce) { e._stOrig = s.cssText, o = zt(e); for (a in o) !+a && !eu.test(a) && o[a] && typeof s[a] == "string" && a !== "0" && (s[a] = o[a]); s.top = i, s.left = r } else s.cssText = e._stOrig; F.core.getCache(e).uncache = 1, t.appendChild(e) } }, cd = function (e, t, i) { var r = t, s = r; return function (a) { var o = Math.round(e()); return o !== r && o !== s && Math.abs(o - r) > 3 && Math.abs(o - s) > 3 && (a = o, i && i()), s = r, r = a, a } }, Hs = function (e, t, i) { var r = {}; r[t.p] = "+=" + i, F.set(e, r) }, ko = function (e, t) { var i = Di(e, t), r = "_scroll" + t.p2, s = function a(o, l, c, d, u) { var f = a.tween, p = l.onComplete, g = {}; c = c || i(); var h = cd(i, c, function () { f.kill(), a.tween = 0 }); return u = d && u || 0, d = d || o - c, f && f.kill(), l[r] = o, l.modifiers = g, g[r] = function () { return h(c + d * f.ratio + u * f.ratio * f.ratio) }, l.onUpdate = function () { K.cache++, a.tween && hi() }, l.onComplete = function () { a.tween = 0, p && p.call(f) }, f = a.tween = F.to(e, l), f }; return e[r] = i, i.wheelHandler = function () { return s.tween && s.tween.kill() && (s.tween = 0) }, Ne(e, "wheel", i.wheelHandler), Z.isTouch && Ne(e, "touchmove", i.wheelHandler), s }, Z = function () { function n(t, i) { xr || n.register(F) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), ga(this), this.init(t, i) } var e = n.prototype; return e.init = function (i, r) { if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !Zr) { this.update = this.refresh = this.kill = ei; return } i = To(St(i) || Zs(i) || i.nodeType ? { trigger: i } : i, Ns); var s = i, a = s.onUpdate, o = s.toggleClass, l = s.id, c = s.onToggle, d = s.onRefresh, u = s.scrub, f = s.trigger, p = s.pin, g = s.pinSpacing, h = s.invalidateOnRefresh, m = s.anticipatePin, y = s.onScrubComplete, _ = s.onSnapComplete, v = s.once, w = s.snap, x = s.pinReparent, S = s.pinSpacer, P = s.containerAnimation, A = s.fastScrollEnd, M = s.preventOverlaps, E = i.horizontal || i.containerAnimation && i.horizontal !== !1 ? ct : Oe, O = !u && u !== 0, C = mt(i.scroller || Q), k = F.core.getCache(C), b = cr(C), L = ("pinType" in i ? i.pinType : Ai(C, "pinType") || b && "fixed") === "fixed", z = [i.onEnter, i.onLeave, i.onEnterBack, i.onLeaveBack], D = O && i.toggleActions.split(" "), I = "markers" in i ? i.markers : Ns.markers, R = b ? 0 : parseFloat(zt(C)["border" + E.p2 + Fr]) || 0, T = this, q = i.onRefreshInit && function () { return i.onRefreshInit(T) }, ie = Vc(C, b, E), N = Gc(C, b), Y = 0, se = 0, de = 0, ne = Di(C, E), De, Pe, qt, Ie, et, W, ue, ze, Ve, $, Le, tt, Ri, Se, $i, Bi, Yr, Ae, we, Yt, Ht, Fi, oi, Kt, pt, Ni, gr, vr, qi, vi, _i, ee, Yi, Vt, Gt, Xt, Hi, _r, li; if (T._startClamp = T._endClamp = !1, T._dir = E, m *= 45, T.scroller = C, T.scroll = P ? P.time.bind(P) : ne, Ie = ne(), T.vars = i, r = r || i.animation, "refreshPriority" in i && (jl = 1, i.refreshPriority === -9999 && (hs = T)), k.tweenScroll = k.tweenScroll || { top: ko(C, Oe), left: ko(C, ct) }, T.tweenTo = De = k.tweenScroll[E.p], T.scrubDuration = function (B) { Yi = Zs(B) && B, Yi ? ee ? ee.duration(B) : ee = F.to(r, { ease: "expo", totalProgress: "+=0", duration: Yi, paused: !0, onComplete: function () { return y && y(T) } }) : (ee && ee.progress(1).kill(), ee = 0) }, r && (r.vars.lazy = !1, r._initted && !T.isReverted || r.vars.immediateRender !== !1 && i.immediateRender !== !1 && r.duration() && r.render(0, !0, !0), T.animation = r.pause(), r.scrollTrigger = T, T.scrubDuration(u), vi = 0, l || (l = r.vars.id)), w && ((!Ui(w) || w.push) && (w = { snapTo: w }), "scrollBehavior" in ce.style && F.set(b ? [ce, Ut] : C, { scrollBehavior: "auto" }), K.forEach(function (B) { return ut(B) && B.target === (b ? he.scrollingElement || Ut : C) && (B.smooth = !1) }), qt = ut(w.snapTo) ? w.snapTo : w.snapTo === "labels" ? Wc(r) : w.snapTo === "labelsDirectional" ? jc(r) : w.directional !== !1 ? function (B, j) { return Wa(w.snapTo)(B, lt() - se < 500 ? 0 : j.direction) } : F.utils.snap(w.snapTo), Vt = w.duration || { min: .1, max: 2 }, Vt = Ui(Vt) ? Cr(Vt.min, Vt.max) : Cr(Vt, Vt), Gt = F.delayedCall(w.delay || Yi / 2 || .1, function () { var B = ne(), j = lt() - se < 500, V = De.tween; if ((j || Math.abs(T.getVelocity()) < 10) && !V && !Mn && Y !== B) { var U = (B - W) / Se, Re = r && !O ? r.totalProgress() : U, te = j ? 0 : (Re - _i) / (lt() - Ks) * 1e3 || 0, be = F.utils.clamp(-U, 1 - U, wr(te / 2) * te / .185), it = U + (w.inertia === !1 ? 0 : be), $e = Cr(0, 1, qt(it, T)), fe = Math.round(W + $e * Se), ae = w, Wt = ae.onStart, pe = ae.onInterrupt, bt = ae.onComplete; if (B <= ue && B >= W && fe !== B) { if (V && !V._initted && V.data <= wr(fe - B)) return; w.inertia === !1 && (be = $e - U), De(fe, { duration: Vt(wr(Math.max(wr(it - Re), wr($e - Re)) * .185 / te / .05 || 0)), ease: w.ease || "power3", data: wr(fe - B), onInterrupt: function () { return Gt.restart(!0) && pe && pe(T) }, onComplete: function () { T.update(), Y = ne(), ee && r && r.progress($e), vi = _i = r && !O ? r.totalProgress() : T.progress, _ && _(T), bt && bt(T) } }, B, be * Se, fe - B - be * Se), Wt && Wt(T, De.tween) } } else T.isActive && Y !== B && Gt.restart(!0) }).pause()), l && (ya[l] = T), f = T.trigger = mt(f || p !== !0 && p), li = f && f._gsap && f._gsap.stRevert, li && (li = li(T)), p = p === !0 ? f : mt(p), St(o) && (o = { targets: f, className: o }), p && (g === !1 || g === It || (g = !g && p.parentNode && p.parentNode.style && zt(p.parentNode).display === "flex" ? !1 : Ee), T.pin = p, Pe = F.core.getCache(p), Pe.spacer ? $i = Pe.pinState : (S && (S = mt(S), S && !S.nodeType && (S = S.current || S.nativeElement), Pe.spacerIsNative = !!S, S && (Pe.spacerState = Ys(S))), Pe.spacer = Ae = S || he.createElement("div"), Ae.classList.add("pin-spacer"), l && Ae.classList.add("pin-spacer-" + l), Pe.pinState = $i = Ys(p)), i.force3D !== !1 && F.set(p, { force3D: !0 }), T.spacer = Ae = Pe.spacer, qi = zt(p), Kt = qi[g + E.os2], Yt = F.getProperty(p), Ht = F.quickSetter(p, E.a, Be), Hn(p, Ae, qi), Yr = Ys(p)), I) { tt = Ui(I) ? To(I, Eo) : Eo, $ = qs("scroller-start", l, C, E, tt, 0), Le = qs("scroller-end", l, C, E, tt, 0, $), we = $["offset" + E.op.d2]; var G = mt(Ai(C, "content") || C); ze = this.markerStart = qs("start", l, G, E, tt, we, 0, P), Ve = this.markerEnd = qs("end", l, G, E, tt, we, 0, P), P && (_r = F.quickSetter([ze, Ve], E.a, Be)), !L && !(ni.length && Ai(C, "fixedMarkers") === !0) && (Xc(b ? ce : C), F.set([$, Le], { force3D: !0 }), Ni = F.quickSetter($, E.a, Be), vr = F.quickSetter(Le, E.a, Be)) } if (P) { var H = P.vars.onUpdate, re = P.vars.onUpdateParams; P.eventCallback("onUpdate", function () { T.update(0, 0, 1), H && H.apply(P, re || []) }) } if (T.previous = function () { return X[X.indexOf(T) - 1] }, T.next = function () { return X[X.indexOf(T) + 1] }, T.revert = function (B, j) { if (!j) return T.kill(!0); var V = B !== !1 || !T.enabled, U = Ke; V !== T.isReverted && (V && (Xt = Math.max(ne(), T.scroll.rec || 0), de = T.progress, Hi = r && r.progress()), ze && [ze, Ve, $, Le].forEach(function (Re) { return Re.style.display = V ? "none" : "block" }), V && (Ke = T, T.update(V)), p && (!x || !T.isActive) && (V ? Zc(p, Ae, $i) : Hn(p, Ae, zt(p), pt)), V || T.update(V), Ke = U, T.isReverted = V) }, T.refresh = function (B, j, V, U) { if (!((Ke || !T.enabled) && !j)) { if (p && B && Ft) { Ne(n, "scrollEnd", ad); return } !ot && q && q(T), Ke = T, De.tween && !V && (De.tween.kill(), De.tween = 0), ee && ee.pause(), h && r && r.revert({ kill: !1 }).invalidate(), T.isReverted || T.revert(!0, !0), T._subPinOffset = !1; var Re = ie(), te = N(), be = P ? P.duration() : ri(C, E), it = Se <= .01, $e = 0, fe = U || 0, ae = Ui(V) ? V.end : i.end, Wt = i.endTrigger || f, pe = Ui(V) ? V.start : i.start || (i.start === 0 || !f ? 0 : p ? "0 0" : "0 100%"), bt = T.pinnedContainer = i.pinnedContainer && mt(i.pinnedContainer, T), Zt = f && Math.max(0, X.indexOf(T)) || 0, ht = Zt, Ge, je, Vi, As, Ue, ke, Qt, Pn, Qa, Hr, Jt, Vr, ks; for (I && Ui(V) && (Vr = F.getProperty($, E.p), ks = F.getProperty(Le, E.p)); ht--;)ke = X[ht], ke.end || ke.refresh(0, 1) || (Ke = T), Qt = ke.pin, Qt && (Qt === f || Qt === p || Qt === bt) && !ke.isReverted && (Hr || (Hr = []), Hr.unshift(ke), ke.revert(!0, !0)), ke !== X[ht] && (Zt--, ht--); for (ut(pe) && (pe = pe(T)), pe = wo(pe, "start", T), W = Lo(pe, f, Re, E, ne(), ze, $, T, te, R, L, be, P, T._startClamp && "_startClamp") || (p ? -.001 : 0), ut(ae) && (ae = ae(T)), St(ae) && !ae.indexOf("+=") && (~ae.indexOf(" ") ? ae = (St(pe) ? pe.split(" ")[0] : "") + ae : ($e = Qs(ae.substr(2), Re), ae = St(pe) ? pe : (P ? F.utils.mapRange(0, P.duration(), P.scrollTrigger.start, P.scrollTrigger.end, W) : W) + $e, Wt = f)), ae = wo(ae, "end", T), ue = Math.max(W, Lo(ae || (Wt ? "100% 0" : be), Wt, Re, E, ne() + $e, Ve, Le, T, te, R, L, be, P, T._endClamp && "_endClamp")) || -.001, $e = 0, ht = Zt; ht--;)ke = X[ht], Qt = ke.pin, Qt && ke.start - ke._pinPush <= W && !P && ke.end > 0 && (Ge = ke.end - (T._startClamp ? Math.max(0, ke.start) : ke.start), (Qt === f && ke.start - ke._pinPush < W || Qt === bt) && isNaN(pe) && ($e += Ge * (1 - ke.progress)), Qt === p && (fe += Ge)); if (W += $e, ue += $e, T._startClamp && (T._startClamp += $e), T._endClamp && !ot && (T._endClamp = ue || -.001, ue = Math.min(ue, ri(C, E))), Se = ue - W || (W -= .01) && .001, it && (de = F.utils.clamp(0, 1, F.utils.normalize(W, ue, Xt))), T._pinPush = fe, ze && $e && (Ge = {}, Ge[E.a] = "+=" + $e, bt && (Ge[E.p] = "-=" + ne()), F.set([ze, Ve], Ge)), p && !(va && T.end >= ri(C, E))) Ge = zt(p), As = E === Oe, Vi = ne(), Fi = parseFloat(Yt(E.a)) + fe, !be && ue > 1 && (Jt = (b ? he.scrollingElement || Ut : C).style, Jt = { style: Jt, value: Jt["overflow" + E.a.toUpperCase()] }, b && zt(ce)["overflow" + E.a.toUpperCase()] !== "scroll" && (Jt.style["overflow" + E.a.toUpperCase()] = "scroll")), Hn(p, Ae, Ge), Yr = Ys(p), je = ui(p, !0), Pn = L && Di(C, As ? ct : Oe)(), g && (pt = [g + E.os2, Se + fe + Be], pt.t = Ae, ht = g === Ee ? _a(p, E) + Se + fe : 0, ht && (pt.push(E.d, ht + Be), Ae.style.flexBasis !== "auto" && (Ae.style.flexBasis = ht + Be)), Dr(pt), bt && X.forEach(function (Gr) { Gr.pin === bt && Gr.vars.pinSpacing !== !1 && (Gr._subPinOffset = !0) }), L && ne(Xt)), L && (Ue = { top: je.top + (As ? Vi - W : Pn) + Be, left: je.left + (As ? Pn : Vi - W) + Be, boxSizing: "border-box", position: "fixed" }, Ue[rr] = Ue["max" + Fr] = Math.ceil(je.width) + Be, Ue[sr] = Ue["max" + Xa] = Math.ceil(je.height) + Be, Ue[It] = Ue[It + fs] = Ue[It + cs] = Ue[It + ps] = Ue[It + us] = "0", Ue[Ee] = Ge[Ee], Ue[Ee + fs] = Ge[Ee + fs], Ue[Ee + cs] = Ge[Ee + cs], Ue[Ee + ps] = Ge[Ee + ps], Ue[Ee + us] = Ge[Ee + us], Bi = Jc($i, Ue, x), ot && ne(0)), r ? (Qa = r._initted, Bn(1), r.render(r.duration(), !0, !0), oi = Yt(E.a) - Fi + Se + fe, gr = Math.abs(Se - oi) > 1, L && gr && Bi.splice(Bi.length - 2, 2), r.render(0, !0, !0), Qa || r.invalidate(!0), r.parent || r.totalTime(r.totalTime()), Bn(0)) : oi = Se, Jt && (Jt.value ? Jt.style["overflow" + E.a.toUpperCase()] = Jt.value : Jt.style.removeProperty("overflow-" + E.a)); else if (f && ne() && !P) for (je = f.parentNode; je && je !== ce;)je._pinOffset && (W -= je._pinOffset, ue -= je._pinOffset), je = je.parentNode; Hr && Hr.forEach(function (Gr) { return Gr.revert(!1, !0) }), T.start = W, T.end = ue, Ie = et = ot ? Xt : ne(), !P && !ot && (Ie < Xt && ne(Xt), T.scroll.rec = 0), T.revert(!1, !0), se = lt(), Gt && (Y = -1, Gt.restart(!0)), Ke = 0, r && O && (r._initted || Hi) && r.progress() !== Hi && r.progress(Hi || 0, !0).render(r.time(), !0, !0), (it || de !== T.progress || P) && (r && !O && r.totalProgress(P && W < -.001 && !de ? F.utils.normalize(W, ue, 0) : de, !0), T.progress = it || (Ie - W) / Se === de ? 0 : de), p && g && (Ae._pinOffset = Math.round(T.progress * oi)), ee && ee.invalidate(), isNaN(Vr) || (Vr -= F.getProperty($, E.p), ks -= F.getProperty(Le, E.p), Hs($, E, Vr), Hs(ze, E, Vr - (U || 0)), Hs(Le, E, ks), Hs(Ve, E, ks - (U || 0))), it && !ot && T.update(), d && !ot && !Ri && (Ri = !0, d(T), Ri = !1) } }, T.getVelocity = function () { return (ne() - et) / (lt() - Ks) * 1e3 || 0 }, T.endAnimation = function () { jr(T.callbackAnimation), r && (ee ? ee.progress(1) : r.paused() ? O || jr(r, T.direction < 0, 1) : jr(r, r.reversed())) }, T.labelToScroll = function (B) { return r && r.labels && (W || T.refresh() || W) + r.labels[B] / r.duration() * Se || 0 }, T.getTrailing = function (B) { var j = X.indexOf(T), V = T.direction > 0 ? X.slice(0, j).reverse() : X.slice(j + 1); return (St(B) ? V.filter(function (U) { return U.vars.preventOverlaps === B }) : V).filter(function (U) { return T.direction > 0 ? U.end <= W : U.start >= ue }) }, T.update = function (B, j, V) { if (!(P && !V && !B)) { var U = ot === !0 ? Xt : T.scroll(), Re = B ? 0 : (U - W) / Se, te = Re < 0 ? 0 : Re > 1 ? 1 : Re || 0, be = T.progress, it, $e, fe, ae, Wt, pe, bt, Zt; if (j && (et = Ie, Ie = P ? ne() : U, w && (_i = vi, vi = r && !O ? r.totalProgress() : te)), m && !te && p && !Ke && !Rs && Ft && W < U + (U - et) / (lt() - Ks) * m && (te = 1e-4), te !== be && T.enabled) { if (it = T.isActive = !!te && te < 1, $e = !!be && be < 1, pe = it !== $e, Wt = pe || !!te != !!be, T.direction = te > be ? 1 : -1, T.progress = te, Wt && !Ke && (fe = te && !be ? 0 : te === 1 ? 1 : be === 1 ? 2 : 3, O && (ae = !pe && D[fe + 1] !== "none" && D[fe + 1] || D[fe], Zt = r && (ae === "complete" || ae === "reset" || ae in r))), M && (pe || Zt) && (Zt || u || !r) && (ut(M) ? M(T) : T.getTrailing(M).forEach(function (Vi) { return Vi.endAnimation() })), O || (ee && !Ke && !Rs ? (ee._dp._time - ee._start !== ee._time && ee.render(ee._dp._time - ee._start), ee.resetTo ? ee.resetTo("totalProgress", te, r._tTime / r._tDur) : (ee.vars.totalProgress = te, ee.invalidate().restart())) : r && r.totalProgress(te, !!(Ke && (se || B)))), p) { if (B && g && (Ae.style[g + E.os2] = Kt), !L) Ht(Qr(Fi + oi * te)); else if (Wt) { if (bt = !B && te > be && ue + 1 > U && U + 1 >= ri(C, E), x) if (!B && (it || bt)) { var ht = ui(p, !0), Ge = U - W; Ao(p, ce, ht.top + (E === Oe ? Ge : 0) + Be, ht.left + (E === Oe ? 0 : Ge) + Be) } else Ao(p, Ae); Dr(it || bt ? Bi : Yr), gr && te < 1 && it || Ht(Fi + (te === 1 && !bt ? oi : 0)) } } w && !De.tween && !Ke && !Rs && Gt.restart(!0), o && (pe || v && te && (te < 1 || !Fn)) && Es(o.targets).forEach(function (Vi) { return Vi.classList[it || v ? "add" : "remove"](o.className) }), a && !O && !B && a(T), Wt && !Ke ? (O && (Zt && (ae === "complete" ? r.pause().totalProgress(1) : ae === "reset" ? r.restart(!0).pause() : ae === "restart" ? r.restart(!0) : r[ae]()), a && a(T)), (pe || !Fn) && (c && pe && qn(T, c), z[fe] && qn(T, z[fe]), v && (te === 1 ? T.kill(!1, 1) : z[fe] = 0), pe || (fe = te === 1 ? 1 : 3, z[fe] && qn(T, z[fe]))), A && !it && Math.abs(T.getVelocity()) > (Zs(A) ? A : 2500) && (jr(T.callbackAnimation), ee ? ee.progress(1) : jr(r, ae === "reverse" ? 1 : !te, 1))) : O && a && !Ke && a(T) } if (vr) { var je = P ? U / P.duration() * (P._caScrollDist || 0) : U; Ni(je + ($._isFlipped ? 1 : 0)), vr(je) } _r && _r(-U / P.duration() * (P._caScrollDist || 0)) } }, T.enable = function (B, j) { T.enabled || (T.enabled = !0, Ne(C, "resize", Jr), b || Ne(C, "scroll", br), q && Ne(n, "refreshInit", q), B !== !1 && (T.progress = de = 0, Ie = et = Y = ne()), j !== !1 && T.refresh()) }, T.getTween = function (B) { return B && De ? De.tween : ee }, T.setPositions = function (B, j, V, U) { if (P) { var Re = P.scrollTrigger, te = P.duration(), be = Re.end - Re.start; B = Re.start + be * B / te, j = Re.start + be * j / te } T.refresh(!1, !1, { start: bo(B, V && !!T._startClamp), end: bo(j, V && !!T._endClamp) }, U), T.update() }, T.adjustPinSpacing = function (B) { if (pt && B) { var j = pt.indexOf(E.d) + 1; pt[j] = parseFloat(pt[j]) + B + Be, pt[1] = parseFloat(pt[1]) + B + Be, Dr(pt) } }, T.disable = function (B, j) { if (T.enabled && (B !== !1 && T.revert(!0, !0), T.enabled = T.isActive = !1, j || ee && ee.pause(), Xt = 0, Pe && (Pe.uncache = 1), q && Fe(n, "refreshInit", q), Gt && (Gt.pause(), De.tween && De.tween.kill() && (De.tween = 0)), !b)) { for (var V = X.length; V--;)if (X[V].scroller === C && X[V] !== T) return; Fe(C, "resize", Jr), b || Fe(C, "scroll", br) } }, T.kill = function (B, j) { T.disable(B, j), ee && !j && ee.kill(), l && delete ya[l]; var V = X.indexOf(T); V >= 0 && X.splice(V, 1), V === at && en > 0 && at--, V = 0, X.forEach(function (U) { return U.scroller === T.scroller && (V = 1) }), V || ot || (T.scroll.rec = 0), r && (r.scrollTrigger = null, B && r.revert({ kill: !1 }), j || r.kill()), ze && [ze, Ve, $, Le].forEach(function (U) { return U.parentNode && U.parentNode.removeChild(U) }), hs === T && (hs = 0), p && (Pe && (Pe.uncache = 1), V = 0, X.forEach(function (U) { return U.pin === p && V++ }), V || (Pe.spacer = 0)), i.onKill && i.onKill(T) }, X.push(T), T.enable(!1, !1), li && li(T), r && r.add && !Se) { var Te = T.update; T.update = function () { T.update = Te, W || ue || T.refresh() }, F.delayedCall(.01, T.update), Se = .01, W = ue = 0 } else T.refresh(); p && Kc() }, n.register = function (i) { return xr || (F = i || ed(), Jl() && window.document && n.enable(), xr = Zr), xr }, n.defaults = function (i) { if (i) for (var r in i) Ns[r] = i[r]; return Ns }, n.disable = function (i, r) { Zr = 0, X.forEach(function (a) { return a[r ? "kill" : "disable"](i) }), Fe(Q, "wheel", br), Fe(he, "scroll", br), clearInterval(zs), Fe(he, "touchcancel", ei), Fe(ce, "touchstart", ei), Bs(Fe, he, "pointerdown,touchstart,mousedown", xo), Bs(Fe, he, "pointerup,touchend,mouseup", So), pn.kill(), $s(Fe); for (var s = 0; s < K.length; s += 3)Fs(Fe, K[s], K[s + 1]), Fs(Fe, K[s], K[s + 2]) }, n.enable = function () { if (Q = window, he = document, Ut = he.documentElement, ce = he.body, F && (Es = F.utils.toArray, Cr = F.utils.clamp, ga = F.core.context || ei, Bn = F.core.suppressOverwrites || ei, Ya = Q.history.scrollRestoration || "auto", wa = Q.pageYOffset, F.core.globals("ScrollTrigger", n), ce)) { Zr = 1, Or = document.createElement("div"), Or.style.height = "100vh", Or.style.position = "absolute", dd(), Hc(), Ce.register(F), n.isTouch = Ce.isTouch, yi = Ce.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), Ne(Q, "wheel", br), Wl = [Q, he, Ut, ce], F.matchMedia ? (n.matchMedia = function (l) { var c = F.matchMedia(), d; for (d in l) c.add(d, l[d]); return c }, F.addEventListener("matchMediaInit", function () { return ja() }), F.addEventListener("matchMediaRevert", function () { return od() }), F.addEventListener("matchMedia", function () { Qi(0, 1), fr("matchMedia") }), F.matchMedia("(orientation: portrait)", function () { return Yn(), Yn })) : console.warn("Requires GSAP 3.11.0 or later"), Yn(), Ne(he, "scroll", br); var i = ce.style, r = i.borderTopStyle, s = F.core.Animation.prototype, a, o; for (s.revert || Object.defineProperty(s, "revert", { value: function () { return this.time(-.01, !0) } }), i.borderTopStyle = "solid", a = ui(ce), Oe.m = Math.round(a.top + Oe.sc()) || 0, ct.m = Math.round(a.left + ct.sc()) || 0, r ? i.borderTopStyle = r : i.removeProperty("border-top-style"), zs = setInterval(Mo, 250), F.delayedCall(.5, function () { return Rs = 0 }), Ne(he, "touchcancel", ei), Ne(ce, "touchstart", ei), Bs(Ne, he, "pointerdown,touchstart,mousedown", xo), Bs(Ne, he, "pointerup,touchend,mouseup", So), ma = F.utils.checkPrefix("transform"), tn.push(ma), xr = lt(), pn = F.delayedCall(.2, Qi).pause(), Sr = [he, "visibilitychange", function () { var l = Q.innerWidth, c = Q.innerHeight; he.hidden ? (_o = l, yo = c) : (_o !== l || yo !== c) && Jr() }, he, "DOMContentLoaded", Qi, Q, "load", Qi, Q, "resize", Jr], $s(Ne), X.forEach(function (l) { return l.enable(0, 1) }), o = 0; o < K.length; o += 3)Fs(Fe, K[o], K[o + 1]), Fs(Fe, K[o], K[o + 2]) } }, n.config = function (i) { "limitCallbacks" in i && (Fn = !!i.limitCallbacks); var r = i.syncInterval; r && clearInterval(zs) || (zs = r) && setInterval(Mo, r), "ignoreMobileResize" in i && (Kl = n.isTouch === 1 && i.ignoreMobileResize), "autoRefreshEvents" in i && ($s(Fe) || $s(Ne, i.autoRefreshEvents || "none"), Ul = (i.autoRefreshEvents + "").indexOf("resize") === -1) }, n.scrollerProxy = function (i, r) { var s = mt(i), a = K.indexOf(s), o = cr(s); ~a && K.splice(a, o ? 6 : 2), r && (o ? ni.unshift(Q, r, ce, r, Ut, r) : ni.unshift(s, r)) }, n.clearMatchMedia = function (i) { X.forEach(function (r) { return r._ctx && r._ctx.query === i && r._ctx.kill(!0, !0) }) }, n.isInViewport = function (i, r, s) { var a = (St(i) ? mt(i) : i).getBoundingClientRect(), o = a[s ? rr : sr] * r || 0; return s ? a.right - o > 0 && a.left + o < Q.innerWidth : a.bottom - o > 0 && a.top + o < Q.innerHeight }, n.positionInViewport = function (i, r, s) { St(i) && (i = mt(i)); var a = i.getBoundingClientRect(), o = a[s ? rr : sr], l = r == null ? o / 2 : r in mn ? mn[r] * o : ~r.indexOf("%") ? parseFloat(r) * o / 100 : parseFloat(r) || 0; return s ? (a.left + l) / Q.innerWidth : (a.top + l) / Q.innerHeight }, n.killAll = function (i) { if (X.slice(0).forEach(function (s) { return s.vars.id !== "ScrollSmoother" && s.kill() }), i !== !0) { var r = ur.killAll || []; ur = {}, r.forEach(function (s) { return s() }) } }, n }(); Z.version = "3.12.4"; Z.saveStyles = function (n) { return n ? Es(n).forEach(function (e) { if (e && e.style) { var t = xt.indexOf(e); t >= 0 && xt.splice(t, 5), xt.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), F.core.getCache(e), ga()) } }) : xt }; Z.revert = function (n, e) { return ja(!n, e) }; Z.create = function (n, e) { return new Z(n, e) }; Z.refresh = function (n) { return n ? Jr() : (xr || Z.register()) && Qi(!0) }; Z.update = function (n) { return ++K.cache && hi(n === !0 ? 2 : 0) }; Z.clearScrollMemory = ld; Z.maxScroll = function (n, e) { return ri(n, e ? ct : Oe) }; Z.getScrollFunc = function (n, e) { return Di(mt(n), e ? ct : Oe) }; Z.getById = function (n) { return ya[n] }; Z.getAll = function () { return X.filter(function (n) { return n.vars.id !== "ScrollSmoother" }) }; Z.isScrolling = function () { return !!Ft }; Z.snapDirectional = Wa; Z.addEventListener = function (n, e) { var t = ur[n] || (ur[n] = []); ~t.indexOf(e) || t.push(e) }; Z.removeEventListener = function (n, e) { var t = ur[n], i = t && t.indexOf(e); i >= 0 && t.splice(i, 1) }; Z.batch = function (n, e) { var t = [], i = {}, r = e.interval || .016, s = e.batchMax || 1e9, a = function (c, d) { var u = [], f = [], p = F.delayedCall(r, function () { d(u, f), u = [], f = [] }).pause(); return function (g) { u.length || p.restart(!0), u.push(g.trigger), f.push(g), s <= u.length && p.progress(1) } }, o; for (o in e) i[o] = o.substr(0, 2) === "on" && ut(e[o]) && o !== "onRefreshInit" ? a(o, e[o]) : e[o]; return ut(s) && (s = s(), Ne(Z, "refresh", function () { return s = e.batchMax() })), Es(n).forEach(function (l) { var c = {}; for (o in i) c[o] = i[o]; c.trigger = l, t.push(Z.create(c)) }), t }; var Oo = function (e, t, i, r) { return t > r ? e(r) : t < 0 && e(0), i > r ? (r - t) / (i - t) : i < 0 ? t / (t - i) : 1 }, Vn = function n(e, t) { t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (Ce.isTouch ? " pinch-zoom" : "") : "none", e === Ut && n(ce, t) }, Vs = { auto: 1, scroll: 1 }, tu = function (e) { var t = e.event, i = e.target, r = e.axis, s = (t.changedTouches ? t.changedTouches[0] : t).target, a = s._gsap || F.core.getCache(s), o = lt(), l; if (!a._isScrollT || o - a._isScrollT > 2e3) { for (; s && s !== ce && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(Vs[(l = zt(s)).overflowY] || Vs[l.overflowX]));)s = s.parentNode; a._isScroll = s && s !== i && !cr(s) && (Vs[(l = zt(s)).overflowY] || Vs[l.overflowX]), a._isScrollT = o } (a._isScroll || r === "x") && (t.stopPropagation(), t._gsapAllow = !0) }, ud = function (e, t, i, r) { return Ce.create({ target: e, capture: !0, debounce: !1, lockAxis: !0, type: t, onWheel: r = r && tu, onPress: r, onDrag: r, onScroll: r, onEnable: function () { return i && Ne(he, Ce.eventTypes[0], Io, !1, !0) }, onDisable: function () { return Fe(he, Ce.eventTypes[0], Io, !0) } }) }, iu = /(input|label|select|textarea)/i, Do, Io = function (e) { var t = iu.test(e.target.tagName); (t || Do) && (e._gsapAllow = !0, Do = t) }, ru = function (e) { Ui(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer"; var t = e, i = t.normalizeScrollX, r = t.momentum, s = t.allowNestedScroll, a = t.onRelease, o, l, c = mt(e.target) || Ut, d = F.core.globals().ScrollSmoother, u = d && d.get(), f = yi && (e.content && mt(e.content) || u && e.content !== !1 && !u.smooth() && u.content()), p = Di(c, Oe), g = Di(c, ct), h = 1, m = (Ce.isTouch && Q.visualViewport ? Q.visualViewport.scale * Q.visualViewport.width : Q.outerWidth) / Q.innerWidth, y = 0, _ = ut(r) ? function () { return r(o) } : function () { return r || 2.8 }, v, w, x = ud(c, e.type, !0, s), S = function () { return w = !1 }, P = ei, A = ei, M = function () { l = ri(c, Oe), A = Cr(yi ? 1 : 0, l), i && (P = Cr(0, ri(c, ct))), v = nr }, E = function () { f._gsap.y = Qr(parseFloat(f._gsap.y) + p.offset) + "px", f.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(f._gsap.y) + ", 0, 1)", p.offset = p.cacheID = 0 }, O = function () { if (w) { requestAnimationFrame(S); var I = Qr(o.deltaY / 2), R = A(p.v - I); if (f && R !== p.v + p.offset) { p.offset = R - p.v; var T = Qr((parseFloat(f && f._gsap.y) || 0) - p.offset); f.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + T + ", 0, 1)", f._gsap.y = T + "px", p.cacheID = K.cache, hi() } return !0 } p.offset && E(), w = !0 }, C, k, b, L, z = function () { M(), C.isActive() && C.vars.scrollY > l && (p() > l ? C.progress(1) && p(l) : C.resetTo("scrollY", l)) }; return f && F.set(f, { y: "+=0" }), e.ignoreCheck = function (D) { return yi && D.type === "touchmove" && O() || h > 1.05 && D.type !== "touchstart" || o.isGesturing || D.touches && D.touches.length > 1 }, e.onPress = function () { w = !1; var D = h; h = Qr((Q.visualViewport && Q.visualViewport.scale || 1) / m), C.pause(), D !== h && Vn(c, h > 1.01 ? !0 : i ? !1 : "x"), k = g(), b = p(), M(), v = nr }, e.onRelease = e.onGestureStart = function (D, I) { if (p.offset && E(), !I) L.restart(!0); else { K.cache++; var R = _(), T, q; i && (T = g(), q = T + R * .05 * -D.velocityX / .227, R *= Oo(g, T, q, ri(c, ct)), C.vars.scrollX = P(q)), T = p(), q = T + R * .05 * -D.velocityY / .227, R *= Oo(p, T, q, ri(c, Oe)), C.vars.scrollY = A(q), C.invalidate().duration(R).play(.01), (yi && C.vars.scrollY >= l || T >= l - 1) && F.to({}, { onUpdate: z, duration: R }) } a && a(D) }, e.onWheel = function () { C._ts && C.pause(), lt() - y > 1e3 && (v = 0, y = lt()) }, e.onChange = function (D, I, R, T, q) { if (nr !== v && M(), I && i && g(P(T[2] === I ? k + (D.startX - D.x) : g() + I - T[1])), R) { p.offset && E(); var ie = q[2] === R, N = ie ? b + D.startY - D.y : p() + R - q[1], Y = A(N); ie && N !== Y && (b += Y - N), p(Y) } (R || I) && hi() }, e.onEnable = function () { Vn(c, i ? !1 : "x"), Z.addEventListener("refresh", z), Ne(Q, "resize", z), p.smooth && (p.target.style.scrollBehavior = "auto", p.smooth = g.smooth = !1), x.enable() }, e.onDisable = function () { Vn(c, !0), Fe(Q, "resize", z), Z.removeEventListener("refresh", z), x.kill() }, e.lockAxis = e.lockAxis !== !1, o = new Ce(e), o.iOS = yi, yi && !p() && p(1), yi && F.ticker.add(ei), L = o._dc, C = F.to(o, { ease: "power4", paused: !0, scrollX: i ? "+=0.1" : "+=0", scrollY: "+=0.1", modifiers: { scrollY: cd(p, p(), function () { return C.pause() }) }, onUpdate: hi, onComplete: L.vars.onComplete }), o }; Z.sort = function (n) { return X.sort(n || function (e, t) { return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6) }) }; Z.observe = function (n) { return new Ce(n) }; Z.normalizeScroll = function (n) { if (typeof n > "u") return nt; if (n === !0 && nt) return nt.enable(); if (n === !1) { nt && nt.kill(), nt = n; return } var e = n instanceof Ce ? n : ru(n); return nt && nt.target === e.target && nt.kill(), cr(e.target) && (nt = e), e }; Z.core = { _getVelocityProp: ha, _inputObserver: ud, _scrollers: K, _proxies: ni, bridge: { ss: function () { Ft || fr("scrollStart"), Ft = lt() }, ref: function () { return Ke } } }; ed() && F.registerPlugin(Z); En.registerPlugin(Z); document.querySelector(".about-work__number") && En.fromTo(".about-work__number", { opacity: 0, x: -30 }, { opacity: 1, x: 0, stagger: .2, scrollTrigger: { trigger: ".about-work__title", start: "center 94%", end: "bottom 38%" } }); document.querySelector(".advancements__item") && En.fromTo(".advancements__item", { opacity: 0, scale: 0 }, { opacity: 1, scale: 1, stagger: .2, scrollTrigger: { trigger: ".advancements__title", start: "top 94%", end: "center 38%" } }); function zo(n) { return n !== null && typeof n == "object" && "constructor" in n && n.constructor === Object } function Ua(n, e) { n === void 0 && (n = {}), e === void 0 && (e = {}), Object.keys(e).forEach(t => { typeof n[t] > "u" ? n[t] = e[t] : zo(e[t]) && zo(n[t]) && Object.keys(e[t]).length > 0 && Ua(n[t], e[t]) }) } const fd = { body: {}, addEventListener() { }, removeEventListener() { }, activeElement: { blur() { }, nodeName: "" }, querySelector() { return null }, querySelectorAll() { return [] }, getElementById() { return null }, createEvent() { return { initEvent() { } } }, createElement() { return { children: [], childNodes: [], style: {}, setAttribute() { }, getElementsByTagName() { return [] } } }, createElementNS() { return {} }, importNode() { return null }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" } }; function ft() { const n = typeof document < "u" ? document : {}; return Ua(n, fd), n } const su = { document: fd, navigator: { userAgent: "" }, location: { hash: "", host: "", hostname: "", href: "", origin: "", pathname: "", protocol: "", search: "" }, history: { replaceState() { }, pushState() { }, go() { }, back() { } }, CustomEvent: function () { return this }, addEventListener() { }, removeEventListener() { }, getComputedStyle() { return { getPropertyValue() { return "" } } }, Image() { }, Date() { }, screen: {}, setTimeout() { }, clearTimeout() { }, matchMedia() { return {} }, requestAnimationFrame(n) { return typeof setTimeout > "u" ? (n(), null) : setTimeout(n, 0) }, cancelAnimationFrame(n) { typeof setTimeout > "u" || clearTimeout(n) } }; function ye() { const n = typeof window < "u" ? window : {}; return Ua(n, su), n } function wi(n) { return n === void 0 && (n = ""), n.trim().split(" ").filter(e => !!e.trim()) } function nu(n) { const e = n; Object.keys(e).forEach(t => { try { e[t] = null } catch { } try { delete e[t] } catch { } }) } function pr(n, e) { return e === void 0 && (e = 0), setTimeout(n, e) } function Rt() { return Date.now() } function au(n) { const e = ye(); let t; return e.getComputedStyle && (t = e.getComputedStyle(n, null)), !t && n.currentStyle && (t = n.currentStyle), t || (t = n.style), t } function xa(n, e) { e === void 0 && (e = "x"); const t = ye(); let i, r, s; const a = au(n); return t.WebKitCSSMatrix ? (r = a.transform || a.webkitTransform, r.split(",").length > 6 && (r = r.split(", ").map(o => o.replace(",", ".")).join(", ")), s = new t.WebKitCSSMatrix(r === "none" ? "" : r)) : (s = a.MozTransform || a.OTransform || a.MsTransform || a.msTransform || a.transform || a.getPropertyValue("transform").replace("translate(", "matrix(1, 0, 0, 1,"), i = s.toString().split(",")), e === "x" && (t.WebKitCSSMatrix ? r = s.m41 : i.length === 16 ? r = parseFloat(i[12]) : r = parseFloat(i[4])), e === "y" && (t.WebKitCSSMatrix ? r = s.m42 : i.length === 16 ? r = parseFloat(i[13]) : r = parseFloat(i[5])), r || 0 } function es(n) { return typeof n == "object" && n !== null && n.constructor && Object.prototype.toString.call(n).slice(8, -1) === "Object" } function ou(n) { return typeof window < "u" && typeof window.HTMLElement < "u" ? n instanceof HTMLElement : n && (n.nodeType === 1 || n.nodeType === 11) } function Et() { const n = Object(arguments.length <= 0 ? void 0 : arguments[0]), e = ["__proto__", "constructor", "prototype"]; for (let t = 1; t < arguments.length; t += 1) { const i = t < 0 || arguments.length <= t ? void 0 : arguments[t]; if (i != null && !ou(i)) { const r = Object.keys(Object(i)).filter(s => e.indexOf(s) < 0); for (let s = 0, a = r.length; s < a; s += 1) { const o = r[s], l = Object.getOwnPropertyDescriptor(i, o); l !== void 0 && l.enumerable && (es(n[o]) && es(i[o]) ? i[o].__swiper__ ? n[o] = i[o] : Et(n[o], i[o]) : !es(n[o]) && es(i[o]) ? (n[o] = {}, i[o].__swiper__ ? n[o] = i[o] : Et(n[o], i[o])) : n[o] = i[o]) } } } return n } function ts(n, e, t) { n.style.setProperty(e, t) } function pd(n) { let { swiper: e, targetPosition: t, side: i } = n; const r = ye(), s = -e.translate; let a = null, o; const l = e.params.speed; e.wrapperEl.style.scrollSnapType = "none", r.cancelAnimationFrame(e.cssModeFrameID); const c = t > s ? "next" : "prev", d = (f, p) => c === "next" && f >= p || c === "prev" && f <= p, u = () => { o = new Date().getTime(), a === null && (a = o); const f = Math.max(Math.min((o - a) / l, 1), 0), p = .5 - Math.cos(f * Math.PI) / 2; let g = s + p * (t - s); if (d(g, t) && (g = t), e.wrapperEl.scrollTo({ [i]: g }), d(g, t)) { e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.scrollSnapType = "", setTimeout(() => { e.wrapperEl.style.overflow = "", e.wrapperEl.scrollTo({ [i]: g }) }), r.cancelAnimationFrame(e.cssModeFrameID); return } e.cssModeFrameID = r.requestAnimationFrame(u) }; u() } function mr(n) { return n.querySelector(".swiper-slide-transform") || n.shadowRoot && n.shadowRoot.querySelector(".swiper-slide-transform") || n } function We(n, e) { return e === void 0 && (e = ""), [...n.children].filter(t => t.matches(e)) } function gn(n) { try { console.warn(n); return } catch { } } function Lt(n, e) { e === void 0 && (e = []); const t = document.createElement(n); return t.classList.add(...Array.isArray(e) ? e : wi(e)), t } function vn(n) { const e = ye(), t = ft(), i = n.getBoundingClientRect(), r = t.body, s = n.clientTop || r.clientTop || 0, a = n.clientLeft || r.clientLeft || 0, o = n === e ? e.scrollY : n.scrollTop, l = n === e ? e.scrollX : n.scrollLeft; return { top: i.top + o - s, left: i.left + l - a } } function lu(n, e) { const t = []; for (; n.previousElementSibling;) { const i = n.previousElementSibling; e ? i.matches(e) && t.push(i) : t.push(i), n = i } return t } function du(n, e) { const t = []; for (; n.nextElementSibling;) { const i = n.nextElementSibling; e ? i.matches(e) && t.push(i) : t.push(i), n = i } return t } function Ci(n, e) { return ye().getComputedStyle(n, null).getPropertyValue(e) } function Cs(n) { let e = n, t; if (e) { for (t = 0; (e = e.previousSibling) !== null;)e.nodeType === 1 && (t += 1); return t } } function ar(n, e) { const t = []; let i = n.parentElement; for (; i;)e ? i.matches(e) && t.push(i) : t.push(i), i = i.parentElement; return t } function ms(n, e) { function t(i) { i.target === n && (e.call(n, i), n.removeEventListener("transitionend", t)) } e && n.addEventListener("transitionend", t) } function Sa(n, e, t) { const i = ye(); return t ? n[e === "width" ? "offsetWidth" : "offsetHeight"] + parseFloat(i.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-right" : "margin-top")) + parseFloat(i.getComputedStyle(n, null).getPropertyValue(e === "width" ? "margin-left" : "margin-bottom")) : n.offsetWidth } let Gn; function cu() { const n = ye(), e = ft(); return { smoothScroll: e.documentElement && e.documentElement.style && "scrollBehavior" in e.documentElement.style, touch: !!("ontouchstart" in n || n.DocumentTouch && e instanceof n.DocumentTouch) } } function hd() { return Gn || (Gn = cu()), Gn } let Xn; function uu(n) { let { userAgent: e } = n === void 0 ? {} : n; const t = hd(), i = ye(), r = i.navigator.platform, s = e || i.navigator.userAgent, a = { ios: !1, android: !1 }, o = i.screen.width, l = i.screen.height, c = s.match(/(Android);?[\s\/]+([\d.]+)?/); let d = s.match(/(iPad).*OS\s([\d_]+)/); const u = s.match(/(iPod)(.*OS\s([\d_]+))?/), f = !d && s.match(/(iPhone\sOS|iOS)\s([\d_]+)/), p = r === "Win32"; let g = r === "MacIntel"; const h = ["1024x1366", "1366x1024", "834x1194", "1194x834", "834x1112", "1112x834", "768x1024", "1024x768", "820x1180", "1180x820", "810x1080", "1080x810"]; return !d && g && t.touch && h.indexOf(`${o}x${l}`) >= 0 && (d = s.match(/(Version)\/([\d.]+)/), d || (d = [0, 1, "13_0_0"]), g = !1), c && !p && (a.os = "android", a.android = !0), (d || f || u) && (a.os = "ios", a.ios = !0), a } function fu(n) { return n === void 0 && (n = {}), Xn || (Xn = uu(n)), Xn } let Wn; function pu() { const n = ye(); let e = !1; function t() { const i = n.navigator.userAgent.toLowerCase(); return i.indexOf("safari") >= 0 && i.indexOf("chrome") < 0 && i.indexOf("android") < 0 } if (t()) { const i = String(n.navigator.userAgent); if (i.includes("Version/")) { const [r, s] = i.split("Version/")[1].split(" ")[0].split(".").map(a => Number(a)); e = r < 16 || r === 16 && s < 2 } } return { isSafari: e || t(), needPerspectiveFix: e, isWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(n.navigator.userAgent) } } function hu() { return Wn || (Wn = pu()), Wn } function mu(n) { let { swiper: e, on: t, emit: i } = n; const r = ye(); let s = null, a = null; const o = () => { !e || e.destroyed || !e.initialized || (i("beforeResize"), i("resize")) }, l = () => { !e || e.destroyed || !e.initialized || (s = new ResizeObserver(u => { a = r.requestAnimationFrame(() => { const { width: f, height: p } = e; let g = f, h = p; u.forEach(m => { let { contentBoxSize: y, contentRect: _, target: v } = m; v && v !== e.el || (g = _ ? _.width : (y[0] || y).inlineSize, h = _ ? _.height : (y[0] || y).blockSize) }), (g !== f || h !== p) && o() }) }), s.observe(e.el)) }, c = () => { a && r.cancelAnimationFrame(a), s && s.unobserve && e.el && (s.unobserve(e.el), s = null) }, d = () => { !e || e.destroyed || !e.initialized || i("orientationchange") }; t("init", () => { if (e.params.resizeObserver && typeof r.ResizeObserver < "u") { l(); return } r.addEventListener("resize", o), r.addEventListener("orientationchange", d) }), t("destroy", () => { c(), r.removeEventListener("resize", o), r.removeEventListener("orientationchange", d) }) } function gu(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = [], a = ye(), o = function (d, u) { u === void 0 && (u = {}); const f = a.MutationObserver || a.WebkitMutationObserver, p = new f(g => { if (e.__preventObserver__) return; if (g.length === 1) { r("observerUpdate", g[0]); return } const h = function () { r("observerUpdate", g[0]) }; a.requestAnimationFrame ? a.requestAnimationFrame(h) : a.setTimeout(h, 0) }); p.observe(d, { attributes: typeof u.attributes > "u" ? !0 : u.attributes, childList: typeof u.childList > "u" ? !0 : u.childList, characterData: typeof u.characterData > "u" ? !0 : u.characterData }), s.push(p) }, l = () => { if (e.params.observer) { if (e.params.observeParents) { const d = ar(e.hostEl); for (let u = 0; u < d.length; u += 1)o(d[u]) } o(e.hostEl, { childList: e.params.observeSlideChildren }), o(e.wrapperEl, { attributes: !1 }) } }, c = () => { s.forEach(d => { d.disconnect() }), s.splice(0, s.length) }; t({ observer: !1, observeParents: !1, observeSlideChildren: !1 }), i("init", l), i("destroy", c) } var vu = { on(n, e, t) { const i = this; if (!i.eventsListeners || i.destroyed || typeof e != "function") return i; const r = t ? "unshift" : "push"; return n.split(" ").forEach(s => { i.eventsListeners[s] || (i.eventsListeners[s] = []), i.eventsListeners[s][r](e) }), i }, once(n, e, t) { const i = this; if (!i.eventsListeners || i.destroyed || typeof e != "function") return i; function r() { i.off(n, r), r.__emitterProxy && delete r.__emitterProxy; for (var s = arguments.length, a = new Array(s), o = 0; o < s; o++)a[o] = arguments[o]; e.apply(i, a) } return r.__emitterProxy = e, i.on(n, r, t) }, onAny(n, e) { const t = this; if (!t.eventsListeners || t.destroyed || typeof n != "function") return t; const i = e ? "unshift" : "push"; return t.eventsAnyListeners.indexOf(n) < 0 && t.eventsAnyListeners[i](n), t }, offAny(n) { const e = this; if (!e.eventsListeners || e.destroyed || !e.eventsAnyListeners) return e; const t = e.eventsAnyListeners.indexOf(n); return t >= 0 && e.eventsAnyListeners.splice(t, 1), e }, off(n, e) { const t = this; return !t.eventsListeners || t.destroyed || !t.eventsListeners || n.split(" ").forEach(i => { typeof e > "u" ? t.eventsListeners[i] = [] : t.eventsListeners[i] && t.eventsListeners[i].forEach((r, s) => { (r === e || r.__emitterProxy && r.__emitterProxy === e) && t.eventsListeners[i].splice(s, 1) }) }), t }, emit() { const n = this; if (!n.eventsListeners || n.destroyed || !n.eventsListeners) return n; let e, t, i; for (var r = arguments.length, s = new Array(r), a = 0; a < r; a++)s[a] = arguments[a]; return typeof s[0] == "string" || Array.isArray(s[0]) ? (e = s[0], t = s.slice(1, s.length), i = n) : (e = s[0].events, t = s[0].data, i = s[0].context || n), t.unshift(i), (Array.isArray(e) ? e : e.split(" ")).forEach(l => { n.eventsAnyListeners && n.eventsAnyListeners.length && n.eventsAnyListeners.forEach(c => { c.apply(i, [l, ...t]) }), n.eventsListeners && n.eventsListeners[l] && n.eventsListeners[l].forEach(c => { c.apply(i, t) }) }), n } }; function _u() { const n = this; let e, t; const i = n.el; typeof n.params.width < "u" && n.params.width !== null ? e = n.params.width : e = i.clientWidth, typeof n.params.height < "u" && n.params.height !== null ? t = n.params.height : t = i.clientHeight, !(e === 0 && n.isHorizontal() || t === 0 && n.isVertical()) && (e = e - parseInt(Ci(i, "padding-left") || 0, 10) - parseInt(Ci(i, "padding-right") || 0, 10), t = t - parseInt(Ci(i, "padding-top") || 0, 10) - parseInt(Ci(i, "padding-bottom") || 0, 10), Number.isNaN(e) && (e = 0), Number.isNaN(t) && (t = 0), Object.assign(n, { width: e, height: t, size: n.isHorizontal() ? e : t })) } function yu() { const n = this; function e(E, O) { return parseFloat(E.getPropertyValue(n.getDirectionLabel(O)) || 0) } const t = n.params, { wrapperEl: i, slidesEl: r, size: s, rtlTranslate: a, wrongRTL: o } = n, l = n.virtual && t.virtual.enabled, c = l ? n.virtual.slides.length : n.slides.length, d = We(r, `.${n.params.slideClass}, swiper-slide`), u = l ? n.virtual.slides.length : d.length; let f = []; const p = [], g = []; let h = t.slidesOffsetBefore; typeof h == "function" && (h = t.slidesOffsetBefore.call(n)); let m = t.slidesOffsetAfter; typeof m == "function" && (m = t.slidesOffsetAfter.call(n)); const y = n.snapGrid.length, _ = n.slidesGrid.length; let v = t.spaceBetween, w = -h, x = 0, S = 0; if (typeof s > "u") return; typeof v == "string" && v.indexOf("%") >= 0 ? v = parseFloat(v.replace("%", "")) / 100 * s : typeof v == "string" && (v = parseFloat(v)), n.virtualSize = -v, d.forEach(E => { a ? E.style.marginLeft = "" : E.style.marginRight = "", E.style.marginBottom = "", E.style.marginTop = "" }), t.centeredSlides && t.cssMode && (ts(i, "--swiper-centered-offset-before", ""), ts(i, "--swiper-centered-offset-after", "")); const P = t.grid && t.grid.rows > 1 && n.grid; P ? n.grid.initSlides(d) : n.grid && n.grid.unsetSlides(); let A; const M = t.slidesPerView === "auto" && t.breakpoints && Object.keys(t.breakpoints).filter(E => typeof t.breakpoints[E].slidesPerView < "u").length > 0; for (let E = 0; E < u; E += 1) { A = 0; let O; if (d[E] && (O = d[E]), P && n.grid.updateSlide(E, O, d), !(d[E] && Ci(O, "display") === "none")) { if (t.slidesPerView === "auto") { M && (d[E].style[n.getDirectionLabel("width")] = ""); const C = getComputedStyle(O), k = O.style.transform, b = O.style.webkitTransform; if (k && (O.style.transform = "none"), b && (O.style.webkitTransform = "none"), t.roundLengths) A = n.isHorizontal() ? Sa(O, "width", !0) : Sa(O, "height", !0); else { const L = e(C, "width"), z = e(C, "padding-left"), D = e(C, "padding-right"), I = e(C, "margin-left"), R = e(C, "margin-right"), T = C.getPropertyValue("box-sizing"); if (T && T === "border-box") A = L + I + R; else { const { clientWidth: q, offsetWidth: ie } = O; A = L + z + D + I + R + (ie - q) } } k && (O.style.transform = k), b && (O.style.webkitTransform = b), t.roundLengths && (A = Math.floor(A)) } else A = (s - (t.slidesPerView - 1) * v) / t.slidesPerView, t.roundLengths && (A = Math.floor(A)), d[E] && (d[E].style[n.getDirectionLabel("width")] = `${A}px`); d[E] && (d[E].swiperSlideSize = A), g.push(A), t.centeredSlides ? (w = w + A / 2 + x / 2 + v, x === 0 && E !== 0 && (w = w - s / 2 - v), E === 0 && (w = w - s / 2 - v), Math.abs(w) < 1 / 1e3 && (w = 0), t.roundLengths && (w = Math.floor(w)), S % t.slidesPerGroup === 0 && f.push(w), p.push(w)) : (t.roundLengths && (w = Math.floor(w)), (S - Math.min(n.params.slidesPerGroupSkip, S)) % n.params.slidesPerGroup === 0 && f.push(w), p.push(w), w = w + A + v), n.virtualSize += A + v, x = A, S += 1 } } if (n.virtualSize = Math.max(n.virtualSize, s) + m, a && o && (t.effect === "slide" || t.effect === "coverflow") && (i.style.width = `${n.virtualSize + v}px`), t.setWrapperSize && (i.style[n.getDirectionLabel("width")] = `${n.virtualSize + v}px`), P && n.grid.updateWrapperSize(A, f), !t.centeredSlides) { const E = []; for (let O = 0; O < f.length; O += 1) { let C = f[O]; t.roundLengths && (C = Math.floor(C)), f[O] <= n.virtualSize - s && E.push(C) } f = E, Math.floor(n.virtualSize - s) - Math.floor(f[f.length - 1]) > 1 && f.push(n.virtualSize - s) } if (l && t.loop) { const E = g[0] + v; if (t.slidesPerGroup > 1) { const O = Math.ceil((n.virtual.slidesBefore + n.virtual.slidesAfter) / t.slidesPerGroup), C = E * t.slidesPerGroup; for (let k = 0; k < O; k += 1)f.push(f[f.length - 1] + C) } for (let O = 0; O < n.virtual.slidesBefore + n.virtual.slidesAfter; O += 1)t.slidesPerGroup === 1 && f.push(f[f.length - 1] + E), p.push(p[p.length - 1] + E), n.virtualSize += E } if (f.length === 0 && (f = [0]), v !== 0) { const E = n.isHorizontal() && a ? "marginLeft" : n.getDirectionLabel("marginRight"); d.filter((O, C) => !t.cssMode || t.loop ? !0 : C !== d.length - 1).forEach(O => { O.style[E] = `${v}px` }) } if (t.centeredSlides && t.centeredSlidesBounds) { let E = 0; g.forEach(C => { E += C + (v || 0) }), E -= v; const O = E - s; f = f.map(C => C <= 0 ? -h : C > O ? O + m : C) } if (t.centerInsufficientSlides) { let E = 0; if (g.forEach(O => { E += O + (v || 0) }), E -= v, E < s) { const O = (s - E) / 2; f.forEach((C, k) => { f[k] = C - O }), p.forEach((C, k) => { p[k] = C + O }) } } if (Object.assign(n, { slides: d, snapGrid: f, slidesGrid: p, slidesSizesGrid: g }), t.centeredSlides && t.cssMode && !t.centeredSlidesBounds) { ts(i, "--swiper-centered-offset-before", `${-f[0]}px`), ts(i, "--swiper-centered-offset-after", `${n.size / 2 - g[g.length - 1] / 2}px`); const E = -n.snapGrid[0], O = -n.slidesGrid[0]; n.snapGrid = n.snapGrid.map(C => C + E), n.slidesGrid = n.slidesGrid.map(C => C + O) } if (u !== c && n.emit("slidesLengthChange"), f.length !== y && (n.params.watchOverflow && n.checkOverflow(), n.emit("snapGridLengthChange")), p.length !== _ && n.emit("slidesGridLengthChange"), t.watchSlidesProgress && n.updateSlidesOffset(), n.emit("slidesUpdated"), !l && !t.cssMode && (t.effect === "slide" || t.effect === "fade")) { const E = `${t.containerModifierClass}backface-hidden`, O = n.el.classList.contains(E); u <= t.maxBackfaceHiddenSlides ? O || n.el.classList.add(E) : O && n.el.classList.remove(E) } } function wu(n) { const e = this, t = [], i = e.virtual && e.params.virtual.enabled; let r = 0, s; typeof n == "number" ? e.setTransition(n) : n === !0 && e.setTransition(e.params.speed); const a = o => i ? e.slides[e.getSlideIndexByData(o)] : e.slides[o]; if (e.params.slidesPerView !== "auto" && e.params.slidesPerView > 1) if (e.params.centeredSlides) (e.visibleSlides || []).forEach(o => { t.push(o) }); else for (s = 0; s < Math.ceil(e.params.slidesPerView); s += 1) { const o = e.activeIndex + s; if (o > e.slides.length && !i) break; t.push(a(o)) } else t.push(a(e.activeIndex)); for (s = 0; s < t.length; s += 1)if (typeof t[s] < "u") { const o = t[s].offsetHeight; r = o > r ? o : r } (r || r === 0) && (e.wrapperEl.style.height = `${r}px`) } function bu() { const n = this, e = n.slides, t = n.isElement ? n.isHorizontal() ? n.wrapperEl.offsetLeft : n.wrapperEl.offsetTop : 0; for (let i = 0; i < e.length; i += 1)e[i].swiperSlideOffset = (n.isHorizontal() ? e[i].offsetLeft : e[i].offsetTop) - t - n.cssOverflowAdjustment() } function xu(n) { n === void 0 && (n = this && this.translate || 0); const e = this, t = e.params, { slides: i, rtlTranslate: r, snapGrid: s } = e; if (i.length === 0) return; typeof i[0].swiperSlideOffset > "u" && e.updateSlidesOffset(); let a = -n; r && (a = n), i.forEach(l => { l.classList.remove(t.slideVisibleClass, t.slideFullyVisibleClass) }), e.visibleSlidesIndexes = [], e.visibleSlides = []; let o = t.spaceBetween; typeof o == "string" && o.indexOf("%") >= 0 ? o = parseFloat(o.replace("%", "")) / 100 * e.size : typeof o == "string" && (o = parseFloat(o)); for (let l = 0; l < i.length; l += 1) { const c = i[l]; let d = c.swiperSlideOffset; t.cssMode && t.centeredSlides && (d -= i[0].swiperSlideOffset); const u = (a + (t.centeredSlides ? e.minTranslate() : 0) - d) / (c.swiperSlideSize + o), f = (a - s[0] + (t.centeredSlides ? e.minTranslate() : 0) - d) / (c.swiperSlideSize + o), p = -(a - d), g = p + e.slidesSizesGrid[l], h = p >= 0 && p <= e.size - e.slidesSizesGrid[l]; (p >= 0 && p < e.size - 1 || g > 1 && g <= e.size || p <= 0 && g >= e.size) && (e.visibleSlides.push(c), e.visibleSlidesIndexes.push(l), i[l].classList.add(t.slideVisibleClass)), h && i[l].classList.add(t.slideFullyVisibleClass), c.progress = r ? -u : u, c.originalProgress = r ? -f : f } } function Su(n) { const e = this; if (typeof n > "u") { const d = e.rtlTranslate ? -1 : 1; n = e && e.translate && e.translate * d || 0 } const t = e.params, i = e.maxTranslate() - e.minTranslate(); let { progress: r, isBeginning: s, isEnd: a, progressLoop: o } = e; const l = s, c = a; if (i === 0) r = 0, s = !0, a = !0; else { r = (n - e.minTranslate()) / i; const d = Math.abs(n - e.minTranslate()) < 1, u = Math.abs(n - e.maxTranslate()) < 1; s = d || r <= 0, a = u || r >= 1, d && (r = 0), u && (r = 1) } if (t.loop) { const d = e.getSlideIndexByData(0), u = e.getSlideIndexByData(e.slides.length - 1), f = e.slidesGrid[d], p = e.slidesGrid[u], g = e.slidesGrid[e.slidesGrid.length - 1], h = Math.abs(n); h >= f ? o = (h - f) / g : o = (h + g - p) / g, o > 1 && (o -= 1) } Object.assign(e, { progress: r, progressLoop: o, isBeginning: s, isEnd: a }), (t.watchSlidesProgress || t.centeredSlides && t.autoHeight) && e.updateSlidesProgress(n), s && !l && e.emit("reachBeginning toEdge"), a && !c && e.emit("reachEnd toEdge"), (l && !s || c && !a) && e.emit("fromEdge"), e.emit("progress", r) } function Tu() { const n = this, { slides: e, params: t, slidesEl: i, activeIndex: r } = n, s = n.virtual && t.virtual.enabled, a = n.grid && t.grid && t.grid.rows > 1, o = u => We(i, `.${t.slideClass}${u}, swiper-slide${u}`)[0]; e.forEach(u => { u.classList.remove(t.slideActiveClass, t.slideNextClass, t.slidePrevClass) }); let l, c, d; if (s) if (t.loop) { let u = r - n.virtual.slidesBefore; u < 0 && (u = n.virtual.slides.length + u), u >= n.virtual.slides.length && (u -= n.virtual.slides.length), l = o(`[data-swiper-slide-index="${u}"]`) } else l = o(`[data-swiper-slide-index="${r}"]`); else a ? (l = e.filter(u => u.column === r)[0], d = e.filter(u => u.column === r + 1)[0], c = e.filter(u => u.column === r - 1)[0]) : l = e[r]; l && (l.classList.add(t.slideActiveClass), a ? (d && d.classList.add(t.slideNextClass), c && c.classList.add(t.slidePrevClass)) : (d = du(l, `.${t.slideClass}, swiper-slide`)[0], t.loop && !d && (d = e[0]), d && d.classList.add(t.slideNextClass), c = lu(l, `.${t.slideClass}, swiper-slide`)[0], t.loop && !c === 0 && (c = e[e.length - 1]), c && c.classList.add(t.slidePrevClass))), n.emitSlidesClasses() } const sn = (n, e) => { if (!n || n.destroyed || !n.params) return; const t = () => n.isElement ? "swiper-slide" : `.${n.params.slideClass}`, i = e.closest(t()); if (i) { let r = i.querySelector(`.${n.params.lazyPreloaderClass}`); !r && n.isElement && (i.shadowRoot ? r = i.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`) : requestAnimationFrame(() => { i.shadowRoot && (r = i.shadowRoot.querySelector(`.${n.params.lazyPreloaderClass}`), r && r.remove()) })), r && r.remove() } }, jn = (n, e) => { if (!n.slides[e]) return; const t = n.slides[e].querySelector('[loading="lazy"]'); t && t.removeAttribute("loading") }, Ta = n => { if (!n || n.destroyed || !n.params) return; let e = n.params.lazyPreloadPrevNext; const t = n.slides.length; if (!t || !e || e < 0) return; e = Math.min(e, t); const i = n.params.slidesPerView === "auto" ? n.slidesPerViewDynamic() : Math.ceil(n.params.slidesPerView), r = n.activeIndex; if (n.params.grid && n.params.grid.rows > 1) { const a = r, o = [a - e]; o.push(...Array.from({ length: e }).map((l, c) => a + i + c)), n.slides.forEach((l, c) => { o.includes(l.column) && jn(n, c) }); return } const s = r + i - 1; if (n.params.rewind || n.params.loop) for (let a = r - e; a <= s + e; a += 1) { const o = (a % t + t) % t; (o < r || o > s) && jn(n, o) } else for (let a = Math.max(r - e, 0); a <= Math.min(s + e, t - 1); a += 1)a !== r && (a > s || a < r) && jn(n, a) }; function Eu(n) { const { slidesGrid: e, params: t } = n, i = n.rtlTranslate ? n.translate : -n.translate; let r; for (let s = 0; s < e.length; s += 1)typeof e[s + 1] < "u" ? i >= e[s] && i < e[s + 1] - (e[s + 1] - e[s]) / 2 ? r = s : i >= e[s] && i < e[s + 1] && (r = s + 1) : i >= e[s] && (r = s); return t.normalizeSlideIndex && (r < 0 || typeof r > "u") && (r = 0), r } function Mu(n) { const e = this, t = e.rtlTranslate ? e.translate : -e.translate, { snapGrid: i, params: r, activeIndex: s, realIndex: a, snapIndex: o } = e; let l = n, c; const d = p => { let g = p - e.virtual.slidesBefore; return g < 0 && (g = e.virtual.slides.length + g), g >= e.virtual.slides.length && (g -= e.virtual.slides.length), g }; if (typeof l > "u" && (l = Eu(e)), i.indexOf(t) >= 0) c = i.indexOf(t); else { const p = Math.min(r.slidesPerGroupSkip, l); c = p + Math.floor((l - p) / r.slidesPerGroup) } if (c >= i.length && (c = i.length - 1), l === s && !e.params.loop) { c !== o && (e.snapIndex = c, e.emit("snapIndexChange")); return } if (l === s && e.params.loop && e.virtual && e.params.virtual.enabled) { e.realIndex = d(l); return } const u = e.grid && r.grid && r.grid.rows > 1; let f; if (e.virtual && r.virtual.enabled && r.loop) f = d(l); else if (u) { const p = e.slides.filter(h => h.column === l)[0]; let g = parseInt(p.getAttribute("data-swiper-slide-index"), 10); Number.isNaN(g) && (g = Math.max(e.slides.indexOf(p), 0)), f = Math.floor(g / r.grid.rows) } else if (e.slides[l]) { const p = e.slides[l].getAttribute("data-swiper-slide-index"); p ? f = parseInt(p, 10) : f = l } else f = l; Object.assign(e, { previousSnapIndex: o, snapIndex: c, previousRealIndex: a, realIndex: f, previousIndex: s, activeIndex: l }), e.initialized && Ta(e), e.emit("activeIndexChange"), e.emit("snapIndexChange"), (e.initialized || e.params.runCallbacksOnInit) && (a !== f && e.emit("realIndexChange"), e.emit("slideChange")) } function Cu(n, e) { const t = this, i = t.params; let r = n.closest(`.${i.slideClass}, swiper-slide`); !r && t.isElement && e && e.length > 1 && e.includes(n) && [...e.slice(e.indexOf(n) + 1, e.length)].forEach(o => { !r && o.matches && o.matches(`.${i.slideClass}, swiper-slide`) && (r = o) }); let s = !1, a; if (r) { for (let o = 0; o < t.slides.length; o += 1)if (t.slides[o] === r) { s = !0, a = o; break } } if (r && s) t.clickedSlide = r, t.virtual && t.params.virtual.enabled ? t.clickedIndex = parseInt(r.getAttribute("data-swiper-slide-index"), 10) : t.clickedIndex = a; else { t.clickedSlide = void 0, t.clickedIndex = void 0; return } i.slideToClickedSlide && t.clickedIndex !== void 0 && t.clickedIndex !== t.activeIndex && t.slideToClickedSlide() } var Pu = { updateSize: _u, updateSlides: yu, updateAutoHeight: wu, updateSlidesOffset: bu, updateSlidesProgress: xu, updateProgress: Su, updateSlidesClasses: Tu, updateActiveIndex: Mu, updateClickedSlide: Cu }; function Lu(n) { n === void 0 && (n = this.isHorizontal() ? "x" : "y"); const e = this, { params: t, rtlTranslate: i, translate: r, wrapperEl: s } = e; if (t.virtualTranslate) return i ? -r : r; if (t.cssMode) return r; let a = xa(s, n); return a += e.cssOverflowAdjustment(), i && (a = -a), a || 0 } function Au(n, e) { const t = this, { rtlTranslate: i, params: r, wrapperEl: s, progress: a } = t; let o = 0, l = 0; const c = 0; t.isHorizontal() ? o = i ? -n : n : l = n, r.roundLengths && (o = Math.floor(o), l = Math.floor(l)), t.previousTranslate = t.translate, t.translate = t.isHorizontal() ? o : l, r.cssMode ? s[t.isHorizontal() ? "scrollLeft" : "scrollTop"] = t.isHorizontal() ? -o : -l : r.virtualTranslate || (t.isHorizontal() ? o -= t.cssOverflowAdjustment() : l -= t.cssOverflowAdjustment(), s.style.transform = `translate3d(${o}px, ${l}px, ${c}px)`); let d; const u = t.maxTranslate() - t.minTranslate(); u === 0 ? d = 0 : d = (n - t.minTranslate()) / u, d !== a && t.updateProgress(n), t.emit("setTranslate", t.translate, e) } function ku() { return -this.snapGrid[0] } function Ou() { return -this.snapGrid[this.snapGrid.length - 1] } function Du(n, e, t, i, r) { n === void 0 && (n = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), i === void 0 && (i = !0); const s = this, { params: a, wrapperEl: o } = s; if (s.animating && a.preventInteractionOnTransition) return !1; const l = s.minTranslate(), c = s.maxTranslate(); let d; if (i && n > l ? d = l : i && n < c ? d = c : d = n, s.updateProgress(d), a.cssMode) { const u = s.isHorizontal(); if (e === 0) o[u ? "scrollLeft" : "scrollTop"] = -d; else { if (!s.support.smoothScroll) return pd({ swiper: s, targetPosition: -d, side: u ? "left" : "top" }), !0; o.scrollTo({ [u ? "left" : "top"]: -d, behavior: "smooth" }) } return !0 } return e === 0 ? (s.setTransition(0), s.setTranslate(d), t && (s.emit("beforeTransitionStart", e, r), s.emit("transitionEnd"))) : (s.setTransition(e), s.setTranslate(d), t && (s.emit("beforeTransitionStart", e, r), s.emit("transitionStart")), s.animating || (s.animating = !0, s.onTranslateToWrapperTransitionEnd || (s.onTranslateToWrapperTransitionEnd = function (f) { !s || s.destroyed || f.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onTranslateToWrapperTransitionEnd), s.onTranslateToWrapperTransitionEnd = null, delete s.onTranslateToWrapperTransitionEnd, t && s.emit("transitionEnd")) }), s.wrapperEl.addEventListener("transitionend", s.onTranslateToWrapperTransitionEnd))), !0 } var Iu = { getTranslate: Lu, setTranslate: Au, minTranslate: ku, maxTranslate: Ou, translateTo: Du }; function zu(n, e) { const t = this; t.params.cssMode || (t.wrapperEl.style.transitionDuration = `${n}ms`, t.wrapperEl.style.transitionDelay = n === 0 ? "0ms" : ""), t.emit("setTransition", n, e) } function md(n) { let { swiper: e, runCallbacks: t, direction: i, step: r } = n; const { activeIndex: s, previousIndex: a } = e; let o = i; if (o || (s > a ? o = "next" : s < a ? o = "prev" : o = "reset"), e.emit(`transition${r}`), t && s !== a) { if (o === "reset") { e.emit(`slideResetTransition${r}`); return } e.emit(`slideChangeTransition${r}`), o === "next" ? e.emit(`slideNextTransition${r}`) : e.emit(`slidePrevTransition${r}`) } } function Ru(n, e) { n === void 0 && (n = !0); const t = this, { params: i } = t; i.cssMode || (i.autoHeight && t.updateAutoHeight(), md({ swiper: t, runCallbacks: n, direction: e, step: "Start" })) } function $u(n, e) { n === void 0 && (n = !0); const t = this, { params: i } = t; t.animating = !1, !i.cssMode && (t.setTransition(0), md({ swiper: t, runCallbacks: n, direction: e, step: "End" })) } var Bu = { setTransition: zu, transitionStart: Ru, transitionEnd: $u }; function Fu(n, e, t, i, r) { n === void 0 && (n = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), typeof n == "string" && (n = parseInt(n, 10)); const s = this; let a = n; a < 0 && (a = 0); const { params: o, snapGrid: l, slidesGrid: c, previousIndex: d, activeIndex: u, rtlTranslate: f, wrapperEl: p, enabled: g } = s; if (s.animating && o.preventInteractionOnTransition || !g && !i && !r) return !1; const h = Math.min(s.params.slidesPerGroupSkip, a); let m = h + Math.floor((a - h) / s.params.slidesPerGroup); m >= l.length && (m = l.length - 1); const y = -l[m]; if (o.normalizeSlideIndex) for (let v = 0; v < c.length; v += 1) { const w = -Math.floor(y * 100), x = Math.floor(c[v] * 100), S = Math.floor(c[v + 1] * 100); typeof c[v + 1] < "u" ? w >= x && w < S - (S - x) / 2 ? a = v : w >= x && w < S && (a = v + 1) : w >= x && (a = v) } if (s.initialized && a !== u && (!s.allowSlideNext && (f ? y > s.translate && y > s.minTranslate() : y < s.translate && y < s.minTranslate()) || !s.allowSlidePrev && y > s.translate && y > s.maxTranslate() && (u || 0) !== a)) return !1; a !== (d || 0) && t && s.emit("beforeSlideChangeStart"), s.updateProgress(y); let _; if (a > u ? _ = "next" : a < u ? _ = "prev" : _ = "reset", f && -y === s.translate || !f && y === s.translate) return s.updateActiveIndex(a), o.autoHeight && s.updateAutoHeight(), s.updateSlidesClasses(), o.effect !== "slide" && s.setTranslate(y), _ !== "reset" && (s.transitionStart(t, _), s.transitionEnd(t, _)), !1; if (o.cssMode) { const v = s.isHorizontal(), w = f ? y : -y; if (e === 0) { const x = s.virtual && s.params.virtual.enabled; x && (s.wrapperEl.style.scrollSnapType = "none", s._immediateVirtual = !0), x && !s._cssModeVirtualInitialSet && s.params.initialSlide > 0 ? (s._cssModeVirtualInitialSet = !0, requestAnimationFrame(() => { p[v ? "scrollLeft" : "scrollTop"] = w })) : p[v ? "scrollLeft" : "scrollTop"] = w, x && requestAnimationFrame(() => { s.wrapperEl.style.scrollSnapType = "", s._immediateVirtual = !1 }) } else { if (!s.support.smoothScroll) return pd({ swiper: s, targetPosition: w, side: v ? "left" : "top" }), !0; p.scrollTo({ [v ? "left" : "top"]: w, behavior: "smooth" }) } return !0 } return s.setTransition(e), s.setTranslate(y), s.updateActiveIndex(a), s.updateSlidesClasses(), s.emit("beforeTransitionStart", e, i), s.transitionStart(t, _), e === 0 ? s.transitionEnd(t, _) : s.animating || (s.animating = !0, s.onSlideToWrapperTransitionEnd || (s.onSlideToWrapperTransitionEnd = function (w) { !s || s.destroyed || w.target === this && (s.wrapperEl.removeEventListener("transitionend", s.onSlideToWrapperTransitionEnd), s.onSlideToWrapperTransitionEnd = null, delete s.onSlideToWrapperTransitionEnd, s.transitionEnd(t, _)) }), s.wrapperEl.addEventListener("transitionend", s.onSlideToWrapperTransitionEnd)), !0 } function Nu(n, e, t, i) { n === void 0 && (n = 0), e === void 0 && (e = this.params.speed), t === void 0 && (t = !0), typeof n == "string" && (n = parseInt(n, 10)); const r = this, s = r.grid && r.params.grid && r.params.grid.rows > 1; let a = n; if (r.params.loop) if (r.virtual && r.params.virtual.enabled) a = a + r.virtual.slidesBefore; else { let o; if (s) { const f = a * r.params.grid.rows; o = r.slides.filter(p => p.getAttribute("data-swiper-slide-index") * 1 === f)[0].column } else o = r.getSlideIndexByData(a); const l = s ? Math.ceil(r.slides.length / r.params.grid.rows) : r.slides.length, { centeredSlides: c } = r.params; let d = r.params.slidesPerView; d === "auto" ? d = r.slidesPerViewDynamic() : (d = Math.ceil(parseFloat(r.params.slidesPerView, 10)), c && d % 2 === 0 && (d = d + 1)); let u = l - o < d; if (c && (u = u || o < Math.ceil(d / 2)), u) { const f = c ? o < r.activeIndex ? "prev" : "next" : o - r.activeIndex - 1 < r.params.slidesPerView ? "next" : "prev"; r.loopFix({ direction: f, slideTo: !0, activeSlideIndex: f === "next" ? o + 1 : o - l + 1, slideRealIndex: f === "next" ? r.realIndex : void 0 }) } if (s) { const f = a * r.params.grid.rows; a = r.slides.filter(p => p.getAttribute("data-swiper-slide-index") * 1 === f)[0].column } else a = r.getSlideIndexByData(a) } return requestAnimationFrame(() => { r.slideTo(a, e, t, i) }), r } function qu(n, e, t) { n === void 0 && (n = this.params.speed), e === void 0 && (e = !0); const i = this, { enabled: r, params: s, animating: a } = i; if (!r) return i; let o = s.slidesPerGroup; s.slidesPerView === "auto" && s.slidesPerGroup === 1 && s.slidesPerGroupAuto && (o = Math.max(i.slidesPerViewDynamic("current", !0), 1)); const l = i.activeIndex < s.slidesPerGroupSkip ? 1 : o, c = i.virtual && s.virtual.enabled; if (s.loop) { if (a && !c && s.loopPreventsSliding) return !1; if (i.loopFix({ direction: "next" }), i._clientLeft = i.wrapperEl.clientLeft, i.activeIndex === i.slides.length - 1 && s.cssMode) return requestAnimationFrame(() => { i.slideTo(i.activeIndex + l, n, e, t) }), !0 } return s.rewind && i.isEnd ? i.slideTo(0, n, e, t) : i.slideTo(i.activeIndex + l, n, e, t) } function Yu(n, e, t) { n === void 0 && (n = this.params.speed), e === void 0 && (e = !0); const i = this, { params: r, snapGrid: s, slidesGrid: a, rtlTranslate: o, enabled: l, animating: c } = i; if (!l) return i; const d = i.virtual && r.virtual.enabled; if (r.loop) { if (c && !d && r.loopPreventsSliding) return !1; i.loopFix({ direction: "prev" }), i._clientLeft = i.wrapperEl.clientLeft } const u = o ? i.translate : -i.translate; function f(y) { return y < 0 ? -Math.floor(Math.abs(y)) : Math.floor(y) } const p = f(u), g = s.map(y => f(y)); let h = s[g.indexOf(p) - 1]; if (typeof h > "u" && r.cssMode) { let y; s.forEach((_, v) => { p >= _ && (y = v) }), typeof y < "u" && (h = s[y > 0 ? y - 1 : y]) } let m = 0; if (typeof h < "u" && (m = a.indexOf(h), m < 0 && (m = i.activeIndex - 1), r.slidesPerView === "auto" && r.slidesPerGroup === 1 && r.slidesPerGroupAuto && (m = m - i.slidesPerViewDynamic("previous", !0) + 1, m = Math.max(m, 0))), r.rewind && i.isBeginning) { const y = i.params.virtual && i.params.virtual.enabled && i.virtual ? i.virtual.slides.length - 1 : i.slides.length - 1; return i.slideTo(y, n, e, t) } else if (r.loop && i.activeIndex === 0 && r.cssMode) return requestAnimationFrame(() => { i.slideTo(m, n, e, t) }), !0; return i.slideTo(m, n, e, t) } function Hu(n, e, t) { n === void 0 && (n = this.params.speed), e === void 0 && (e = !0); const i = this; return i.slideTo(i.activeIndex, n, e, t) } function Vu(n, e, t, i) { n === void 0 && (n = this.params.speed), e === void 0 && (e = !0), i === void 0 && (i = .5); const r = this; let s = r.activeIndex; const a = Math.min(r.params.slidesPerGroupSkip, s), o = a + Math.floor((s - a) / r.params.slidesPerGroup), l = r.rtlTranslate ? r.translate : -r.translate; if (l >= r.snapGrid[o]) { const c = r.snapGrid[o], d = r.snapGrid[o + 1]; l - c > (d - c) * i && (s += r.params.slidesPerGroup) } else { const c = r.snapGrid[o - 1], d = r.snapGrid[o]; l - c <= (d - c) * i && (s -= r.params.slidesPerGroup) } return s = Math.max(s, 0), s = Math.min(s, r.slidesGrid.length - 1), r.slideTo(s, n, e, t) } function Gu() { const n = this, { params: e, slidesEl: t } = n, i = e.slidesPerView === "auto" ? n.slidesPerViewDynamic() : e.slidesPerView; let r = n.clickedIndex, s; const a = n.isElement ? "swiper-slide" : `.${e.slideClass}`; if (e.loop) { if (n.animating) return; s = parseInt(n.clickedSlide.getAttribute("data-swiper-slide-index"), 10), e.centeredSlides ? r < n.loopedSlides - i / 2 || r > n.slides.length - n.loopedSlides + i / 2 ? (n.loopFix(), r = n.getSlideIndex(We(t, `${a}[data-swiper-slide-index="${s}"]`)[0]), pr(() => { n.slideTo(r) })) : n.slideTo(r) : r > n.slides.length - i ? (n.loopFix(), r = n.getSlideIndex(We(t, `${a}[data-swiper-slide-index="${s}"]`)[0]), pr(() => { n.slideTo(r) })) : n.slideTo(r) } else n.slideTo(r) } var Xu = { slideTo: Fu, slideToLoop: Nu, slideNext: qu, slidePrev: Yu, slideReset: Hu, slideToClosest: Vu, slideToClickedSlide: Gu }; function Wu(n) { const e = this, { params: t, slidesEl: i } = e; if (!t.loop || e.virtual && e.params.virtual.enabled) return; const r = () => { We(i, `.${t.slideClass}, swiper-slide`).forEach((u, f) => { u.setAttribute("data-swiper-slide-index", f) }) }, s = e.grid && t.grid && t.grid.rows > 1, a = t.slidesPerGroup * (s ? t.grid.rows : 1), o = e.slides.length % a !== 0, l = s && e.slides.length % t.grid.rows !== 0, c = d => { for (let u = 0; u < d; u += 1) { const f = e.isElement ? Lt("swiper-slide", [t.slideBlankClass]) : Lt("div", [t.slideClass, t.slideBlankClass]); e.slidesEl.append(f) } }; if (o) { if (t.loopAddBlankSlides) { const d = a - e.slides.length % a; c(d), e.recalcSlides(), e.updateSlides() } else gn("Swiper Loop Warning: The number of slides is not even to slidesPerGroup, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); r() } else if (l) { if (t.loopAddBlankSlides) { const d = t.grid.rows - e.slides.length % t.grid.rows; c(d), e.recalcSlides(), e.updateSlides() } else gn("Swiper Loop Warning: The number of slides is not even to grid.rows, loop mode may not function properly. You need to add more slides (or make duplicates, or empty slides)"); r() } else r(); e.loopFix({ slideRealIndex: n, direction: t.centeredSlides ? void 0 : "next" }) } function ju(n) { let { slideRealIndex: e, slideTo: t = !0, direction: i, setTranslate: r, activeSlideIndex: s, byController: a, byMousewheel: o } = n === void 0 ? {} : n; const l = this; if (!l.params.loop) return; l.emit("beforeLoopFix"); const { slides: c, allowSlidePrev: d, allowSlideNext: u, slidesEl: f, params: p } = l, { centeredSlides: g } = p; if (l.allowSlidePrev = !0, l.allowSlideNext = !0, l.virtual && p.virtual.enabled) { t && (!p.centeredSlides && l.snapIndex === 0 ? l.slideTo(l.virtual.slides.length, 0, !1, !0) : p.centeredSlides && l.snapIndex < p.slidesPerView ? l.slideTo(l.virtual.slides.length + l.snapIndex, 0, !1, !0) : l.snapIndex === l.snapGrid.length - 1 && l.slideTo(l.virtual.slidesBefore, 0, !1, !0)), l.allowSlidePrev = d, l.allowSlideNext = u, l.emit("loopFix"); return } let h = p.slidesPerView; h === "auto" ? h = l.slidesPerViewDynamic() : (h = Math.ceil(parseFloat(p.slidesPerView, 10)), g && h % 2 === 0 && (h = h + 1)); const m = p.slidesPerGroupAuto ? h : p.slidesPerGroup; let y = m; y % m !== 0 && (y += m - y % m), y += p.loopAdditionalSlides, l.loopedSlides = y; const _ = l.grid && p.grid && p.grid.rows > 1; c.length < h + y ? gn("Swiper Loop Warning: The number of slides is not enough for loop mode, it will be disabled and not function properly. You need to add more slides (or make duplicates) or lower the values of slidesPerView and slidesPerGroup parameters") : _ && p.grid.fill === "row" && gn("Swiper Loop Warning: Loop mode is not compatible with grid.fill = `row`"); const v = [], w = []; let x = l.activeIndex; typeof s > "u" ? s = l.getSlideIndex(c.filter(k => k.classList.contains(p.slideActiveClass))[0]) : x = s; const S = i === "next" || !i, P = i === "prev" || !i; let A = 0, M = 0; const E = _ ? Math.ceil(c.length / p.grid.rows) : c.length, C = (_ ? c[s].column : s) + (g && typeof r > "u" ? -h / 2 + .5 : 0); if (C < y) { A = Math.max(y - C, m); for (let k = 0; k < y - C; k += 1) { const b = k - Math.floor(k / E) * E; if (_) { const L = E - b - 1; for (let z = c.length - 1; z >= 0; z -= 1)c[z].column === L && v.push(z) } else v.push(E - b - 1) } } else if (C + h > E - y) { M = Math.max(C - (E - y * 2), m); for (let k = 0; k < M; k += 1) { const b = k - Math.floor(k / E) * E; _ ? c.forEach((L, z) => { L.column === b && w.push(z) }) : w.push(b) } } if (l.__preventObserver__ = !0, requestAnimationFrame(() => { l.__preventObserver__ = !1 }), P && v.forEach(k => { c[k].swiperLoopMoveDOM = !0, f.prepend(c[k]), c[k].swiperLoopMoveDOM = !1 }), S && w.forEach(k => { c[k].swiperLoopMoveDOM = !0, f.append(c[k]), c[k].swiperLoopMoveDOM = !1 }), l.recalcSlides(), p.slidesPerView === "auto" ? l.updateSlides() : _ && (v.length > 0 && P || w.length > 0 && S) && l.slides.forEach((k, b) => { l.grid.updateSlide(b, k, l.slides) }), p.watchSlidesProgress && l.updateSlidesOffset(), t) { if (v.length > 0 && P) { if (typeof e > "u") { const k = l.slidesGrid[x], L = l.slidesGrid[x + A] - k; o ? l.setTranslate(l.translate - L) : (l.slideTo(x + A, 0, !1, !0), r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - L, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - L)) } else if (r) { const k = _ ? v.length / p.grid.rows : v.length; l.slideTo(l.activeIndex + k, 0, !1, !0), l.touchEventsData.currentTranslate = l.translate } } else if (w.length > 0 && S) if (typeof e > "u") { const k = l.slidesGrid[x], L = l.slidesGrid[x - M] - k; o ? l.setTranslate(l.translate - L) : (l.slideTo(x - M, 0, !1, !0), r && (l.touchEventsData.startTranslate = l.touchEventsData.startTranslate - L, l.touchEventsData.currentTranslate = l.touchEventsData.currentTranslate - L)) } else { const k = _ ? w.length / p.grid.rows : w.length; l.slideTo(l.activeIndex - k, 0, !1, !0) } } if (l.allowSlidePrev = d, l.allowSlideNext = u, l.controller && l.controller.control && !a) { const k = { slideRealIndex: e, direction: i, setTranslate: r, activeSlideIndex: s, byController: !0 }; Array.isArray(l.controller.control) ? l.controller.control.forEach(b => { !b.destroyed && b.params.loop && b.loopFix({ ...k, slideTo: b.params.slidesPerView === p.slidesPerView ? t : !1 }) }) : l.controller.control instanceof l.constructor && l.controller.control.params.loop && l.controller.control.loopFix({ ...k, slideTo: l.controller.control.params.slidesPerView === p.slidesPerView ? t : !1 }) } l.emit("loopFix") } function Uu() { const n = this, { params: e, slidesEl: t } = n; if (!e.loop || n.virtual && n.params.virtual.enabled) return; n.recalcSlides(); const i = []; n.slides.forEach(r => { const s = typeof r.swiperSlideIndex > "u" ? r.getAttribute("data-swiper-slide-index") * 1 : r.swiperSlideIndex; i[s] = r }), n.slides.forEach(r => { r.removeAttribute("data-swiper-slide-index") }), i.forEach(r => { t.append(r) }), n.recalcSlides(), n.slideTo(n.realIndex, 0) } var Ku = { loopCreate: Wu, loopFix: ju, loopDestroy: Uu }; function Zu(n) { const e = this; if (!e.params.simulateTouch || e.params.watchOverflow && e.isLocked || e.params.cssMode) return; const t = e.params.touchEventsTarget === "container" ? e.el : e.wrapperEl; e.isElement && (e.__preventObserver__ = !0), t.style.cursor = "move", t.style.cursor = n ? "grabbing" : "grab", e.isElement && requestAnimationFrame(() => { e.__preventObserver__ = !1 }) } function Qu() { const n = this; n.params.watchOverflow && n.isLocked || n.params.cssMode || (n.isElement && (n.__preventObserver__ = !0), n[n.params.touchEventsTarget === "container" ? "el" : "wrapperEl"].style.cursor = "", n.isElement && requestAnimationFrame(() => { n.__preventObserver__ = !1 })) } var Ju = { setGrabCursor: Zu, unsetGrabCursor: Qu }; function ef(n, e) { e === void 0 && (e = this); function t(i) { if (!i || i === ft() || i === ye()) return null; i.assignedSlot && (i = i.assignedSlot); const r = i.closest(n); return !r && !i.getRootNode ? null : r || t(i.getRootNode().host) } return t(e) } function Ro(n, e, t) { const i = ye(), { params: r } = n, s = r.edgeSwipeDetection, a = r.edgeSwipeThreshold; return s && (t <= a || t >= i.innerWidth - a) ? s === "prevent" ? (e.preventDefault(), !0) : !1 : !0 } function tf(n) { const e = this, t = ft(); let i = n; i.originalEvent && (i = i.originalEvent); const r = e.touchEventsData; if (i.type === "pointerdown") { if (r.pointerId !== null && r.pointerId !== i.pointerId) return; r.pointerId = i.pointerId } else i.type === "touchstart" && i.targetTouches.length === 1 && (r.touchId = i.targetTouches[0].identifier); if (i.type === "touchstart") { Ro(e, i, i.targetTouches[0].pageX); return } const { params: s, touches: a, enabled: o } = e; if (!o || !s.simulateTouch && i.pointerType === "mouse" || e.animating && s.preventInteractionOnTransition) return; !e.animating && s.cssMode && s.loop && e.loopFix(); let l = i.target; if (s.touchEventsTarget === "wrapper" && !e.wrapperEl.contains(l) || "which" in i && i.which === 3 || "button" in i && i.button > 0 || r.isTouched && r.isMoved) return; const c = !!s.noSwipingClass && s.noSwipingClass !== "", d = i.composedPath ? i.composedPath() : i.path; c && i.target && i.target.shadowRoot && d && (l = d[0]); const u = s.noSwipingSelector ? s.noSwipingSelector : `.${s.noSwipingClass}`, f = !!(i.target && i.target.shadowRoot); if (s.noSwiping && (f ? ef(u, l) : l.closest(u))) { e.allowClick = !0; return } if (s.swipeHandler && !l.closest(s.swipeHandler)) return; a.currentX = i.pageX, a.currentY = i.pageY; const p = a.currentX, g = a.currentY; if (!Ro(e, i, p)) return; Object.assign(r, { isTouched: !0, isMoved: !1, allowTouchCallbacks: !0, isScrolling: void 0, startMoving: void 0 }), a.startX = p, a.startY = g, r.touchStartTime = Rt(), e.allowClick = !0, e.updateSize(), e.swipeDirection = void 0, s.threshold > 0 && (r.allowThresholdMove = !1); let h = !0; l.matches(r.focusableElements) && (h = !1, l.nodeName === "SELECT" && (r.isTouched = !1)), t.activeElement && t.activeElement.matches(r.focusableElements) && t.activeElement !== l && t.activeElement.blur(); const m = h && e.allowTouchMove && s.touchStartPreventDefault; (s.touchStartForcePreventDefault || m) && !l.isContentEditable && i.preventDefault(), s.freeMode && s.freeMode.enabled && e.freeMode && e.animating && !s.cssMode && e.freeMode.onTouchStart(), e.emit("touchStart", i) } function rf(n) { const e = ft(), t = this, i = t.touchEventsData, { params: r, touches: s, rtlTranslate: a, enabled: o } = t; if (!o || !r.simulateTouch && n.pointerType === "mouse") return; let l = n; if (l.originalEvent && (l = l.originalEvent), l.type === "pointermove" && (i.touchId !== null || l.pointerId !== i.pointerId)) return; let c; if (l.type === "touchmove") { if (c = [...l.changedTouches].filter(S => S.identifier === i.touchId)[0], !c || c.identifier !== i.touchId) return } else c = l; if (!i.isTouched) { i.startMoving && i.isScrolling && t.emit("touchMoveOpposite", l); return } const d = c.pageX, u = c.pageY; if (l.preventedByNestedSwiper) { s.startX = d, s.startY = u; return } if (!t.allowTouchMove) { l.target.matches(i.focusableElements) || (t.allowClick = !1), i.isTouched && (Object.assign(s, { startX: d, startY: u, currentX: d, currentY: u }), i.touchStartTime = Rt()); return } if (r.touchReleaseOnEdges && !r.loop) { if (t.isVertical()) { if (u < s.startY && t.translate <= t.maxTranslate() || u > s.startY && t.translate >= t.minTranslate()) { i.isTouched = !1, i.isMoved = !1; return } } else if (d < s.startX && t.translate <= t.maxTranslate() || d > s.startX && t.translate >= t.minTranslate()) return } if (e.activeElement && l.target === e.activeElement && l.target.matches(i.focusableElements)) { i.isMoved = !0, t.allowClick = !1; return } i.allowTouchCallbacks && t.emit("touchMove", l), s.previousX = s.currentX, s.previousY = s.currentY, s.currentX = d, s.currentY = u; const f = s.currentX - s.startX, p = s.currentY - s.startY; if (t.params.threshold && Math.sqrt(f ** 2 + p ** 2) < t.params.threshold) return; if (typeof i.isScrolling > "u") { let S; t.isHorizontal() && s.currentY === s.startY || t.isVertical() && s.currentX === s.startX ? i.isScrolling = !1 : f * f + p * p >= 25 && (S = Math.atan2(Math.abs(p), Math.abs(f)) * 180 / Math.PI, i.isScrolling = t.isHorizontal() ? S > r.touchAngle : 90 - S > r.touchAngle) } if (i.isScrolling && t.emit("touchMoveOpposite", l), typeof i.startMoving > "u" && (s.currentX !== s.startX || s.currentY !== s.startY) && (i.startMoving = !0), i.isScrolling) { i.isTouched = !1; return } if (!i.startMoving) return; t.allowClick = !1, !r.cssMode && l.cancelable && l.preventDefault(), r.touchMoveStopPropagation && !r.nested && l.stopPropagation(); let g = t.isHorizontal() ? f : p, h = t.isHorizontal() ? s.currentX - s.previousX : s.currentY - s.previousY; r.oneWayMovement && (g = Math.abs(g) * (a ? 1 : -1), h = Math.abs(h) * (a ? 1 : -1)), s.diff = g, g *= r.touchRatio, a && (g = -g, h = -h); const m = t.touchesDirection; t.swipeDirection = g > 0 ? "prev" : "next", t.touchesDirection = h > 0 ? "prev" : "next"; const y = t.params.loop && !r.cssMode, _ = t.touchesDirection === "next" && t.allowSlideNext || t.touchesDirection === "prev" && t.allowSlidePrev; if (!i.isMoved) { if (y && _ && t.loopFix({ direction: t.swipeDirection }), i.startTranslate = t.getTranslate(), t.setTransition(0), t.animating) { const S = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); t.wrapperEl.dispatchEvent(S) } i.allowMomentumBounce = !1, r.grabCursor && (t.allowSlideNext === !0 || t.allowSlidePrev === !0) && t.setGrabCursor(!0), t.emit("sliderFirstMove", l) } let v; if (new Date().getTime(), i.isMoved && i.allowThresholdMove && m !== t.touchesDirection && y && _ && Math.abs(g) >= 1) { Object.assign(s, { startX: d, startY: u, currentX: d, currentY: u, startTranslate: i.currentTranslate }), i.loopSwapReset = !0, i.startTranslate = i.currentTranslate; return } t.emit("sliderMove", l), i.isMoved = !0, i.currentTranslate = g + i.startTranslate; let w = !0, x = r.resistanceRatio; if (r.touchReleaseOnEdges && (x = 0), g > 0 ? (y && _ && !v && i.allowThresholdMove && i.currentTranslate > (r.centeredSlides ? t.minTranslate() - t.slidesSizesGrid[t.activeIndex + 1] : t.minTranslate()) && t.loopFix({ direction: "prev", setTranslate: !0, activeSlideIndex: 0 }), i.currentTranslate > t.minTranslate() && (w = !1, r.resistance && (i.currentTranslate = t.minTranslate() - 1 + (-t.minTranslate() + i.startTranslate + g) ** x))) : g < 0 && (y && _ && !v && i.allowThresholdMove && i.currentTranslate < (r.centeredSlides ? t.maxTranslate() + t.slidesSizesGrid[t.slidesSizesGrid.length - 1] : t.maxTranslate()) && t.loopFix({ direction: "next", setTranslate: !0, activeSlideIndex: t.slides.length - (r.slidesPerView === "auto" ? t.slidesPerViewDynamic() : Math.ceil(parseFloat(r.slidesPerView, 10))) }), i.currentTranslate < t.maxTranslate() && (w = !1, r.resistance && (i.currentTranslate = t.maxTranslate() + 1 - (t.maxTranslate() - i.startTranslate - g) ** x))), w && (l.preventedByNestedSwiper = !0), !t.allowSlideNext && t.swipeDirection === "next" && i.currentTranslate < i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && t.swipeDirection === "prev" && i.currentTranslate > i.startTranslate && (i.currentTranslate = i.startTranslate), !t.allowSlidePrev && !t.allowSlideNext && (i.currentTranslate = i.startTranslate), r.threshold > 0) if (Math.abs(g) > r.threshold || i.allowThresholdMove) { if (!i.allowThresholdMove) { i.allowThresholdMove = !0, s.startX = s.currentX, s.startY = s.currentY, i.currentTranslate = i.startTranslate, s.diff = t.isHorizontal() ? s.currentX - s.startX : s.currentY - s.startY; return } } else { i.currentTranslate = i.startTranslate; return } !r.followFinger || r.cssMode || ((r.freeMode && r.freeMode.enabled && t.freeMode || r.watchSlidesProgress) && (t.updateActiveIndex(), t.updateSlidesClasses()), r.freeMode && r.freeMode.enabled && t.freeMode && t.freeMode.onTouchMove(), t.updateProgress(i.currentTranslate), t.setTranslate(i.currentTranslate)) } function sf(n) { const e = this, t = e.touchEventsData; let i = n; i.originalEvent && (i = i.originalEvent); let r; if (i.type === "touchend" || i.type === "touchcancel") { if (r = [...i.changedTouches].filter(x => x.identifier === t.touchId)[0], !r || r.identifier !== t.touchId) return } else { if (t.touchId !== null || i.pointerId !== t.pointerId) return; r = i } if (["pointercancel", "pointerout", "pointerleave", "contextmenu"].includes(i.type) && !(["pointercancel", "contextmenu"].includes(i.type) && (e.browser.isSafari || e.browser.isWebView))) return; t.pointerId = null, t.touchId = null; const { params: a, touches: o, rtlTranslate: l, slidesGrid: c, enabled: d } = e; if (!d || !a.simulateTouch && i.pointerType === "mouse") return; if (t.allowTouchCallbacks && e.emit("touchEnd", i), t.allowTouchCallbacks = !1, !t.isTouched) { t.isMoved && a.grabCursor && e.setGrabCursor(!1), t.isMoved = !1, t.startMoving = !1; return } a.grabCursor && t.isMoved && t.isTouched && (e.allowSlideNext === !0 || e.allowSlidePrev === !0) && e.setGrabCursor(!1); const u = Rt(), f = u - t.touchStartTime; if (e.allowClick) { const x = i.path || i.composedPath && i.composedPath(); e.updateClickedSlide(x && x[0] || i.target, x), e.emit("tap click", i), f < 300 && u - t.lastClickTime < 300 && e.emit("doubleTap doubleClick", i) } if (t.lastClickTime = Rt(), pr(() => { e.destroyed || (e.allowClick = !0) }), !t.isTouched || !t.isMoved || !e.swipeDirection || o.diff === 0 && !t.loopSwapReset || t.currentTranslate === t.startTranslate && !t.loopSwapReset) { t.isTouched = !1, t.isMoved = !1, t.startMoving = !1; return } t.isTouched = !1, t.isMoved = !1, t.startMoving = !1; let p; if (a.followFinger ? p = l ? e.translate : -e.translate : p = -t.currentTranslate, a.cssMode) return; if (a.freeMode && a.freeMode.enabled) { e.freeMode.onTouchEnd({ currentPos: p }); return } const g = p >= -e.maxTranslate() && !e.params.loop; let h = 0, m = e.slidesSizesGrid[0]; for (let x = 0; x < c.length; x += x < a.slidesPerGroupSkip ? 1 : a.slidesPerGroup) { const S = x < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; typeof c[x + S] < "u" ? (g || p >= c[x] && p < c[x + S]) && (h = x, m = c[x + S] - c[x]) : (g || p >= c[x]) && (h = x, m = c[c.length - 1] - c[c.length - 2]) } let y = null, _ = null; a.rewind && (e.isBeginning ? _ = a.virtual && a.virtual.enabled && e.virtual ? e.virtual.slides.length - 1 : e.slides.length - 1 : e.isEnd && (y = 0)); const v = (p - c[h]) / m, w = h < a.slidesPerGroupSkip - 1 ? 1 : a.slidesPerGroup; if (f > a.longSwipesMs) { if (!a.longSwipes) { e.slideTo(e.activeIndex); return } e.swipeDirection === "next" && (v >= a.longSwipesRatio ? e.slideTo(a.rewind && e.isEnd ? y : h + w) : e.slideTo(h)), e.swipeDirection === "prev" && (v > 1 - a.longSwipesRatio ? e.slideTo(h + w) : _ !== null && v < 0 && Math.abs(v) > a.longSwipesRatio ? e.slideTo(_) : e.slideTo(h)) } else { if (!a.shortSwipes) { e.slideTo(e.activeIndex); return } e.navigation && (i.target === e.navigation.nextEl || i.target === e.navigation.prevEl) ? i.target === e.navigation.nextEl ? e.slideTo(h + w) : e.slideTo(h) : (e.swipeDirection === "next" && e.slideTo(y !== null ? y : h + w), e.swipeDirection === "prev" && e.slideTo(_ !== null ? _ : h)) } } function $o() { const n = this, { params: e, el: t } = n; if (t && t.offsetWidth === 0) return; e.breakpoints && n.setBreakpoint(); const { allowSlideNext: i, allowSlidePrev: r, snapGrid: s } = n, a = n.virtual && n.params.virtual.enabled; n.allowSlideNext = !0, n.allowSlidePrev = !0, n.updateSize(), n.updateSlides(), n.updateSlidesClasses(); const o = a && e.loop; (e.slidesPerView === "auto" || e.slidesPerView > 1) && n.isEnd && !n.isBeginning && !n.params.centeredSlides && !o ? n.slideTo(n.slides.length - 1, 0, !1, !0) : n.params.loop && !a ? n.slideToLoop(n.realIndex, 0, !1, !0) : n.slideTo(n.activeIndex, 0, !1, !0), n.autoplay && n.autoplay.running && n.autoplay.paused && (clearTimeout(n.autoplay.resizeTimeout), n.autoplay.resizeTimeout = setTimeout(() => { n.autoplay && n.autoplay.running && n.autoplay.paused && n.autoplay.resume() }, 500)), n.allowSlidePrev = r, n.allowSlideNext = i, n.params.watchOverflow && s !== n.snapGrid && n.checkOverflow() } function nf(n) { const e = this; e.enabled && (e.allowClick || (e.params.preventClicks && n.preventDefault(), e.params.preventClicksPropagation && e.animating && (n.stopPropagation(), n.stopImmediatePropagation()))) } function af() { const n = this, { wrapperEl: e, rtlTranslate: t, enabled: i } = n; if (!i) return; n.previousTranslate = n.translate, n.isHorizontal() ? n.translate = -e.scrollLeft : n.translate = -e.scrollTop, n.translate === 0 && (n.translate = 0), n.updateActiveIndex(), n.updateSlidesClasses(); let r; const s = n.maxTranslate() - n.minTranslate(); s === 0 ? r = 0 : r = (n.translate - n.minTranslate()) / s, r !== n.progress && n.updateProgress(t ? -n.translate : n.translate), n.emit("setTranslate", n.translate, !1) } function of(n) { const e = this; sn(e, n.target), !(e.params.cssMode || e.params.slidesPerView !== "auto" && !e.params.autoHeight) && e.update() } function lf() { const n = this; n.documentTouchHandlerProceeded || (n.documentTouchHandlerProceeded = !0, n.params.touchReleaseOnEdges && (n.el.style.touchAction = "auto")) } const gd = (n, e) => { const t = ft(), { params: i, el: r, wrapperEl: s, device: a } = n, o = !!i.nested, l = e === "on" ? "addEventListener" : "removeEventListener", c = e; t[l]("touchstart", n.onDocumentTouchStart, { passive: !1, capture: o }), r[l]("touchstart", n.onTouchStart, { passive: !1 }), r[l]("pointerdown", n.onTouchStart, { passive: !1 }), t[l]("touchmove", n.onTouchMove, { passive: !1, capture: o }), t[l]("pointermove", n.onTouchMove, { passive: !1, capture: o }), t[l]("touchend", n.onTouchEnd, { passive: !0 }), t[l]("pointerup", n.onTouchEnd, { passive: !0 }), t[l]("pointercancel", n.onTouchEnd, { passive: !0 }), t[l]("touchcancel", n.onTouchEnd, { passive: !0 }), t[l]("pointerout", n.onTouchEnd, { passive: !0 }), t[l]("pointerleave", n.onTouchEnd, { passive: !0 }), t[l]("contextmenu", n.onTouchEnd, { passive: !0 }), (i.preventClicks || i.preventClicksPropagation) && r[l]("click", n.onClick, !0), i.cssMode && s[l]("scroll", n.onScroll), i.updateOnWindowResize ? n[c](a.ios || a.android ? "resize orientationchange observerUpdate" : "resize observerUpdate", $o, !0) : n[c]("observerUpdate", $o, !0), r[l]("load", n.onLoad, { capture: !0 }) }; function df() { const n = this, { params: e } = n; n.onTouchStart = tf.bind(n), n.onTouchMove = rf.bind(n), n.onTouchEnd = sf.bind(n), n.onDocumentTouchStart = lf.bind(n), e.cssMode && (n.onScroll = af.bind(n)), n.onClick = nf.bind(n), n.onLoad = of.bind(n), gd(n, "on") } function cf() { gd(this, "off") } var uf = { attachEvents: df, detachEvents: cf }; const Bo = (n, e) => n.grid && e.grid && e.grid.rows > 1; function ff() { const n = this, { realIndex: e, initialized: t, params: i, el: r } = n, s = i.breakpoints; if (!s || s && Object.keys(s).length === 0) return; const a = n.getBreakpoint(s, n.params.breakpointsBase, n.el); if (!a || n.currentBreakpoint === a) return; const l = (a in s ? s[a] : void 0) || n.originalParams, c = Bo(n, i), d = Bo(n, l), u = i.enabled; c && !d ? (r.classList.remove(`${i.containerModifierClass}grid`, `${i.containerModifierClass}grid-column`), n.emitContainerClasses()) : !c && d && (r.classList.add(`${i.containerModifierClass}grid`), (l.grid.fill && l.grid.fill === "column" || !l.grid.fill && i.grid.fill === "column") && r.classList.add(`${i.containerModifierClass}grid-column`), n.emitContainerClasses()), ["navigation", "pagination", "scrollbar"].forEach(y => { if (typeof l[y] > "u") return; const _ = i[y] && i[y].enabled, v = l[y] && l[y].enabled; _ && !v && n[y].disable(), !_ && v && n[y].enable() }); const f = l.direction && l.direction !== i.direction, p = i.loop && (l.slidesPerView !== i.slidesPerView || f), g = i.loop; f && t && n.changeDirection(), Et(n.params, l); const h = n.params.enabled, m = n.params.loop; Object.assign(n, { allowTouchMove: n.params.allowTouchMove, allowSlideNext: n.params.allowSlideNext, allowSlidePrev: n.params.allowSlidePrev }), u && !h ? n.disable() : !u && h && n.enable(), n.currentBreakpoint = a, n.emit("_beforeBreakpoint", l), t && (p ? (n.loopDestroy(), n.loopCreate(e), n.updateSlides()) : !g && m ? (n.loopCreate(e), n.updateSlides()) : g && !m && n.loopDestroy()), n.emit("breakpoint", l) } function pf(n, e, t) { if (e === void 0 && (e = "window"), !n || e === "container" && !t) return; let i = !1; const r = ye(), s = e === "window" ? r.innerHeight : t.clientHeight, a = Object.keys(n).map(o => { if (typeof o == "string" && o.indexOf("@") === 0) { const l = parseFloat(o.substr(1)); return { value: s * l, point: o } } return { value: o, point: o } }); a.sort((o, l) => parseInt(o.value, 10) - parseInt(l.value, 10)); for (let o = 0; o < a.length; o += 1) { const { point: l, value: c } = a[o]; e === "window" ? r.matchMedia(`(min-width: ${c}px)`).matches && (i = l) : c <= t.clientWidth && (i = l) } return i || "max" } var hf = { setBreakpoint: ff, getBreakpoint: pf }; function mf(n, e) { const t = []; return n.forEach(i => { typeof i == "object" ? Object.keys(i).forEach(r => { i[r] && t.push(e + r) }) : typeof i == "string" && t.push(e + i) }), t } function gf() { const n = this, { classNames: e, params: t, rtl: i, el: r, device: s } = n, a = mf(["initialized", t.direction, { "free-mode": n.params.freeMode && t.freeMode.enabled }, { autoheight: t.autoHeight }, { rtl: i }, { grid: t.grid && t.grid.rows > 1 }, { "grid-column": t.grid && t.grid.rows > 1 && t.grid.fill === "column" }, { android: s.android }, { ios: s.ios }, { "css-mode": t.cssMode }, { centered: t.cssMode && t.centeredSlides }, { "watch-progress": t.watchSlidesProgress }], t.containerModifierClass); e.push(...a), r.classList.add(...e), n.emitContainerClasses() } function vf() { const n = this, { el: e, classNames: t } = n; e.classList.remove(...t), n.emitContainerClasses() } var _f = { addClasses: gf, removeClasses: vf }; function yf() { const n = this, { isLocked: e, params: t } = n, { slidesOffsetBefore: i } = t; if (i) { const r = n.slides.length - 1, s = n.slidesGrid[r] + n.slidesSizesGrid[r] + i * 2; n.isLocked = n.size > s } else n.isLocked = n.snapGrid.length === 1; t.allowSlideNext === !0 && (n.allowSlideNext = !n.isLocked), t.allowSlidePrev === !0 && (n.allowSlidePrev = !n.isLocked), e && e !== n.isLocked && (n.isEnd = !1), e !== n.isLocked && n.emit(n.isLocked ? "lock" : "unlock") } var wf = { checkOverflow: yf }, Fo = { init: !0, direction: "horizontal", oneWayMovement: !1, touchEventsTarget: "wrapper", initialSlide: 0, speed: 300, cssMode: !1, updateOnWindowResize: !0, resizeObserver: !0, nested: !1, createElements: !1, eventsPrefix: "swiper", enabled: !0, focusableElements: "input, select, option, textarea, button, video, label", width: null, height: null, preventInteractionOnTransition: !1, userAgent: null, url: null, edgeSwipeDetection: !1, edgeSwipeThreshold: 20, autoHeight: !1, setWrapperSize: !1, virtualTranslate: !1, effect: "slide", breakpoints: void 0, breakpointsBase: "window", spaceBetween: 0, slidesPerView: 1, slidesPerGroup: 1, slidesPerGroupSkip: 0, slidesPerGroupAuto: !1, centeredSlides: !1, centeredSlidesBounds: !1, slidesOffsetBefore: 0, slidesOffsetAfter: 0, normalizeSlideIndex: !0, centerInsufficientSlides: !1, watchOverflow: !0, roundLengths: !1, touchRatio: 1, touchAngle: 45, simulateTouch: !0, shortSwipes: !0, longSwipes: !0, longSwipesRatio: .5, longSwipesMs: 300, followFinger: !0, allowTouchMove: !0, threshold: 5, touchMoveStopPropagation: !1, touchStartPreventDefault: !0, touchStartForcePreventDefault: !1, touchReleaseOnEdges: !1, uniqueNavElements: !0, resistance: !0, resistanceRatio: .85, watchSlidesProgress: !1, grabCursor: !1, preventClicks: !0, preventClicksPropagation: !0, slideToClickedSlide: !1, loop: !1, loopAddBlankSlides: !0, loopAdditionalSlides: 0, loopPreventsSliding: !0, rewind: !1, allowSlidePrev: !0, allowSlideNext: !0, swipeHandler: null, noSwiping: !0, noSwipingClass: "swiper-no-swiping", noSwipingSelector: null, passiveListeners: !0, maxBackfaceHiddenSlides: 10, containerModifierClass: "swiper-", slideClass: "swiper-slide", slideBlankClass: "swiper-slide-blank", slideActiveClass: "swiper-slide-active", slideVisibleClass: "swiper-slide-visible", slideFullyVisibleClass: "swiper-slide-fully-visible", slideNextClass: "swiper-slide-next", slidePrevClass: "swiper-slide-prev", wrapperClass: "swiper-wrapper", lazyPreloaderClass: "swiper-lazy-preloader", lazyPreloadPrevNext: 0, runCallbacksOnInit: !0, _emitClasses: !1 }; function bf(n, e) { return function (i) { i === void 0 && (i = {}); const r = Object.keys(i)[0], s = i[r]; if (typeof s != "object" || s === null) { Et(e, i); return } if (n[r] === !0 && (n[r] = { enabled: !0 }), r === "navigation" && n[r] && n[r].enabled && !n[r].prevEl && !n[r].nextEl && (n[r].auto = !0), ["pagination", "scrollbar"].indexOf(r) >= 0 && n[r] && n[r].enabled && !n[r].el && (n[r].auto = !0), !(r in n && "enabled" in s)) { Et(e, i); return } typeof n[r] == "object" && !("enabled" in n[r]) && (n[r].enabled = !0), n[r] || (n[r] = { enabled: !1 }), Et(e, i) } } const Un = { eventsEmitter: vu, update: Pu, translate: Iu, transition: Bu, slide: Xu, loop: Ku, grabCursor: Ju, events: uf, breakpoints: hf, checkOverflow: wf, classes: _f }, Kn = {}; class qe { constructor() { let e, t; for (var i = arguments.length, r = new Array(i), s = 0; s < i; s++)r[s] = arguments[s]; r.length === 1 && r[0].constructor && Object.prototype.toString.call(r[0]).slice(8, -1) === "Object" ? t = r[0] : [e, t] = r, t || (t = {}), t = Et({}, t), e && !t.el && (t.el = e); const a = ft(); if (t.el && typeof t.el == "string" && a.querySelectorAll(t.el).length > 1) { const d = []; return a.querySelectorAll(t.el).forEach(u => { const f = Et({}, t, { el: u }); d.push(new qe(f)) }), d } const o = this; o.__swiper__ = !0, o.support = hd(), o.device = fu({ userAgent: t.userAgent }), o.browser = hu(), o.eventsListeners = {}, o.eventsAnyListeners = [], o.modules = [...o.__modules__], t.modules && Array.isArray(t.modules) && o.modules.push(...t.modules); const l = {}; o.modules.forEach(d => { d({ params: t, swiper: o, extendParams: bf(t, l), on: o.on.bind(o), once: o.once.bind(o), off: o.off.bind(o), emit: o.emit.bind(o) }) }); const c = Et({}, Fo, l); return o.params = Et({}, c, Kn, t), o.originalParams = Et({}, o.params), o.passedParams = Et({}, t), o.params && o.params.on && Object.keys(o.params.on).forEach(d => { o.on(d, o.params.on[d]) }), o.params && o.params.onAny && o.onAny(o.params.onAny), Object.assign(o, { enabled: o.params.enabled, el: e, classNames: [], slides: [], slidesGrid: [], snapGrid: [], slidesSizesGrid: [], isHorizontal() { return o.params.direction === "horizontal" }, isVertical() { return o.params.direction === "vertical" }, activeIndex: 0, realIndex: 0, isBeginning: !0, isEnd: !1, translate: 0, previousTranslate: 0, progress: 0, velocity: 0, animating: !1, cssOverflowAdjustment() { return Math.trunc(this.translate / 2 ** 23) * 2 ** 23 }, allowSlideNext: o.params.allowSlideNext, allowSlidePrev: o.params.allowSlidePrev, touchEventsData: { isTouched: void 0, isMoved: void 0, allowTouchCallbacks: void 0, touchStartTime: void 0, isScrolling: void 0, currentTranslate: void 0, startTranslate: void 0, allowThresholdMove: void 0, focusableElements: o.params.focusableElements, lastClickTime: 0, clickTimeout: void 0, velocities: [], allowMomentumBounce: void 0, startMoving: void 0, pointerId: null, touchId: null }, allowClick: !0, allowTouchMove: o.params.allowTouchMove, touches: { startX: 0, startY: 0, currentX: 0, currentY: 0, diff: 0 }, imagesToLoad: [], imagesLoaded: 0 }), o.emit("_swiper"), o.params.init && o.init(), o } getDirectionLabel(e) { return this.isHorizontal() ? e : { width: "height", "margin-top": "margin-left", "margin-bottom ": "margin-right", "margin-left": "margin-top", "margin-right": "margin-bottom", "padding-left": "padding-top", "padding-right": "padding-bottom", marginRight: "marginBottom" }[e] } getSlideIndex(e) { const { slidesEl: t, params: i } = this, r = We(t, `.${i.slideClass}, swiper-slide`), s = Cs(r[0]); return Cs(e) - s } getSlideIndexByData(e) { return this.getSlideIndex(this.slides.filter(t => t.getAttribute("data-swiper-slide-index") * 1 === e)[0]) } recalcSlides() { const e = this, { slidesEl: t, params: i } = e; e.slides = We(t, `.${i.slideClass}, swiper-slide`) } enable() { const e = this; e.enabled || (e.enabled = !0, e.params.grabCursor && e.setGrabCursor(), e.emit("enable")) } disable() { const e = this; e.enabled && (e.enabled = !1, e.params.grabCursor && e.unsetGrabCursor(), e.emit("disable")) } setProgress(e, t) { const i = this; e = Math.min(Math.max(e, 0), 1); const r = i.minTranslate(), a = (i.maxTranslate() - r) * e + r; i.translateTo(a, typeof t > "u" ? 0 : t), i.updateActiveIndex(), i.updateSlidesClasses() } emitContainerClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = e.el.className.split(" ").filter(i => i.indexOf("swiper") === 0 || i.indexOf(e.params.containerModifierClass) === 0); e.emit("_containerClasses", t.join(" ")) } getSlideClasses(e) { const t = this; return t.destroyed ? "" : e.className.split(" ").filter(i => i.indexOf("swiper-slide") === 0 || i.indexOf(t.params.slideClass) === 0).join(" ") } emitSlidesClasses() { const e = this; if (!e.params._emitClasses || !e.el) return; const t = []; e.slides.forEach(i => { const r = e.getSlideClasses(i); t.push({ slideEl: i, classNames: r }), e.emit("_slideClass", i, r) }), e.emit("_slideClasses", t) } slidesPerViewDynamic(e, t) { e === void 0 && (e = "current"), t === void 0 && (t = !1); const i = this, { params: r, slides: s, slidesGrid: a, slidesSizesGrid: o, size: l, activeIndex: c } = i; let d = 1; if (typeof r.slidesPerView == "number") return r.slidesPerView; if (r.centeredSlides) { let u = s[c] ? s[c].swiperSlideSize : 0, f; for (let p = c + 1; p < s.length; p += 1)s[p] && !f && (u += s[p].swiperSlideSize, d += 1, u > l && (f = !0)); for (let p = c - 1; p >= 0; p -= 1)s[p] && !f && (u += s[p].swiperSlideSize, d += 1, u > l && (f = !0)) } else if (e === "current") for (let u = c + 1; u < s.length; u += 1)(t ? a[u] + o[u] - a[c] < l : a[u] - a[c] < l) && (d += 1); else for (let u = c - 1; u >= 0; u -= 1)a[c] - a[u] < l && (d += 1); return d } update() { const e = this; if (!e || e.destroyed) return; const { snapGrid: t, params: i } = e; i.breakpoints && e.setBreakpoint(), [...e.el.querySelectorAll('[loading="lazy"]')].forEach(a => { a.complete && sn(e, a) }), e.updateSize(), e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(); function r() { const a = e.rtlTranslate ? e.translate * -1 : e.translate, o = Math.min(Math.max(a, e.maxTranslate()), e.minTranslate()); e.setTranslate(o), e.updateActiveIndex(), e.updateSlidesClasses() } let s; if (i.freeMode && i.freeMode.enabled && !i.cssMode) r(), i.autoHeight && e.updateAutoHeight(); else { if ((i.slidesPerView === "auto" || i.slidesPerView > 1) && e.isEnd && !i.centeredSlides) { const a = e.virtual && i.virtual.enabled ? e.virtual.slides : e.slides; s = e.slideTo(a.length - 1, 0, !1, !0) } else s = e.slideTo(e.activeIndex, 0, !1, !0); s || r() } i.watchOverflow && t !== e.snapGrid && e.checkOverflow(), e.emit("update") } changeDirection(e, t) { t === void 0 && (t = !0); const i = this, r = i.params.direction; return e || (e = r === "horizontal" ? "vertical" : "horizontal"), e === r || e !== "horizontal" && e !== "vertical" || (i.el.classList.remove(`${i.params.containerModifierClass}${r}`), i.el.classList.add(`${i.params.containerModifierClass}${e}`), i.emitContainerClasses(), i.params.direction = e, i.slides.forEach(s => { e === "vertical" ? s.style.width = "" : s.style.height = "" }), i.emit("changeDirection"), t && i.update()), i } changeLanguageDirection(e) { const t = this; t.rtl && e === "rtl" || !t.rtl && e === "ltr" || (t.rtl = e === "rtl", t.rtlTranslate = t.params.direction === "horizontal" && t.rtl, t.rtl ? (t.el.classList.add(`${t.params.containerModifierClass}rtl`), t.el.dir = "rtl") : (t.el.classList.remove(`${t.params.containerModifierClass}rtl`), t.el.dir = "ltr"), t.update()) } mount(e) { const t = this; if (t.mounted) return !0; let i = e || t.params.el; if (typeof i == "string" && (i = document.querySelector(i)), !i) return !1; i.swiper = t, i.parentNode && i.parentNode.host && i.parentNode.host.nodeName === "SWIPER-CONTAINER" && (t.isElement = !0); const r = () => `.${(t.params.wrapperClass || "").trim().split(" ").join(".")}`; let a = i && i.shadowRoot && i.shadowRoot.querySelector ? i.shadowRoot.querySelector(r()) : We(i, r())[0]; return !a && t.params.createElements && (a = Lt("div", t.params.wrapperClass), i.append(a), We(i, `.${t.params.slideClass}`).forEach(o => { a.append(o) })), Object.assign(t, { el: i, wrapperEl: a, slidesEl: t.isElement && !i.parentNode.host.slideSlots ? i.parentNode.host : a, hostEl: t.isElement ? i.parentNode.host : i, mounted: !0, rtl: i.dir.toLowerCase() === "rtl" || Ci(i, "direction") === "rtl", rtlTranslate: t.params.direction === "horizontal" && (i.dir.toLowerCase() === "rtl" || Ci(i, "direction") === "rtl"), wrongRTL: Ci(a, "display") === "-webkit-box" }), !0 } init(e) { const t = this; if (t.initialized || t.mount(e) === !1) return t; t.emit("beforeInit"), t.params.breakpoints && t.setBreakpoint(), t.addClasses(), t.updateSize(), t.updateSlides(), t.params.watchOverflow && t.checkOverflow(), t.params.grabCursor && t.enabled && t.setGrabCursor(), t.params.loop && t.virtual && t.params.virtual.enabled ? t.slideTo(t.params.initialSlide + t.virtual.slidesBefore, 0, t.params.runCallbacksOnInit, !1, !0) : t.slideTo(t.params.initialSlide, 0, t.params.runCallbacksOnInit, !1, !0), t.params.loop && t.loopCreate(), t.attachEvents(); const r = [...t.el.querySelectorAll('[loading="lazy"]')]; return t.isElement && r.push(...t.hostEl.querySelectorAll('[loading="lazy"]')), r.forEach(s => { s.complete ? sn(t, s) : s.addEventListener("load", a => { sn(t, a.target) }) }), Ta(t), t.initialized = !0, Ta(t), t.emit("init"), t.emit("afterInit"), t } destroy(e, t) { e === void 0 && (e = !0), t === void 0 && (t = !0); const i = this, { params: r, el: s, wrapperEl: a, slides: o } = i; return typeof i.params > "u" || i.destroyed || (i.emit("beforeDestroy"), i.initialized = !1, i.detachEvents(), r.loop && i.loopDestroy(), t && (i.removeClasses(), s.removeAttribute("style"), a.removeAttribute("style"), o && o.length && o.forEach(l => { l.classList.remove(r.slideVisibleClass, r.slideFullyVisibleClass, r.slideActiveClass, r.slideNextClass, r.slidePrevClass), l.removeAttribute("style"), l.removeAttribute("data-swiper-slide-index") })), i.emit("destroy"), Object.keys(i.eventsListeners).forEach(l => { i.off(l) }), e !== !1 && (i.el.swiper = null, nu(i)), i.destroyed = !0), null } static extendDefaults(e) { Et(Kn, e) } static get extendedDefaults() { return Kn } static get defaults() { return Fo } static installModule(e) { qe.prototype.__modules__ || (qe.prototype.__modules__ = []); const t = qe.prototype.__modules__; typeof e == "function" && t.indexOf(e) < 0 && t.push(e) } static use(e) { return Array.isArray(e) ? (e.forEach(t => qe.installModule(t)), qe) : (qe.installModule(e), qe) } } Object.keys(Un).forEach(n => { Object.keys(Un[n]).forEach(e => { qe.prototype[e] = Un[n][e] }) }); qe.use([mu, gu]); function xf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; t({ virtual: { enabled: !1, slides: [], cache: !0, renderSlide: null, renderExternal: null, renderExternalUpdate: !0, addSlidesBefore: 0, addSlidesAfter: 0 } }); let s; const a = ft(); e.virtual = { cache: {}, from: void 0, to: void 0, slides: [], offset: 0, slidesGrid: [] }; const o = a.createElement("div"); function l(g, h) { const m = e.params.virtual; if (m.cache && e.virtual.cache[h]) return e.virtual.cache[h]; let y; return m.renderSlide ? (y = m.renderSlide.call(e, g, h), typeof y == "string" && (o.innerHTML = y, y = o.children[0])) : e.isElement ? y = Lt("swiper-slide") : y = Lt("div", e.params.slideClass), y.setAttribute("data-swiper-slide-index", h), m.renderSlide || (y.innerHTML = g), m.cache && (e.virtual.cache[h] = y), y } function c(g) { const { slidesPerView: h, slidesPerGroup: m, centeredSlides: y, loop: _ } = e.params, { addSlidesBefore: v, addSlidesAfter: w } = e.params.virtual, { from: x, to: S, slides: P, slidesGrid: A, offset: M } = e.virtual; e.params.cssMode || e.updateActiveIndex(); const E = e.activeIndex || 0; let O; e.rtlTranslate ? O = "right" : O = e.isHorizontal() ? "left" : "top"; let C, k; y ? (C = Math.floor(h / 2) + m + w, k = Math.floor(h / 2) + m + v) : (C = h + (m - 1) + w, k = (_ ? h : m) + v); let b = E - k, L = E + C; _ || (b = Math.max(b, 0), L = Math.min(L, P.length - 1)); let z = (e.slidesGrid[b] || 0) - (e.slidesGrid[0] || 0); _ && E >= k ? (b -= k, y || (z += e.slidesGrid[0])) : _ && E < k && (b = -k, y && (z += e.slidesGrid[0])), Object.assign(e.virtual, { from: b, to: L, offset: z, slidesGrid: e.slidesGrid, slidesBefore: k, slidesAfter: C }); function D() { e.updateSlides(), e.updateProgress(), e.updateSlidesClasses(), r("virtualUpdate") } if (x === b && S === L && !g) { e.slidesGrid !== A && z !== M && e.slides.forEach(N => { N.style[O] = `${z - Math.abs(e.cssOverflowAdjustment())}px` }), e.updateProgress(), r("virtualUpdate"); return } if (e.params.virtual.renderExternal) { e.params.virtual.renderExternal.call(e, { offset: z, from: b, to: L, slides: function () { const Y = []; for (let se = b; se <= L; se += 1)Y.push(P[se]); return Y }() }), e.params.virtual.renderExternalUpdate ? D() : r("virtualUpdate"); return } const I = [], R = [], T = N => { let Y = N; return N < 0 ? Y = P.length + N : Y >= P.length && (Y = Y - P.length), Y }; if (g) e.slides.filter(N => N.matches(`.${e.params.slideClass}, swiper-slide`)).forEach(N => { N.remove() }); else for (let N = x; N <= S; N += 1)if (N < b || N > L) { const Y = T(N); e.slides.filter(se => se.matches(`.${e.params.slideClass}[data-swiper-slide-index="${Y}"], swiper-slide[data-swiper-slide-index="${Y}"]`)).forEach(se => { se.remove() }) } const q = _ ? -P.length : 0, ie = _ ? P.length * 2 : P.length; for (let N = q; N < ie; N += 1)if (N >= b && N <= L) { const Y = T(N); typeof S > "u" || g ? R.push(Y) : (N > S && R.push(Y), N < x && I.push(Y)) } if (R.forEach(N => { e.slidesEl.append(l(P[N], N)) }), _) for (let N = I.length - 1; N >= 0; N -= 1) { const Y = I[N]; e.slidesEl.prepend(l(P[Y], Y)) } else I.sort((N, Y) => Y - N), I.forEach(N => { e.slidesEl.prepend(l(P[N], N)) }); We(e.slidesEl, ".swiper-slide, swiper-slide").forEach(N => { N.style[O] = `${z - Math.abs(e.cssOverflowAdjustment())}px` }), D() } function d(g) { if (typeof g == "object" && "length" in g) for (let h = 0; h < g.length; h += 1)g[h] && e.virtual.slides.push(g[h]); else e.virtual.slides.push(g); c(!0) } function u(g) { const h = e.activeIndex; let m = h + 1, y = 1; if (Array.isArray(g)) { for (let _ = 0; _ < g.length; _ += 1)g[_] && e.virtual.slides.unshift(g[_]); m = h + g.length, y = g.length } else e.virtual.slides.unshift(g); if (e.params.virtual.cache) { const _ = e.virtual.cache, v = {}; Object.keys(_).forEach(w => { const x = _[w], S = x.getAttribute("data-swiper-slide-index"); S && x.setAttribute("data-swiper-slide-index", parseInt(S, 10) + y), v[parseInt(w, 10) + y] = x }), e.virtual.cache = v } c(!0), e.slideTo(m, 0) } function f(g) { if (typeof g > "u" || g === null) return; let h = e.activeIndex; if (Array.isArray(g)) for (let m = g.length - 1; m >= 0; m -= 1)e.params.virtual.cache && (delete e.virtual.cache[g[m]], Object.keys(e.virtual.cache).forEach(y => { y > g && (e.virtual.cache[y - 1] = e.virtual.cache[y], e.virtual.cache[y - 1].setAttribute("data-swiper-slide-index", y - 1), delete e.virtual.cache[y]) })), e.virtual.slides.splice(g[m], 1), g[m] < h && (h -= 1), h = Math.max(h, 0); else e.params.virtual.cache && (delete e.virtual.cache[g], Object.keys(e.virtual.cache).forEach(m => { m > g && (e.virtual.cache[m - 1] = e.virtual.cache[m], e.virtual.cache[m - 1].setAttribute("data-swiper-slide-index", m - 1), delete e.virtual.cache[m]) })), e.virtual.slides.splice(g, 1), g < h && (h -= 1), h = Math.max(h, 0); c(!0), e.slideTo(h, 0) } function p() { e.virtual.slides = [], e.params.virtual.cache && (e.virtual.cache = {}), c(!0), e.slideTo(0, 0) } i("beforeInit", () => { if (!e.params.virtual.enabled) return; let g; if (typeof e.passedParams.virtual.slides > "u") { const h = [...e.slidesEl.children].filter(m => m.matches(`.${e.params.slideClass}, swiper-slide`)); h && h.length && (e.virtual.slides = [...h], g = !0, h.forEach((m, y) => { m.setAttribute("data-swiper-slide-index", y), e.virtual.cache[y] = m, m.remove() })) } g || (e.virtual.slides = e.params.virtual.slides), e.classNames.push(`${e.params.containerModifierClass}virtual`), e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0, c() }), i("setTranslate", () => { e.params.virtual.enabled && (e.params.cssMode && !e._immediateVirtual ? (clearTimeout(s), s = setTimeout(() => { c() }, 100)) : c()) }), i("init update resize", () => { e.params.virtual.enabled && e.params.cssMode && ts(e.wrapperEl, "--swiper-virtual-size", `${e.virtualSize}px`) }), Object.assign(e.virtual, { appendSlide: d, prependSlide: u, removeSlide: f, removeAllSlides: p, update: c }) } function Sf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = ft(), a = ye(); e.keyboard = { enabled: !1 }, t({ keyboard: { enabled: !1, onlyInViewport: !0, pageUpDown: !0 } }); function o(d) { if (!e.enabled) return; const { rtlTranslate: u } = e; let f = d; f.originalEvent && (f = f.originalEvent); const p = f.keyCode || f.charCode, g = e.params.keyboard.pageUpDown, h = g && p === 33, m = g && p === 34, y = p === 37, _ = p === 39, v = p === 38, w = p === 40; if (!e.allowSlideNext && (e.isHorizontal() && _ || e.isVertical() && w || m) || !e.allowSlidePrev && (e.isHorizontal() && y || e.isVertical() && v || h)) return !1; if (!(f.shiftKey || f.altKey || f.ctrlKey || f.metaKey) && !(s.activeElement && s.activeElement.nodeName && (s.activeElement.nodeName.toLowerCase() === "input" || s.activeElement.nodeName.toLowerCase() === "textarea"))) { if (e.params.keyboard.onlyInViewport && (h || m || y || _ || v || w)) { let x = !1; if (ar(e.el, `.${e.params.slideClass}, swiper-slide`).length > 0 && ar(e.el, `.${e.params.slideActiveClass}`).length === 0) return; const S = e.el, P = S.clientWidth, A = S.clientHeight, M = a.innerWidth, E = a.innerHeight, O = vn(S); u && (O.left -= S.scrollLeft); const C = [[O.left, O.top], [O.left + P, O.top], [O.left, O.top + A], [O.left + P, O.top + A]]; for (let k = 0; k < C.length; k += 1) { const b = C[k]; if (b[0] >= 0 && b[0] <= M && b[1] >= 0 && b[1] <= E) { if (b[0] === 0 && b[1] === 0) continue; x = !0 } } if (!x) return } e.isHorizontal() ? ((h || m || y || _) && (f.preventDefault ? f.preventDefault() : f.returnValue = !1), ((m || _) && !u || (h || y) && u) && e.slideNext(), ((h || y) && !u || (m || _) && u) && e.slidePrev()) : ((h || m || v || w) && (f.preventDefault ? f.preventDefault() : f.returnValue = !1), (m || w) && e.slideNext(), (h || v) && e.slidePrev()), r("keyPress", p) } } function l() { e.keyboard.enabled || (s.addEventListener("keydown", o), e.keyboard.enabled = !0) } function c() { e.keyboard.enabled && (s.removeEventListener("keydown", o), e.keyboard.enabled = !1) } i("init", () => { e.params.keyboard.enabled && l() }), i("destroy", () => { e.keyboard.enabled && c() }), Object.assign(e.keyboard, { enable: l, disable: c }) } function Tf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = ye(); t({ mousewheel: { enabled: !1, releaseOnEdges: !1, invert: !1, forceToAxis: !1, sensitivity: 1, eventsTarget: "container", thresholdDelta: null, thresholdTime: null, noMousewheelClass: "swiper-no-mousewheel" } }), e.mousewheel = { enabled: !1 }; let a, o = Rt(), l; const c = []; function d(v) { let P = 0, A = 0, M = 0, E = 0; return "detail" in v && (A = v.detail), "wheelDelta" in v && (A = -v.wheelDelta / 120), "wheelDeltaY" in v && (A = -v.wheelDeltaY / 120), "wheelDeltaX" in v && (P = -v.wheelDeltaX / 120), "axis" in v && v.axis === v.HORIZONTAL_AXIS && (P = A, A = 0), M = P * 10, E = A * 10, "deltaY" in v && (E = v.deltaY), "deltaX" in v && (M = v.deltaX), v.shiftKey && !M && (M = E, E = 0), (M || E) && v.deltaMode && (v.deltaMode === 1 ? (M *= 40, E *= 40) : (M *= 800, E *= 800)), M && !P && (P = M < 1 ? -1 : 1), E && !A && (A = E < 1 ? -1 : 1), { spinX: P, spinY: A, pixelX: M, pixelY: E } } function u() { e.enabled && (e.mouseEntered = !0) } function f() { e.enabled && (e.mouseEntered = !1) } function p(v) { return e.params.mousewheel.thresholdDelta && v.delta < e.params.mousewheel.thresholdDelta || e.params.mousewheel.thresholdTime && Rt() - o < e.params.mousewheel.thresholdTime ? !1 : v.delta >= 6 && Rt() - o < 60 ? !0 : (v.direction < 0 ? (!e.isEnd || e.params.loop) && !e.animating && (e.slideNext(), r("scroll", v.raw)) : (!e.isBeginning || e.params.loop) && !e.animating && (e.slidePrev(), r("scroll", v.raw)), o = new s.Date().getTime(), !1) } function g(v) { const w = e.params.mousewheel; if (v.direction < 0) { if (e.isEnd && !e.params.loop && w.releaseOnEdges) return !0 } else if (e.isBeginning && !e.params.loop && w.releaseOnEdges) return !0; return !1 } function h(v) { let w = v, x = !0; if (!e.enabled || v.target.closest(`.${e.params.mousewheel.noMousewheelClass}`)) return; const S = e.params.mousewheel; e.params.cssMode && w.preventDefault(); let P = e.el; e.params.mousewheel.eventsTarget !== "container" && (P = document.querySelector(e.params.mousewheel.eventsTarget)); const A = P && P.contains(w.target); if (!e.mouseEntered && !A && !S.releaseOnEdges) return !0; w.originalEvent && (w = w.originalEvent); let M = 0; const E = e.rtlTranslate ? -1 : 1, O = d(w); if (S.forceToAxis) if (e.isHorizontal()) if (Math.abs(O.pixelX) > Math.abs(O.pixelY)) M = -O.pixelX * E; else return !0; else if (Math.abs(O.pixelY) > Math.abs(O.pixelX)) M = -O.pixelY; else return !0; else M = Math.abs(O.pixelX) > Math.abs(O.pixelY) ? -O.pixelX * E : -O.pixelY; if (M === 0) return !0; S.invert && (M = -M); let C = e.getTranslate() + M * S.sensitivity; if (C >= e.minTranslate() && (C = e.minTranslate()), C <= e.maxTranslate() && (C = e.maxTranslate()), x = e.params.loop ? !0 : !(C === e.minTranslate() || C === e.maxTranslate()), x && e.params.nested && w.stopPropagation(), !e.params.freeMode || !e.params.freeMode.enabled) { const k = { time: Rt(), delta: Math.abs(M), direction: Math.sign(M), raw: v }; c.length >= 2 && c.shift(); const b = c.length ? c[c.length - 1] : void 0; if (c.push(k), b ? (k.direction !== b.direction || k.delta > b.delta || k.time > b.time + 150) && p(k) : p(k), g(k)) return !0 } else { const k = { time: Rt(), delta: Math.abs(M), direction: Math.sign(M) }, b = l && k.time < l.time + 500 && k.delta <= l.delta && k.direction === l.direction; if (!b) { l = void 0; let L = e.getTranslate() + M * S.sensitivity; const z = e.isBeginning, D = e.isEnd; if (L >= e.minTranslate() && (L = e.minTranslate()), L <= e.maxTranslate() && (L = e.maxTranslate()), e.setTransition(0), e.setTranslate(L), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses(), (!z && e.isBeginning || !D && e.isEnd) && e.updateSlidesClasses(), e.params.loop && e.loopFix({ direction: k.direction < 0 ? "next" : "prev", byMousewheel: !0 }), e.params.freeMode.sticky) { clearTimeout(a), a = void 0, c.length >= 15 && c.shift(); const I = c.length ? c[c.length - 1] : void 0, R = c[0]; if (c.push(k), I && (k.delta > I.delta || k.direction !== I.direction)) c.splice(0); else if (c.length >= 15 && k.time - R.time < 500 && R.delta - k.delta >= 1 && k.delta <= 6) { const T = M > 0 ? .8 : .2; l = k, c.splice(0), a = pr(() => { e.slideToClosest(e.params.speed, !0, void 0, T) }, 0) } a || (a = pr(() => { l = k, c.splice(0), e.slideToClosest(e.params.speed, !0, void 0, .5) }, 500)) } if (b || r("scroll", w), e.params.autoplay && e.params.autoplayDisableOnInteraction && e.autoplay.stop(), S.releaseOnEdges && (L === e.minTranslate() || L === e.maxTranslate())) return !0 } } return w.preventDefault ? w.preventDefault() : w.returnValue = !1, !1 } function m(v) { let w = e.el; e.params.mousewheel.eventsTarget !== "container" && (w = document.querySelector(e.params.mousewheel.eventsTarget)), w[v]("mouseenter", u), w[v]("mouseleave", f), w[v]("wheel", h) } function y() { return e.params.cssMode ? (e.wrapperEl.removeEventListener("wheel", h), !0) : e.mousewheel.enabled ? !1 : (m("addEventListener"), e.mousewheel.enabled = !0, !0) } function _() { return e.params.cssMode ? (e.wrapperEl.addEventListener(event, h), !0) : e.mousewheel.enabled ? (m("removeEventListener"), e.mousewheel.enabled = !1, !0) : !1 } i("init", () => { !e.params.mousewheel.enabled && e.params.cssMode && _(), e.params.mousewheel.enabled && y() }), i("destroy", () => { e.params.cssMode && y(), e.mousewheel.enabled && _() }), Object.assign(e.mousewheel, { enable: y, disable: _ }) } function Ka(n, e, t, i) { return n.params.createElements && Object.keys(i).forEach(r => { if (!t[r] && t.auto === !0) { let s = We(n.el, `.${i[r]}`)[0]; s || (s = Lt("div", i[r]), s.className = i[r], n.el.append(s)), t[r] = s, e[r] = s } }), t } function Ef(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; t({ navigation: { nextEl: null, prevEl: null, hideOnClick: !1, disabledClass: "swiper-button-disabled", hiddenClass: "swiper-button-hidden", lockClass: "swiper-button-lock", navigationDisabledClass: "swiper-navigation-disabled" } }), e.navigation = { nextEl: null, prevEl: null }; const s = h => (Array.isArray(h) ? h : [h]).filter(m => !!m); function a(h) { let m; return h && typeof h == "string" && e.isElement && (m = e.el.querySelector(h), m) ? m : (h && (typeof h == "string" && (m = [...document.querySelectorAll(h)]), e.params.uniqueNavElements && typeof h == "string" && m.length > 1 && e.el.querySelectorAll(h).length === 1 && (m = e.el.querySelector(h))), h && !m ? h : m) } function o(h, m) { const y = e.params.navigation; h = s(h), h.forEach(_ => { _ && (_.classList[m ? "add" : "remove"](...y.disabledClass.split(" ")), _.tagName === "BUTTON" && (_.disabled = m), e.params.watchOverflow && e.enabled && _.classList[e.isLocked ? "add" : "remove"](y.lockClass)) }) } function l() { const { nextEl: h, prevEl: m } = e.navigation; if (e.params.loop) { o(m, !1), o(h, !1); return } o(m, e.isBeginning && !e.params.rewind), o(h, e.isEnd && !e.params.rewind) } function c(h) { h.preventDefault(), !(e.isBeginning && !e.params.loop && !e.params.rewind) && (e.slidePrev(), r("navigationPrev")) } function d(h) { h.preventDefault(), !(e.isEnd && !e.params.loop && !e.params.rewind) && (e.slideNext(), r("navigationNext")) } function u() { const h = e.params.navigation; if (e.params.navigation = Ka(e, e.originalParams.navigation, e.params.navigation, { nextEl: "swiper-button-next", prevEl: "swiper-button-prev" }), !(h.nextEl || h.prevEl)) return; let m = a(h.nextEl), y = a(h.prevEl); Object.assign(e.navigation, { nextEl: m, prevEl: y }), m = s(m), y = s(y); const _ = (v, w) => { v && v.addEventListener("click", w === "next" ? d : c), !e.enabled && v && v.classList.add(...h.lockClass.split(" ")) }; m.forEach(v => _(v, "next")), y.forEach(v => _(v, "prev")) } function f() { let { nextEl: h, prevEl: m } = e.navigation; h = s(h), m = s(m); const y = (_, v) => { _.removeEventListener("click", v === "next" ? d : c), _.classList.remove(...e.params.navigation.disabledClass.split(" ")) }; h.forEach(_ => y(_, "next")), m.forEach(_ => y(_, "prev")) } i("init", () => { e.params.navigation.enabled === !1 ? g() : (u(), l()) }), i("toEdge fromEdge lock unlock", () => { l() }), i("destroy", () => { f() }), i("enable disable", () => { let { nextEl: h, prevEl: m } = e.navigation; if (h = s(h), m = s(m), e.enabled) { l(); return } [...h, ...m].filter(y => !!y).forEach(y => y.classList.add(e.params.navigation.lockClass)) }), i("click", (h, m) => { let { nextEl: y, prevEl: _ } = e.navigation; y = s(y), _ = s(_); const v = m.target; if (e.params.navigation.hideOnClick && !_.includes(v) && !y.includes(v)) { if (e.pagination && e.params.pagination && e.params.pagination.clickable && (e.pagination.el === v || e.pagination.el.contains(v))) return; let w; y.length ? w = y[0].classList.contains(e.params.navigation.hiddenClass) : _.length && (w = _[0].classList.contains(e.params.navigation.hiddenClass)), r(w === !0 ? "navigationShow" : "navigationHide"), [...y, ..._].filter(x => !!x).forEach(x => x.classList.toggle(e.params.navigation.hiddenClass)) } }); const p = () => { e.el.classList.remove(...e.params.navigation.navigationDisabledClass.split(" ")), u(), l() }, g = () => { e.el.classList.add(...e.params.navigation.navigationDisabledClass.split(" ")), f() }; Object.assign(e.navigation, { enable: p, disable: g, update: l, init: u, destroy: f }) } function fi(n) { return n === void 0 && (n = ""), `.${n.trim().replace(/([\.:!+\/])/g, "\\$1").replace(/ /g, ".")}` } function Mf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = "swiper-pagination"; t({ pagination: { el: null, bulletElement: "span", clickable: !1, hideOnClick: !1, renderBullet: null, renderProgressbar: null, renderFraction: null, renderCustom: null, progressbarOpposite: !1, type: "bullets", dynamicBullets: !1, dynamicMainBullets: 1, formatFractionCurrent: _ => _, formatFractionTotal: _ => _, bulletClass: `${s}-bullet`, bulletActiveClass: `${s}-bullet-active`, modifierClass: `${s}-`, currentClass: `${s}-current`, totalClass: `${s}-total`, hiddenClass: `${s}-hidden`, progressbarFillClass: `${s}-progressbar-fill`, progressbarOppositeClass: `${s}-progressbar-opposite`, clickableClass: `${s}-clickable`, lockClass: `${s}-lock`, horizontalClass: `${s}-horizontal`, verticalClass: `${s}-vertical`, paginationDisabledClass: `${s}-disabled` } }), e.pagination = { el: null, bullets: [] }; let a, o = 0; const l = _ => (Array.isArray(_) ? _ : [_]).filter(v => !!v); function c() { return !e.params.pagination.el || !e.pagination.el || Array.isArray(e.pagination.el) && e.pagination.el.length === 0 } function d(_, v) { const { bulletActiveClass: w } = e.params.pagination; _ && (_ = _[`${v === "prev" ? "previous" : "next"}ElementSibling`], _ && (_.classList.add(`${w}-${v}`), _ = _[`${v === "prev" ? "previous" : "next"}ElementSibling`], _ && _.classList.add(`${w}-${v}-${v}`))) } function u(_) { const v = _.target.closest(fi(e.params.pagination.bulletClass)); if (!v) return; _.preventDefault(); const w = Cs(v) * e.params.slidesPerGroup; if (e.params.loop) { if (e.realIndex === w) return; e.slideToLoop(w) } else e.slideTo(w) } function f() { const _ = e.rtl, v = e.params.pagination; if (c()) return; let w = e.pagination.el; w = l(w); let x, S; const P = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.slides.length, A = e.params.loop ? Math.ceil(P / e.params.slidesPerGroup) : e.snapGrid.length; if (e.params.loop ? (S = e.previousRealIndex || 0, x = e.params.slidesPerGroup > 1 ? Math.floor(e.realIndex / e.params.slidesPerGroup) : e.realIndex) : typeof e.snapIndex < "u" ? (x = e.snapIndex, S = e.previousSnapIndex) : (S = e.previousIndex || 0, x = e.activeIndex || 0), v.type === "bullets" && e.pagination.bullets && e.pagination.bullets.length > 0) { const M = e.pagination.bullets; let E, O, C; if (v.dynamicBullets && (a = Sa(M[0], e.isHorizontal() ? "width" : "height", !0), w.forEach(k => { k.style[e.isHorizontal() ? "width" : "height"] = `${a * (v.dynamicMainBullets + 4)}px` }), v.dynamicMainBullets > 1 && S !== void 0 && (o += x - (S || 0), o > v.dynamicMainBullets - 1 ? o = v.dynamicMainBullets - 1 : o < 0 && (o = 0)), E = Math.max(x - o, 0), O = E + (Math.min(M.length, v.dynamicMainBullets) - 1), C = (O + E) / 2), M.forEach(k => { const b = [...["", "-next", "-next-next", "-prev", "-prev-prev", "-main"].map(L => `${v.bulletActiveClass}${L}`)].map(L => typeof L == "string" && L.includes(" ") ? L.split(" ") : L).flat(); k.classList.remove(...b) }), w.length > 1) M.forEach(k => { const b = Cs(k); b === x ? k.classList.add(...v.bulletActiveClass.split(" ")) : e.isElement && k.setAttribute("part", "bullet"), v.dynamicBullets && (b >= E && b <= O && k.classList.add(...`${v.bulletActiveClass}-main`.split(" ")), b === E && d(k, "prev"), b === O && d(k, "next")) }); else { const k = M[x]; if (k && k.classList.add(...v.bulletActiveClass.split(" ")), e.isElement && M.forEach((b, L) => { b.setAttribute("part", L === x ? "bullet-active" : "bullet") }), v.dynamicBullets) { const b = M[E], L = M[O]; for (let z = E; z <= O; z += 1)M[z] && M[z].classList.add(...`${v.bulletActiveClass}-main`.split(" ")); d(b, "prev"), d(L, "next") } } if (v.dynamicBullets) { const k = Math.min(M.length, v.dynamicMainBullets + 4), b = (a * k - a) / 2 - C * a, L = _ ? "right" : "left"; M.forEach(z => { z.style[e.isHorizontal() ? L : "top"] = `${b}px` }) } } w.forEach((M, E) => { if (v.type === "fraction" && (M.querySelectorAll(fi(v.currentClass)).forEach(O => { O.textContent = v.formatFractionCurrent(x + 1) }), M.querySelectorAll(fi(v.totalClass)).forEach(O => { O.textContent = v.formatFractionTotal(A) })), v.type === "progressbar") { let O; v.progressbarOpposite ? O = e.isHorizontal() ? "vertical" : "horizontal" : O = e.isHorizontal() ? "horizontal" : "vertical"; const C = (x + 1) / A; let k = 1, b = 1; O === "horizontal" ? k = C : b = C, M.querySelectorAll(fi(v.progressbarFillClass)).forEach(L => { L.style.transform = `translate3d(0,0,0) scaleX(${k}) scaleY(${b})`, L.style.transitionDuration = `${e.params.speed}ms` }) } v.type === "custom" && v.renderCustom ? (M.innerHTML = v.renderCustom(e, x + 1, A), E === 0 && r("paginationRender", M)) : (E === 0 && r("paginationRender", M), r("paginationUpdate", M)), e.params.watchOverflow && e.enabled && M.classList[e.isLocked ? "add" : "remove"](v.lockClass) }) } function p() { const _ = e.params.pagination; if (c()) return; const v = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : e.grid && e.params.grid.rows > 1 ? e.slides.length / Math.ceil(e.params.grid.rows) : e.slides.length; let w = e.pagination.el; w = l(w); let x = ""; if (_.type === "bullets") { let S = e.params.loop ? Math.ceil(v / e.params.slidesPerGroup) : e.snapGrid.length; e.params.freeMode && e.params.freeMode.enabled && S > v && (S = v); for (let P = 0; P < S; P += 1)_.renderBullet ? x += _.renderBullet.call(e, P, _.bulletClass) : x += `<${_.bulletElement} ${e.isElement ? 'part="bullet"' : ""} class="${_.bulletClass}"></${_.bulletElement}>` } _.type === "fraction" && (_.renderFraction ? x = _.renderFraction.call(e, _.currentClass, _.totalClass) : x = `<span class="${_.currentClass}"></span> / <span class="${_.totalClass}"></span>`), _.type === "progressbar" && (_.renderProgressbar ? x = _.renderProgressbar.call(e, _.progressbarFillClass) : x = `<span class="${_.progressbarFillClass}"></span>`), e.pagination.bullets = [], w.forEach(S => { _.type !== "custom" && (S.innerHTML = x || ""), _.type === "bullets" && e.pagination.bullets.push(...S.querySelectorAll(fi(_.bulletClass))) }), _.type !== "custom" && r("paginationRender", w[0]) } function g() { e.params.pagination = Ka(e, e.originalParams.pagination, e.params.pagination, { el: "swiper-pagination" }); const _ = e.params.pagination; if (!_.el) return; let v; typeof _.el == "string" && e.isElement && (v = e.el.querySelector(_.el)), !v && typeof _.el == "string" && (v = [...document.querySelectorAll(_.el)]), v || (v = _.el), !(!v || v.length === 0) && (e.params.uniqueNavElements && typeof _.el == "string" && Array.isArray(v) && v.length > 1 && (v = [...e.el.querySelectorAll(_.el)], v.length > 1 && (v = v.filter(w => ar(w, ".swiper")[0] === e.el)[0])), Array.isArray(v) && v.length === 1 && (v = v[0]), Object.assign(e.pagination, { el: v }), v = l(v), v.forEach(w => { _.type === "bullets" && _.clickable && w.classList.add(...(_.clickableClass || "").split(" ")), w.classList.add(_.modifierClass + _.type), w.classList.add(e.isHorizontal() ? _.horizontalClass : _.verticalClass), _.type === "bullets" && _.dynamicBullets && (w.classList.add(`${_.modifierClass}${_.type}-dynamic`), o = 0, _.dynamicMainBullets < 1 && (_.dynamicMainBullets = 1)), _.type === "progressbar" && _.progressbarOpposite && w.classList.add(_.progressbarOppositeClass), _.clickable && w.addEventListener("click", u), e.enabled || w.classList.add(_.lockClass) })) } function h() { const _ = e.params.pagination; if (c()) return; let v = e.pagination.el; v && (v = l(v), v.forEach(w => { w.classList.remove(_.hiddenClass), w.classList.remove(_.modifierClass + _.type), w.classList.remove(e.isHorizontal() ? _.horizontalClass : _.verticalClass), _.clickable && (w.classList.remove(...(_.clickableClass || "").split(" ")), w.removeEventListener("click", u)) })), e.pagination.bullets && e.pagination.bullets.forEach(w => w.classList.remove(..._.bulletActiveClass.split(" "))) } i("changeDirection", () => { if (!e.pagination || !e.pagination.el) return; const _ = e.params.pagination; let { el: v } = e.pagination; v = l(v), v.forEach(w => { w.classList.remove(_.horizontalClass, _.verticalClass), w.classList.add(e.isHorizontal() ? _.horizontalClass : _.verticalClass) }) }), i("init", () => { e.params.pagination.enabled === !1 ? y() : (g(), p(), f()) }), i("activeIndexChange", () => { typeof e.snapIndex > "u" && f() }), i("snapIndexChange", () => { f() }), i("snapGridLengthChange", () => { p(), f() }), i("destroy", () => { h() }), i("enable disable", () => { let { el: _ } = e.pagination; _ && (_ = l(_), _.forEach(v => v.classList[e.enabled ? "remove" : "add"](e.params.pagination.lockClass))) }), i("lock unlock", () => { f() }), i("click", (_, v) => { const w = v.target, x = l(e.pagination.el); if (e.params.pagination.el && e.params.pagination.hideOnClick && x && x.length > 0 && !w.classList.contains(e.params.pagination.bulletClass)) { if (e.navigation && (e.navigation.nextEl && w === e.navigation.nextEl || e.navigation.prevEl && w === e.navigation.prevEl)) return; const S = x[0].classList.contains(e.params.pagination.hiddenClass); r(S === !0 ? "paginationShow" : "paginationHide"), x.forEach(P => P.classList.toggle(e.params.pagination.hiddenClass)) } }); const m = () => { e.el.classList.remove(e.params.pagination.paginationDisabledClass); let { el: _ } = e.pagination; _ && (_ = l(_), _.forEach(v => v.classList.remove(e.params.pagination.paginationDisabledClass))), g(), p(), f() }, y = () => { e.el.classList.add(e.params.pagination.paginationDisabledClass); let { el: _ } = e.pagination; _ && (_ = l(_), _.forEach(v => v.classList.add(e.params.pagination.paginationDisabledClass))), h() }; Object.assign(e.pagination, { enable: m, disable: y, render: p, update: f, init: g, destroy: h }) } function Cf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = ft(); let a = !1, o = null, l = null, c, d, u, f; t({ scrollbar: { el: null, dragSize: "auto", hide: !1, draggable: !1, snapOnRelease: !0, lockClass: "swiper-scrollbar-lock", dragClass: "swiper-scrollbar-drag", scrollbarDisabledClass: "swiper-scrollbar-disabled", horizontalClass: "swiper-scrollbar-horizontal", verticalClass: "swiper-scrollbar-vertical" } }), e.scrollbar = { el: null, dragEl: null }; function p() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: C, rtlTranslate: k } = e, { dragEl: b, el: L } = C, z = e.params.scrollbar, D = e.params.loop ? e.progressLoop : e.progress; let I = d, R = (u - d) * D; k ? (R = -R, R > 0 ? (I = d - R, R = 0) : -R + d > u && (I = u + R)) : R < 0 ? (I = d + R, R = 0) : R + d > u && (I = u - R), e.isHorizontal() ? (b.style.transform = `translate3d(${R}px, 0, 0)`, b.style.width = `${I}px`) : (b.style.transform = `translate3d(0px, ${R}px, 0)`, b.style.height = `${I}px`), z.hide && (clearTimeout(o), L.style.opacity = 1, o = setTimeout(() => { L.style.opacity = 0, L.style.transitionDuration = "400ms" }, 1e3)) } function g(C) { !e.params.scrollbar.el || !e.scrollbar.el || (e.scrollbar.dragEl.style.transitionDuration = `${C}ms`) } function h() { if (!e.params.scrollbar.el || !e.scrollbar.el) return; const { scrollbar: C } = e, { dragEl: k, el: b } = C; k.style.width = "", k.style.height = "", u = e.isHorizontal() ? b.offsetWidth : b.offsetHeight, f = e.size / (e.virtualSize + e.params.slidesOffsetBefore - (e.params.centeredSlides ? e.snapGrid[0] : 0)), e.params.scrollbar.dragSize === "auto" ? d = u * f : d = parseInt(e.params.scrollbar.dragSize, 10), e.isHorizontal() ? k.style.width = `${d}px` : k.style.height = `${d}px`, f >= 1 ? b.style.display = "none" : b.style.display = "", e.params.scrollbar.hide && (b.style.opacity = 0), e.params.watchOverflow && e.enabled && C.el.classList[e.isLocked ? "add" : "remove"](e.params.scrollbar.lockClass) } function m(C) { return e.isHorizontal() ? C.clientX : C.clientY } function y(C) { const { scrollbar: k, rtlTranslate: b } = e, { el: L } = k; let z; z = (m(C) - vn(L)[e.isHorizontal() ? "left" : "top"] - (c !== null ? c : d / 2)) / (u - d), z = Math.max(Math.min(z, 1), 0), b && (z = 1 - z); const D = e.minTranslate() + (e.maxTranslate() - e.minTranslate()) * z; e.updateProgress(D), e.setTranslate(D), e.updateActiveIndex(), e.updateSlidesClasses() } function _(C) { const k = e.params.scrollbar, { scrollbar: b, wrapperEl: L } = e, { el: z, dragEl: D } = b; a = !0, c = C.target === D ? m(C) - C.target.getBoundingClientRect()[e.isHorizontal() ? "left" : "top"] : null, C.preventDefault(), C.stopPropagation(), L.style.transitionDuration = "100ms", D.style.transitionDuration = "100ms", y(C), clearTimeout(l), z.style.transitionDuration = "0ms", k.hide && (z.style.opacity = 1), e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "none"), r("scrollbarDragStart", C) } function v(C) { const { scrollbar: k, wrapperEl: b } = e, { el: L, dragEl: z } = k; a && (C.preventDefault ? C.preventDefault() : C.returnValue = !1, y(C), b.style.transitionDuration = "0ms", L.style.transitionDuration = "0ms", z.style.transitionDuration = "0ms", r("scrollbarDragMove", C)) } function w(C) { const k = e.params.scrollbar, { scrollbar: b, wrapperEl: L } = e, { el: z } = b; a && (a = !1, e.params.cssMode && (e.wrapperEl.style["scroll-snap-type"] = "", L.style.transitionDuration = ""), k.hide && (clearTimeout(l), l = pr(() => { z.style.opacity = 0, z.style.transitionDuration = "400ms" }, 1e3)), r("scrollbarDragEnd", C), k.snapOnRelease && e.slideToClosest()) } function x(C) { const { scrollbar: k, params: b } = e, L = k.el; if (!L) return; const z = L, D = b.passiveListeners ? { passive: !1, capture: !1 } : !1, I = b.passiveListeners ? { passive: !0, capture: !1 } : !1; if (!z) return; const R = C === "on" ? "addEventListener" : "removeEventListener"; z[R]("pointerdown", _, D), s[R]("pointermove", v, D), s[R]("pointerup", w, I) } function S() { !e.params.scrollbar.el || !e.scrollbar.el || x("on") } function P() { !e.params.scrollbar.el || !e.scrollbar.el || x("off") } function A() { const { scrollbar: C, el: k } = e; e.params.scrollbar = Ka(e, e.originalParams.scrollbar, e.params.scrollbar, { el: "swiper-scrollbar" }); const b = e.params.scrollbar; if (!b.el) return; let L; if (typeof b.el == "string" && e.isElement && (L = e.el.querySelector(b.el)), !L && typeof b.el == "string") { if (L = s.querySelectorAll(b.el), !L.length) return } else L || (L = b.el); e.params.uniqueNavElements && typeof b.el == "string" && L.length > 1 && k.querySelectorAll(b.el).length === 1 && (L = k.querySelector(b.el)), L.length > 0 && (L = L[0]), L.classList.add(e.isHorizontal() ? b.horizontalClass : b.verticalClass); let z; L && (z = L.querySelector(fi(e.params.scrollbar.dragClass)), z || (z = Lt("div", e.params.scrollbar.dragClass), L.append(z))), Object.assign(C, { el: L, dragEl: z }), b.draggable && S(), L && L.classList[e.enabled ? "remove" : "add"](...wi(e.params.scrollbar.lockClass)) } function M() { const C = e.params.scrollbar, k = e.scrollbar.el; k && k.classList.remove(...wi(e.isHorizontal() ? C.horizontalClass : C.verticalClass)), P() } i("init", () => { e.params.scrollbar.enabled === !1 ? O() : (A(), h(), p()) }), i("update resize observerUpdate lock unlock", () => { h() }), i("setTranslate", () => { p() }), i("setTransition", (C, k) => { g(k) }), i("enable disable", () => { const { el: C } = e.scrollbar; C && C.classList[e.enabled ? "remove" : "add"](...wi(e.params.scrollbar.lockClass)) }), i("destroy", () => { M() }); const E = () => { e.el.classList.remove(...wi(e.params.scrollbar.scrollbarDisabledClass)), e.scrollbar.el && e.scrollbar.el.classList.remove(...wi(e.params.scrollbar.scrollbarDisabledClass)), A(), h(), p() }, O = () => { e.el.classList.add(...wi(e.params.scrollbar.scrollbarDisabledClass)), e.scrollbar.el && e.scrollbar.el.classList.add(...wi(e.params.scrollbar.scrollbarDisabledClass)), M() }; Object.assign(e.scrollbar, { enable: E, disable: O, updateSize: h, setTranslate: p, init: A, destroy: M }) } function Pf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ parallax: { enabled: !1 } }); const r = "[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]", s = (l, c) => { const { rtl: d } = e, u = d ? -1 : 1, f = l.getAttribute("data-swiper-parallax") || "0"; let p = l.getAttribute("data-swiper-parallax-x"), g = l.getAttribute("data-swiper-parallax-y"); const h = l.getAttribute("data-swiper-parallax-scale"), m = l.getAttribute("data-swiper-parallax-opacity"), y = l.getAttribute("data-swiper-parallax-rotate"); if (p || g ? (p = p || "0", g = g || "0") : e.isHorizontal() ? (p = f, g = "0") : (g = f, p = "0"), p.indexOf("%") >= 0 ? p = `${parseInt(p, 10) * c * u}%` : p = `${p * c * u}px`, g.indexOf("%") >= 0 ? g = `${parseInt(g, 10) * c}%` : g = `${g * c}px`, typeof m < "u" && m !== null) { const v = m - (m - 1) * (1 - Math.abs(c)); l.style.opacity = v } let _ = `translate3d(${p}, ${g}, 0px)`; if (typeof h < "u" && h !== null) { const v = h - (h - 1) * (1 - Math.abs(c)); _ += ` scale(${v})` } if (y && typeof y < "u" && y !== null) { const v = y * c * -1; _ += ` rotate(${v}deg)` } l.style.transform = _ }, a = () => { const { el: l, slides: c, progress: d, snapGrid: u, isElement: f } = e, p = We(l, r); e.isElement && p.push(...We(e.hostEl, r)), p.forEach(g => { s(g, d) }), c.forEach((g, h) => { let m = g.progress; e.params.slidesPerGroup > 1 && e.params.slidesPerView !== "auto" && (m += Math.ceil(h / 2) - d * (u.length - 1)), m = Math.min(Math.max(m, -1), 1), g.querySelectorAll(`${r}, [data-swiper-parallax-rotate]`).forEach(y => { s(y, m) }) }) }, o = function (l) { l === void 0 && (l = e.params.speed); const { el: c, hostEl: d } = e, u = [...c.querySelectorAll(r)]; e.isElement && u.push(...d.querySelectorAll(r)), u.forEach(f => { let p = parseInt(f.getAttribute("data-swiper-parallax-duration"), 10) || l; l === 0 && (p = 0), f.style.transitionDuration = `${p}ms` }) }; i("beforeInit", () => { e.params.parallax.enabled && (e.params.watchSlidesProgress = !0, e.originalParams.watchSlidesProgress = !0) }), i("init", () => { e.params.parallax.enabled && a() }), i("setTranslate", () => { e.params.parallax.enabled && a() }), i("setTransition", (l, c) => { e.params.parallax.enabled && o(c) }) } function Lf(n) { let { swiper: e, extendParams: t, on: i, emit: r } = n; const s = ye(); t({ zoom: { enabled: !1, maxRatio: 3, minRatio: 1, toggle: !0, containerClass: "swiper-zoom-container", zoomedSlideClass: "swiper-slide-zoomed" } }), e.zoom = { enabled: !1 }; let a = 1, o = !1, l, c; const d = [], u = { originX: 0, originY: 0, slideEl: void 0, slideWidth: void 0, slideHeight: void 0, imageEl: void 0, imageWrapEl: void 0, maxRatio: 3 }, f = { isTouched: void 0, isMoved: void 0, currentX: void 0, currentY: void 0, minX: void 0, minY: void 0, maxX: void 0, maxY: void 0, width: void 0, height: void 0, startX: void 0, startY: void 0, touchesStart: {}, touchesCurrent: {} }, p = { x: void 0, y: void 0, prevPositionX: void 0, prevPositionY: void 0, prevTime: void 0 }; let g = 1; Object.defineProperty(e.zoom, "scale", { get() { return g }, set(D) { if (g !== D) { const I = u.imageEl, R = u.slideEl; r("zoomChange", D, I, R) } g = D } }); function h() { if (d.length < 2) return 1; const D = d[0].pageX, I = d[0].pageY, R = d[1].pageX, T = d[1].pageY; return Math.sqrt((R - D) ** 2 + (T - I) ** 2) } function m() { if (d.length < 2) return { x: null, y: null }; const D = u.imageEl.getBoundingClientRect(); return [(d[0].pageX + (d[1].pageX - d[0].pageX) / 2 - D.x - s.scrollX) / a, (d[0].pageY + (d[1].pageY - d[0].pageY) / 2 - D.y - s.scrollY) / a] } function y() { return e.isElement ? "swiper-slide" : `.${e.params.slideClass}` } function _(D) { const I = y(); return !!(D.target.matches(I) || e.slides.filter(R => R.contains(D.target)).length > 0) } function v(D) { const I = `.${e.params.zoom.containerClass}`; return !!(D.target.matches(I) || [...e.hostEl.querySelectorAll(I)].filter(R => R.contains(D.target)).length > 0) } function w(D) { if (D.pointerType === "mouse" && d.splice(0, d.length), !_(D)) return; const I = e.params.zoom; if (l = !1, c = !1, d.push(D), !(d.length < 2)) { if (l = !0, u.scaleStart = h(), !u.slideEl) { u.slideEl = D.target.closest(`.${e.params.slideClass}, swiper-slide`), u.slideEl || (u.slideEl = e.slides[e.activeIndex]); let R = u.slideEl.querySelector(`.${I.containerClass}`); if (R && (R = R.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), u.imageEl = R, R ? u.imageWrapEl = ar(u.imageEl, `.${I.containerClass}`)[0] : u.imageWrapEl = void 0, !u.imageWrapEl) { u.imageEl = void 0; return } u.maxRatio = u.imageWrapEl.getAttribute("data-swiper-zoom") || I.maxRatio } if (u.imageEl) { const [R, T] = m(); u.originX = R, u.originY = T, u.imageEl.style.transitionDuration = "0ms" } o = !0 } } function x(D) { if (!_(D)) return; const I = e.params.zoom, R = e.zoom, T = d.findIndex(q => q.pointerId === D.pointerId); T >= 0 && (d[T] = D), !(d.length < 2) && (c = !0, u.scaleMove = h(), u.imageEl && (R.scale = u.scaleMove / u.scaleStart * a, R.scale > u.maxRatio && (R.scale = u.maxRatio - 1 + (R.scale - u.maxRatio + 1) ** .5), R.scale < I.minRatio && (R.scale = I.minRatio + 1 - (I.minRatio - R.scale + 1) ** .5), u.imageEl.style.transform = `translate3d(0,0,0) scale(${R.scale})`)) } function S(D) { if (!_(D) || D.pointerType === "mouse" && D.type === "pointerout") return; const I = e.params.zoom, R = e.zoom, T = d.findIndex(q => q.pointerId === D.pointerId); T >= 0 && d.splice(T, 1), !(!l || !c) && (l = !1, c = !1, u.imageEl && (R.scale = Math.max(Math.min(R.scale, u.maxRatio), I.minRatio), u.imageEl.style.transitionDuration = `${e.params.speed}ms`, u.imageEl.style.transform = `translate3d(0,0,0) scale(${R.scale})`, a = R.scale, o = !1, R.scale > 1 && u.slideEl ? u.slideEl.classList.add(`${I.zoomedSlideClass}`) : R.scale <= 1 && u.slideEl && u.slideEl.classList.remove(`${I.zoomedSlideClass}`), R.scale === 1 && (u.originX = 0, u.originY = 0, u.slideEl = void 0))) } function P(D) { const I = e.device; if (!u.imageEl || f.isTouched) return; I.android && D.cancelable && D.preventDefault(), f.isTouched = !0; const R = d.length > 0 ? d[0] : D; f.touchesStart.x = R.pageX, f.touchesStart.y = R.pageY } function A(D) { if (!_(D) || !v(D)) return; const I = e.zoom; if (!u.imageEl || !f.isTouched || !u.slideEl) return; f.isMoved || (f.width = u.imageEl.offsetWidth, f.height = u.imageEl.offsetHeight, f.startX = xa(u.imageWrapEl, "x") || 0, f.startY = xa(u.imageWrapEl, "y") || 0, u.slideWidth = u.slideEl.offsetWidth, u.slideHeight = u.slideEl.offsetHeight, u.imageWrapEl.style.transitionDuration = "0ms"); const R = f.width * I.scale, T = f.height * I.scale; if (R < u.slideWidth && T < u.slideHeight) return; if (f.minX = Math.min(u.slideWidth / 2 - R / 2, 0), f.maxX = -f.minX, f.minY = Math.min(u.slideHeight / 2 - T / 2, 0), f.maxY = -f.minY, f.touchesCurrent.x = d.length > 0 ? d[0].pageX : D.pageX, f.touchesCurrent.y = d.length > 0 ? d[0].pageY : D.pageY, Math.max(Math.abs(f.touchesCurrent.x - f.touchesStart.x), Math.abs(f.touchesCurrent.y - f.touchesStart.y)) > 5 && (e.allowClick = !1), !f.isMoved && !o) { if (e.isHorizontal() && (Math.floor(f.minX) === Math.floor(f.startX) && f.touchesCurrent.x < f.touchesStart.x || Math.floor(f.maxX) === Math.floor(f.startX) && f.touchesCurrent.x > f.touchesStart.x)) { f.isTouched = !1; return } if (!e.isHorizontal() && (Math.floor(f.minY) === Math.floor(f.startY) && f.touchesCurrent.y < f.touchesStart.y || Math.floor(f.maxY) === Math.floor(f.startY) && f.touchesCurrent.y > f.touchesStart.y)) { f.isTouched = !1; return } } D.cancelable && D.preventDefault(), D.stopPropagation(), f.isMoved = !0; const ie = (I.scale - a) / (u.maxRatio - e.params.zoom.minRatio), { originX: N, originY: Y } = u; f.currentX = f.touchesCurrent.x - f.touchesStart.x + f.startX + ie * (f.width - N * 2), f.currentY = f.touchesCurrent.y - f.touchesStart.y + f.startY + ie * (f.height - Y * 2), f.currentX < f.minX && (f.currentX = f.minX + 1 - (f.minX - f.currentX + 1) ** .8), f.currentX > f.maxX && (f.currentX = f.maxX - 1 + (f.currentX - f.maxX + 1) ** .8), f.currentY < f.minY && (f.currentY = f.minY + 1 - (f.minY - f.currentY + 1) ** .8), f.currentY > f.maxY && (f.currentY = f.maxY - 1 + (f.currentY - f.maxY + 1) ** .8), p.prevPositionX || (p.prevPositionX = f.touchesCurrent.x), p.prevPositionY || (p.prevPositionY = f.touchesCurrent.y), p.prevTime || (p.prevTime = Date.now()), p.x = (f.touchesCurrent.x - p.prevPositionX) / (Date.now() - p.prevTime) / 2, p.y = (f.touchesCurrent.y - p.prevPositionY) / (Date.now() - p.prevTime) / 2, Math.abs(f.touchesCurrent.x - p.prevPositionX) < 2 && (p.x = 0), Math.abs(f.touchesCurrent.y - p.prevPositionY) < 2 && (p.y = 0), p.prevPositionX = f.touchesCurrent.x, p.prevPositionY = f.touchesCurrent.y, p.prevTime = Date.now(), u.imageWrapEl.style.transform = `translate3d(${f.currentX}px, ${f.currentY}px,0)` } function M() { const D = e.zoom; if (!u.imageEl) return; if (!f.isTouched || !f.isMoved) { f.isTouched = !1, f.isMoved = !1; return } f.isTouched = !1, f.isMoved = !1; let I = 300, R = 300; const T = p.x * I, q = f.currentX + T, ie = p.y * R, N = f.currentY + ie; p.x !== 0 && (I = Math.abs((q - f.currentX) / p.x)), p.y !== 0 && (R = Math.abs((N - f.currentY) / p.y)); const Y = Math.max(I, R); f.currentX = q, f.currentY = N; const se = f.width * D.scale, de = f.height * D.scale; f.minX = Math.min(u.slideWidth / 2 - se / 2, 0), f.maxX = -f.minX, f.minY = Math.min(u.slideHeight / 2 - de / 2, 0), f.maxY = -f.minY, f.currentX = Math.max(Math.min(f.currentX, f.maxX), f.minX), f.currentY = Math.max(Math.min(f.currentY, f.maxY), f.minY), u.imageWrapEl.style.transitionDuration = `${Y}ms`, u.imageWrapEl.style.transform = `translate3d(${f.currentX}px, ${f.currentY}px,0)` } function E() { const D = e.zoom; u.slideEl && e.activeIndex !== e.slides.indexOf(u.slideEl) && (u.imageEl && (u.imageEl.style.transform = "translate3d(0,0,0) scale(1)"), u.imageWrapEl && (u.imageWrapEl.style.transform = "translate3d(0,0,0)"), u.slideEl.classList.remove(`${e.params.zoom.zoomedSlideClass}`), D.scale = 1, a = 1, u.slideEl = void 0, u.imageEl = void 0, u.imageWrapEl = void 0, u.originX = 0, u.originY = 0) } function O(D) { const I = e.zoom, R = e.params.zoom; if (!u.slideEl) { D && D.target && (u.slideEl = D.target.closest(`.${e.params.slideClass}, swiper-slide`)), u.slideEl || (e.params.virtual && e.params.virtual.enabled && e.virtual ? u.slideEl = We(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : u.slideEl = e.slides[e.activeIndex]); let tt = u.slideEl.querySelector(`.${R.containerClass}`); tt && (tt = tt.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), u.imageEl = tt, tt ? u.imageWrapEl = ar(u.imageEl, `.${R.containerClass}`)[0] : u.imageWrapEl = void 0 } if (!u.imageEl || !u.imageWrapEl) return; e.params.cssMode && (e.wrapperEl.style.overflow = "hidden", e.wrapperEl.style.touchAction = "none"), u.slideEl.classList.add(`${R.zoomedSlideClass}`); let T, q, ie, N, Y, se, de, ne, De, Pe, qt, Ie, et, W, ue, ze, Ve, $; typeof f.touchesStart.x > "u" && D ? (T = D.pageX, q = D.pageY) : (T = f.touchesStart.x, q = f.touchesStart.y); const Le = typeof D == "number" ? D : null; a === 1 && Le && (T = void 0, q = void 0), I.scale = Le || u.imageWrapEl.getAttribute("data-swiper-zoom") || R.maxRatio, a = Le || u.imageWrapEl.getAttribute("data-swiper-zoom") || R.maxRatio, D && !(a === 1 && Le) ? (Ve = u.slideEl.offsetWidth, $ = u.slideEl.offsetHeight, ie = vn(u.slideEl).left + s.scrollX, N = vn(u.slideEl).top + s.scrollY, Y = ie + Ve / 2 - T, se = N + $ / 2 - q, De = u.imageEl.offsetWidth, Pe = u.imageEl.offsetHeight, qt = De * I.scale, Ie = Pe * I.scale, et = Math.min(Ve / 2 - qt / 2, 0), W = Math.min($ / 2 - Ie / 2, 0), ue = -et, ze = -W, de = Y * I.scale, ne = se * I.scale, de < et && (de = et), de > ue && (de = ue), ne < W && (ne = W), ne > ze && (ne = ze)) : (de = 0, ne = 0), Le && I.scale === 1 && (u.originX = 0, u.originY = 0), u.imageWrapEl.style.transitionDuration = "300ms", u.imageWrapEl.style.transform = `translate3d(${de}px, ${ne}px,0)`, u.imageEl.style.transitionDuration = "300ms", u.imageEl.style.transform = `translate3d(0,0,0) scale(${I.scale})` } function C() { const D = e.zoom, I = e.params.zoom; if (!u.slideEl) { e.params.virtual && e.params.virtual.enabled && e.virtual ? u.slideEl = We(e.slidesEl, `.${e.params.slideActiveClass}`)[0] : u.slideEl = e.slides[e.activeIndex]; let R = u.slideEl.querySelector(`.${I.containerClass}`); R && (R = R.querySelectorAll("picture, img, svg, canvas, .swiper-zoom-target")[0]), u.imageEl = R, R ? u.imageWrapEl = ar(u.imageEl, `.${I.containerClass}`)[0] : u.imageWrapEl = void 0 } !u.imageEl || !u.imageWrapEl || (e.params.cssMode && (e.wrapperEl.style.overflow = "", e.wrapperEl.style.touchAction = ""), D.scale = 1, a = 1, u.imageWrapEl.style.transitionDuration = "300ms", u.imageWrapEl.style.transform = "translate3d(0,0,0)", u.imageEl.style.transitionDuration = "300ms", u.imageEl.style.transform = "translate3d(0,0,0) scale(1)", u.slideEl.classList.remove(`${I.zoomedSlideClass}`), u.slideEl = void 0, u.originX = 0, u.originY = 0) } function k(D) { const I = e.zoom; I.scale && I.scale !== 1 ? C() : O(D) } function b() { const D = e.params.passiveListeners ? { passive: !0, capture: !1 } : !1, I = e.params.passiveListeners ? { passive: !1, capture: !0 } : !0; return { passiveListener: D, activeListenerWithCapture: I } } function L() { const D = e.zoom; if (D.enabled) return; D.enabled = !0; const { passiveListener: I, activeListenerWithCapture: R } = b(); e.wrapperEl.addEventListener("pointerdown", w, I), e.wrapperEl.addEventListener("pointermove", x, R), ["pointerup", "pointercancel", "pointerout"].forEach(T => { e.wrapperEl.addEventListener(T, S, I) }), e.wrapperEl.addEventListener("pointermove", A, R) } function z() { const D = e.zoom; if (!D.enabled) return; D.enabled = !1; const { passiveListener: I, activeListenerWithCapture: R } = b(); e.wrapperEl.removeEventListener("pointerdown", w, I), e.wrapperEl.removeEventListener("pointermove", x, R), ["pointerup", "pointercancel", "pointerout"].forEach(T => { e.wrapperEl.removeEventListener(T, S, I) }), e.wrapperEl.removeEventListener("pointermove", A, R) } i("init", () => { e.params.zoom.enabled && L() }), i("destroy", () => { z() }), i("touchStart", (D, I) => { e.zoom.enabled && P(I) }), i("touchEnd", (D, I) => { e.zoom.enabled && M() }), i("doubleTap", (D, I) => { !e.animating && e.params.zoom.enabled && e.zoom.enabled && e.params.zoom.toggle && k(I) }), i("transitionEnd", () => { e.zoom.enabled && e.params.zoom.enabled && E() }), i("slideChange", () => { e.zoom.enabled && e.params.zoom.enabled && e.params.cssMode && E() }), Object.assign(e.zoom, { enable: L, disable: z, in: O, out: C, toggle: k }) } function Af(n) { let { swiper: e, extendParams: t, on: i } = n; t({ controller: { control: void 0, inverse: !1, by: "slide" } }), e.controller = { control: void 0 }; function r(c, d) { const u = function () { let h, m, y; return (_, v) => { for (m = -1, h = _.length; h - m > 1;)y = h + m >> 1, _[y] <= v ? m = y : h = y; return h } }(); this.x = c, this.y = d, this.lastIndex = c.length - 1; let f, p; return this.interpolate = function (h) { return h ? (p = u(this.x, h), f = p - 1, (h - this.x[f]) * (this.y[p] - this.y[f]) / (this.x[p] - this.x[f]) + this.y[f]) : 0 }, this } function s(c) { e.controller.spline = e.params.loop ? new r(e.slidesGrid, c.slidesGrid) : new r(e.snapGrid, c.snapGrid) } function a(c, d) { const u = e.controller.control; let f, p; const g = e.constructor; function h(m) { if (m.destroyed) return; const y = e.rtlTranslate ? -e.translate : e.translate; e.params.controller.by === "slide" && (s(m), p = -e.controller.spline.interpolate(-y)), (!p || e.params.controller.by === "container") && (f = (m.maxTranslate() - m.minTranslate()) / (e.maxTranslate() - e.minTranslate()), (Number.isNaN(f) || !Number.isFinite(f)) && (f = 1), p = (y - e.minTranslate()) * f + m.minTranslate()), e.params.controller.inverse && (p = m.maxTranslate() - p), m.updateProgress(p), m.setTranslate(p, e), m.updateActiveIndex(), m.updateSlidesClasses() } if (Array.isArray(u)) for (let m = 0; m < u.length; m += 1)u[m] !== d && u[m] instanceof g && h(u[m]); else u instanceof g && d !== u && h(u) } function o(c, d) { const u = e.constructor, f = e.controller.control; let p; function g(h) { h.destroyed || (h.setTransition(c, e), c !== 0 && (h.transitionStart(), h.params.autoHeight && pr(() => { h.updateAutoHeight() }), ms(h.wrapperEl, () => { f && h.transitionEnd() }))) } if (Array.isArray(f)) for (p = 0; p < f.length; p += 1)f[p] !== d && f[p] instanceof u && g(f[p]); else f instanceof u && d !== f && g(f) } function l() { e.controller.control && e.controller.spline && (e.controller.spline = void 0, delete e.controller.spline) } i("beforeInit", () => { if (typeof window < "u" && (typeof e.params.controller.control == "string" || e.params.controller.control instanceof HTMLElement)) { const c = document.querySelector(e.params.controller.control); if (c && c.swiper) e.controller.control = c.swiper; else if (c) { const d = u => { e.controller.control = u.detail[0], e.update(), c.removeEventListener("init", d) }; c.addEventListener("init", d) } return } e.controller.control = e.params.controller.control }), i("update", () => { l() }), i("resize", () => { l() }), i("observerUpdate", () => { l() }), i("setTranslate", (c, d, u) => { !e.controller.control || e.controller.control.destroyed || e.controller.setTranslate(d, u) }), i("setTransition", (c, d, u) => { !e.controller.control || e.controller.control.destroyed || e.controller.setTransition(d, u) }), Object.assign(e.controller, { setTranslate: a, setTransition: o }) } function kf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ a11y: { enabled: !0, notificationClass: "swiper-notification", prevSlideMessage: "Previous slide", nextSlideMessage: "Next slide", firstSlideMessage: "This is the first slide", lastSlideMessage: "This is the last slide", paginationBulletMessage: "Go to slide {{index}}", slideLabelMessage: "{{index}} / {{slidesLength}}", containerMessage: null, containerRoleDescriptionMessage: null, itemRoleDescriptionMessage: null, slideRole: "group", id: null } }), e.a11y = { clicked: !1 }; let r = null; function s(b) { const L = r; L.length !== 0 && (L.innerHTML = "", L.innerHTML = b) } const a = b => (Array.isArray(b) ? b : [b]).filter(L => !!L); function o(b) { b === void 0 && (b = 16); const L = () => Math.round(16 * Math.random()).toString(16); return "x".repeat(b).replace(/x/g, L) } function l(b) { b = a(b), b.forEach(L => { L.setAttribute("tabIndex", "0") }) } function c(b) { b = a(b), b.forEach(L => { L.setAttribute("tabIndex", "-1") }) } function d(b, L) { b = a(b), b.forEach(z => { z.setAttribute("role", L) }) } function u(b, L) { b = a(b), b.forEach(z => { z.setAttribute("aria-roledescription", L) }) } function f(b, L) { b = a(b), b.forEach(z => { z.setAttribute("aria-controls", L) }) } function p(b, L) { b = a(b), b.forEach(z => { z.setAttribute("aria-label", L) }) } function g(b, L) { b = a(b), b.forEach(z => { z.setAttribute("id", L) }) } function h(b, L) { b = a(b), b.forEach(z => { z.setAttribute("aria-live", L) }) } function m(b) { b = a(b), b.forEach(L => { L.setAttribute("aria-disabled", !0) }) } function y(b) { b = a(b), b.forEach(L => { L.setAttribute("aria-disabled", !1) }) } function _(b) { if (b.keyCode !== 13 && b.keyCode !== 32) return; const L = e.params.a11y, z = b.target; e.pagination && e.pagination.el && (z === e.pagination.el || e.pagination.el.contains(b.target)) && !b.target.matches(fi(e.params.pagination.bulletClass)) || (e.navigation && e.navigation.nextEl && z === e.navigation.nextEl && (e.isEnd && !e.params.loop || e.slideNext(), e.isEnd ? s(L.lastSlideMessage) : s(L.nextSlideMessage)), e.navigation && e.navigation.prevEl && z === e.navigation.prevEl && (e.isBeginning && !e.params.loop || e.slidePrev(), e.isBeginning ? s(L.firstSlideMessage) : s(L.prevSlideMessage)), e.pagination && z.matches(fi(e.params.pagination.bulletClass)) && z.click()) } function v() { if (e.params.loop || e.params.rewind || !e.navigation) return; const { nextEl: b, prevEl: L } = e.navigation; L && (e.isBeginning ? (m(L), c(L)) : (y(L), l(L))), b && (e.isEnd ? (m(b), c(b)) : (y(b), l(b))) } function w() { return e.pagination && e.pagination.bullets && e.pagination.bullets.length } function x() { return w() && e.params.pagination.clickable } function S() { const b = e.params.a11y; w() && e.pagination.bullets.forEach(L => { e.params.pagination.clickable && (l(L), e.params.pagination.renderBullet || (d(L, "button"), p(L, b.paginationBulletMessage.replace(/\{\{index\}\}/, Cs(L) + 1)))), L.matches(fi(e.params.pagination.bulletActiveClass)) ? L.setAttribute("aria-current", "true") : L.removeAttribute("aria-current") }) } const P = (b, L, z) => { l(b), b.tagName !== "BUTTON" && (d(b, "button"), b.addEventListener("keydown", _)), p(b, z), f(b, L) }, A = () => { e.a11y.clicked = !0 }, M = () => { requestAnimationFrame(() => { requestAnimationFrame(() => { e.destroyed || (e.a11y.clicked = !1) }) }) }, E = b => { if (e.a11y.clicked) return; const L = b.target.closest(`.${e.params.slideClass}, swiper-slide`); if (!L || !e.slides.includes(L)) return; const z = e.slides.indexOf(L) === e.activeIndex, D = e.params.watchSlidesProgress && e.visibleSlides && e.visibleSlides.includes(L); z || D || b.sourceCapabilities && b.sourceCapabilities.firesTouchEvents || (e.isHorizontal() ? e.el.scrollLeft = 0 : e.el.scrollTop = 0, e.slideTo(e.slides.indexOf(L), 0)) }, O = () => { const b = e.params.a11y; b.itemRoleDescriptionMessage && u(e.slides, b.itemRoleDescriptionMessage), b.slideRole && d(e.slides, b.slideRole); const L = e.slides.length; b.slideLabelMessage && e.slides.forEach((z, D) => { const I = e.params.loop ? parseInt(z.getAttribute("data-swiper-slide-index"), 10) : D, R = b.slideLabelMessage.replace(/\{\{index\}\}/, I + 1).replace(/\{\{slidesLength\}\}/, L); p(z, R) }) }, C = () => { const b = e.params.a11y; e.el.append(r); const L = e.el; b.containerRoleDescriptionMessage && u(L, b.containerRoleDescriptionMessage), b.containerMessage && p(L, b.containerMessage); const z = e.wrapperEl, D = b.id || z.getAttribute("id") || `swiper-wrapper-${o(16)}`, I = e.params.autoplay && e.params.autoplay.enabled ? "off" : "polite"; g(z, D), h(z, I), O(); let { nextEl: R, prevEl: T } = e.navigation ? e.navigation : {}; R = a(R), T = a(T), R && R.forEach(q => P(q, D, b.nextSlideMessage)), T && T.forEach(q => P(q, D, b.prevSlideMessage)), x() && a(e.pagination.el).forEach(ie => { ie.addEventListener("keydown", _) }), e.el.addEventListener("focus", E, !0), e.el.addEventListener("pointerdown", A, !0), e.el.addEventListener("pointerup", M, !0) }; function k() { r && r.remove(); let { nextEl: b, prevEl: L } = e.navigation ? e.navigation : {}; b = a(b), L = a(L), b && b.forEach(z => z.removeEventListener("keydown", _)), L && L.forEach(z => z.removeEventListener("keydown", _)), x() && a(e.pagination.el).forEach(D => { D.removeEventListener("keydown", _) }), e.el.removeEventListener("focus", E, !0), e.el.removeEventListener("pointerdown", A, !0), e.el.removeEventListener("pointerup", M, !0) } i("beforeInit", () => { r = Lt("span", e.params.a11y.notificationClass), r.setAttribute("aria-live", "assertive"), r.setAttribute("aria-atomic", "true") }), i("afterInit", () => { e.params.a11y.enabled && C() }), i("slidesLengthChange snapGridLengthChange slidesGridLengthChange", () => { e.params.a11y.enabled && O() }), i("fromEdge toEdge afterInit lock unlock", () => { e.params.a11y.enabled && v() }), i("paginationUpdate", () => { e.params.a11y.enabled && S() }), i("destroy", () => { e.params.a11y.enabled && k() }) } function Of(n) { let { swiper: e, extendParams: t, on: i } = n; t({ history: { enabled: !1, root: "", replaceState: !1, key: "slides", keepQuery: !1 } }); let r = !1, s = {}; const a = p => p.toString().replace(/\s+/g, "-").replace(/[^\w-]+/g, "").replace(/--+/g, "-").replace(/^-+/, "").replace(/-+$/, ""), o = p => { const g = ye(); let h; p ? h = new URL(p) : h = g.location; const m = h.pathname.slice(1).split("/").filter(w => w !== ""), y = m.length, _ = m[y - 2], v = m[y - 1]; return { key: _, value: v } }, l = (p, g) => { const h = ye(); if (!r || !e.params.history.enabled) return; let m; e.params.url ? m = new URL(e.params.url) : m = h.location; const y = e.slides[g]; let _ = a(y.getAttribute("data-history")); if (e.params.history.root.length > 0) { let w = e.params.history.root; w[w.length - 1] === "/" && (w = w.slice(0, w.length - 1)), _ = `${w}/${p ? `${p}/` : ""}${_}` } else m.pathname.includes(p) || (_ = `${p ? `${p}/` : ""}${_}`); e.params.history.keepQuery && (_ += m.search); const v = h.history.state; v && v.value === _ || (e.params.history.replaceState ? h.history.replaceState({ value: _ }, null, _) : h.history.pushState({ value: _ }, null, _)) }, c = (p, g, h) => { if (g) for (let m = 0, y = e.slides.length; m < y; m += 1) { const _ = e.slides[m]; if (a(_.getAttribute("data-history")) === g) { const w = e.getSlideIndex(_); e.slideTo(w, p, h) } } else e.slideTo(0, p, h) }, d = () => { s = o(e.params.url), c(e.params.speed, s.value, !1) }, u = () => { const p = ye(); if (e.params.history) { if (!p.history || !p.history.pushState) { e.params.history.enabled = !1, e.params.hashNavigation.enabled = !0; return } if (r = !0, s = o(e.params.url), !s.key && !s.value) { e.params.history.replaceState || p.addEventListener("popstate", d); return } c(0, s.value, e.params.runCallbacksOnInit), e.params.history.replaceState || p.addEventListener("popstate", d) } }, f = () => { const p = ye(); e.params.history.replaceState || p.removeEventListener("popstate", d) }; i("init", () => { e.params.history.enabled && u() }), i("destroy", () => { e.params.history.enabled && f() }), i("transitionEnd _freeModeNoMomentumRelease", () => { r && l(e.params.history.key, e.activeIndex) }), i("slideChange", () => { r && e.params.cssMode && l(e.params.history.key, e.activeIndex) }) } function Df(n) { let { swiper: e, extendParams: t, emit: i, on: r } = n, s = !1; const a = ft(), o = ye(); t({ hashNavigation: { enabled: !1, replaceState: !1, watchState: !1, getSlideIndex(f, p) { if (e.virtual && e.params.virtual.enabled) { const g = e.slides.filter(m => m.getAttribute("data-hash") === p)[0]; return g ? parseInt(g.getAttribute("data-swiper-slide-index"), 10) : 0 } return e.getSlideIndex(We(e.slidesEl, `.${e.params.slideClass}[data-hash="${p}"], swiper-slide[data-hash="${p}"]`)[0]) } } }); const l = () => { i("hashChange"); const f = a.location.hash.replace("#", ""), p = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${e.activeIndex}"]`) : e.slides[e.activeIndex], g = p ? p.getAttribute("data-hash") : ""; if (f !== g) { const h = e.params.hashNavigation.getSlideIndex(e, f); if (typeof h > "u" || Number.isNaN(h)) return; e.slideTo(h) } }, c = () => { if (!s || !e.params.hashNavigation.enabled) return; const f = e.virtual && e.params.virtual.enabled ? e.slidesEl.querySelector(`[data-swiper-slide-index="${e.activeIndex}"]`) : e.slides[e.activeIndex], p = f ? f.getAttribute("data-hash") || f.getAttribute("data-history") : ""; e.params.hashNavigation.replaceState && o.history && o.history.replaceState ? (o.history.replaceState(null, null, `#${p}` || ""), i("hashSet")) : (a.location.hash = p || "", i("hashSet")) }, d = () => { if (!e.params.hashNavigation.enabled || e.params.history && e.params.history.enabled) return; s = !0; const f = a.location.hash.replace("#", ""); if (f) { const g = e.params.hashNavigation.getSlideIndex(e, f); e.slideTo(g || 0, 0, e.params.runCallbacksOnInit, !0) } e.params.hashNavigation.watchState && o.addEventListener("hashchange", l) }, u = () => { e.params.hashNavigation.watchState && o.removeEventListener("hashchange", l) }; r("init", () => { e.params.hashNavigation.enabled && d() }), r("destroy", () => { e.params.hashNavigation.enabled && u() }), r("transitionEnd _freeModeNoMomentumRelease", () => { s && c() }), r("slideChange", () => { s && e.params.cssMode && c() }) } function If(n) { let { swiper: e, extendParams: t, on: i, emit: r, params: s } = n; e.autoplay = { running: !1, paused: !1, timeLeft: 0 }, t({ autoplay: { enabled: !1, delay: 3e3, waitForTransition: !0, disableOnInteraction: !1, stopOnLastSlide: !1, reverseDirection: !1, pauseOnMouseEnter: !1 } }); let a, o, l = s && s.autoplay ? s.autoplay.delay : 3e3, c = s && s.autoplay ? s.autoplay.delay : 3e3, d, u = new Date().getTime(), f, p, g, h, m, y, _; function v(I) { !e || e.destroyed || !e.wrapperEl || I.target === e.wrapperEl && (e.wrapperEl.removeEventListener("transitionend", v), !_ && E()) } const w = () => { if (e.destroyed || !e.autoplay.running) return; e.autoplay.paused ? f = !0 : f && (c = d, f = !1); const I = e.autoplay.paused ? d : u + c - new Date().getTime(); e.autoplay.timeLeft = I, r("autoplayTimeLeft", I, I / l), o = requestAnimationFrame(() => { w() }) }, x = () => { let I; return e.virtual && e.params.virtual.enabled ? I = e.slides.filter(T => T.classList.contains("swiper-slide-active"))[0] : I = e.slides[e.activeIndex], I ? parseInt(I.getAttribute("data-swiper-autoplay"), 10) : void 0 }, S = I => { if (e.destroyed || !e.autoplay.running) return; cancelAnimationFrame(o), w(); let R = typeof I > "u" ? e.params.autoplay.delay : I; l = e.params.autoplay.delay, c = e.params.autoplay.delay; const T = x(); !Number.isNaN(T) && T > 0 && typeof I > "u" && (R = T, l = T, c = T), d = R; const q = e.params.speed, ie = () => { !e || e.destroyed || (e.params.autoplay.reverseDirection ? !e.isBeginning || e.params.loop || e.params.rewind ? (e.slidePrev(q, !0, !0), r("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(e.slides.length - 1, q, !0, !0), r("autoplay")) : !e.isEnd || e.params.loop || e.params.rewind ? (e.slideNext(q, !0, !0), r("autoplay")) : e.params.autoplay.stopOnLastSlide || (e.slideTo(0, q, !0, !0), r("autoplay")), e.params.cssMode && (u = new Date().getTime(), requestAnimationFrame(() => { S() }))) }; return R > 0 ? (clearTimeout(a), a = setTimeout(() => { ie() }, R)) : requestAnimationFrame(() => { ie() }), R }, P = () => { u = new Date().getTime(), e.autoplay.running = !0, S(), r("autoplayStart") }, A = () => { e.autoplay.running = !1, clearTimeout(a), cancelAnimationFrame(o), r("autoplayStop") }, M = (I, R) => { if (e.destroyed || !e.autoplay.running) return; clearTimeout(a), I || (y = !0); const T = () => { r("autoplayPause"), e.params.autoplay.waitForTransition ? e.wrapperEl.addEventListener("transitionend", v) : E() }; if (e.autoplay.paused = !0, R) { m && (d = e.params.autoplay.delay), m = !1, T(); return } d = (d || e.params.autoplay.delay) - (new Date().getTime() - u), !(e.isEnd && d < 0 && !e.params.loop) && (d < 0 && (d = 0), T()) }, E = () => { e.isEnd && d < 0 && !e.params.loop || e.destroyed || !e.autoplay.running || (u = new Date().getTime(), y ? (y = !1, S(d)) : S(), e.autoplay.paused = !1, r("autoplayResume")) }, O = () => { if (e.destroyed || !e.autoplay.running) return; const I = ft(); I.visibilityState === "hidden" && (y = !0, M(!0)), I.visibilityState === "visible" && E() }, C = I => { I.pointerType === "mouse" && (y = !0, _ = !0, !(e.animating || e.autoplay.paused) && M(!0)) }, k = I => { I.pointerType === "mouse" && (_ = !1, e.autoplay.paused && E()) }, b = () => { e.params.autoplay.pauseOnMouseEnter && (e.el.addEventListener("pointerenter", C), e.el.addEventListener("pointerleave", k)) }, L = () => { e.el.removeEventListener("pointerenter", C), e.el.removeEventListener("pointerleave", k) }, z = () => { ft().addEventListener("visibilitychange", O) }, D = () => { ft().removeEventListener("visibilitychange", O) }; i("init", () => { e.params.autoplay.enabled && (b(), z(), P()) }), i("destroy", () => { L(), D(), e.autoplay.running && A() }), i("_freeModeStaticRelease", () => { (g || y) && E() }), i("_freeModeNoMomentumRelease", () => { e.params.autoplay.disableOnInteraction ? A() : M(!0, !0) }), i("beforeTransitionStart", (I, R, T) => { e.destroyed || !e.autoplay.running || (T || !e.params.autoplay.disableOnInteraction ? M(!0, !0) : A()) }), i("sliderFirstMove", () => { if (!(e.destroyed || !e.autoplay.running)) { if (e.params.autoplay.disableOnInteraction) { A(); return } p = !0, g = !1, y = !1, h = setTimeout(() => { y = !0, g = !0, M(!0) }, 200) } }), i("touchEnd", () => { if (!(e.destroyed || !e.autoplay.running || !p)) { if (clearTimeout(h), clearTimeout(a), e.params.autoplay.disableOnInteraction) { g = !1, p = !1; return } g && e.params.cssMode && E(), g = !1, p = !1 } }), i("slideChange", () => { e.destroyed || !e.autoplay.running || (m = !0) }), Object.assign(e.autoplay, { start: P, stop: A, pause: M, resume: E }) } function zf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ thumbs: { swiper: null, multipleActiveThumbs: !0, autoScrollOffset: 0, slideThumbActiveClass: "swiper-slide-thumb-active", thumbsContainerClass: "swiper-thumbs" } }); let r = !1, s = !1; e.thumbs = { swiper: null }; function a() { const c = e.thumbs.swiper; if (!c || c.destroyed) return; const d = c.clickedIndex, u = c.clickedSlide; if (u && u.classList.contains(e.params.thumbs.slideThumbActiveClass) || typeof d > "u" || d === null) return; let f; c.params.loop ? f = parseInt(c.clickedSlide.getAttribute("data-swiper-slide-index"), 10) : f = d, e.params.loop ? e.slideToLoop(f) : e.slideTo(f) } function o() { const { thumbs: c } = e.params; if (r) return !1; r = !0; const d = e.constructor; if (c.swiper instanceof d) e.thumbs.swiper = c.swiper, Object.assign(e.thumbs.swiper.originalParams, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), Object.assign(e.thumbs.swiper.params, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), e.thumbs.swiper.update(); else if (es(c.swiper)) { const u = Object.assign({}, c.swiper); Object.assign(u, { watchSlidesProgress: !0, slideToClickedSlide: !1 }), e.thumbs.swiper = new d(u), s = !0 } return e.thumbs.swiper.el.classList.add(e.params.thumbs.thumbsContainerClass), e.thumbs.swiper.on("tap", a), !0 } function l(c) { const d = e.thumbs.swiper; if (!d || d.destroyed) return; const u = d.params.slidesPerView === "auto" ? d.slidesPerViewDynamic() : d.params.slidesPerView; let f = 1; const p = e.params.thumbs.slideThumbActiveClass; if (e.params.slidesPerView > 1 && !e.params.centeredSlides && (f = e.params.slidesPerView), e.params.thumbs.multipleActiveThumbs || (f = 1), f = Math.floor(f), d.slides.forEach(m => m.classList.remove(p)), d.params.loop || d.params.virtual && d.params.virtual.enabled) for (let m = 0; m < f; m += 1)We(d.slidesEl, `[data-swiper-slide-index="${e.realIndex + m}"]`).forEach(y => { y.classList.add(p) }); else for (let m = 0; m < f; m += 1)d.slides[e.realIndex + m] && d.slides[e.realIndex + m].classList.add(p); const g = e.params.thumbs.autoScrollOffset, h = g && !d.params.loop; if (e.realIndex !== d.realIndex || h) { const m = d.activeIndex; let y, _; if (d.params.loop) { const v = d.slides.filter(w => w.getAttribute("data-swiper-slide-index") === `${e.realIndex}`)[0]; y = d.slides.indexOf(v), _ = e.activeIndex > e.previousIndex ? "next" : "prev" } else y = e.realIndex, _ = y > e.previousIndex ? "next" : "prev"; h && (y += _ === "next" ? g : -1 * g), d.visibleSlidesIndexes && d.visibleSlidesIndexes.indexOf(y) < 0 && (d.params.centeredSlides ? y > m ? y = y - Math.floor(u / 2) + 1 : y = y + Math.floor(u / 2) - 1 : y > m && d.params.slidesPerGroup, d.slideTo(y, c ? 0 : void 0)) } } i("beforeInit", () => { const { thumbs: c } = e.params; if (!(!c || !c.swiper)) if (typeof c.swiper == "string" || c.swiper instanceof HTMLElement) { const d = ft(), u = () => { const p = typeof c.swiper == "string" ? d.querySelector(c.swiper) : c.swiper; if (p && p.swiper) c.swiper = p.swiper, o(), l(!0); else if (p) { const g = h => { c.swiper = h.detail[0], p.removeEventListener("init", g), o(), l(!0), c.swiper.update(), e.update() }; p.addEventListener("init", g) } return p }, f = () => { if (e.destroyed) return; u() || requestAnimationFrame(f) }; requestAnimationFrame(f) } else o(), l(!0) }), i("slideChange update resize observerUpdate", () => { l() }), i("setTransition", (c, d) => { const u = e.thumbs.swiper; !u || u.destroyed || u.setTransition(d) }), i("beforeDestroy", () => { const c = e.thumbs.swiper; !c || c.destroyed || s && c.destroy() }), Object.assign(e.thumbs, { init: o, update: l }) } function Rf(n) { let { swiper: e, extendParams: t, emit: i, once: r } = n; t({ freeMode: { enabled: !1, momentum: !0, momentumRatio: 1, momentumBounce: !0, momentumBounceRatio: 1, momentumVelocityRatio: 1, sticky: !1, minimumVelocity: .02 } }); function s() { if (e.params.cssMode) return; const l = e.getTranslate(); e.setTranslate(l), e.setTransition(0), e.touchEventsData.velocities.length = 0, e.freeMode.onTouchEnd({ currentPos: e.rtl ? e.translate : -e.translate }) } function a() { if (e.params.cssMode) return; const { touchEventsData: l, touches: c } = e; l.velocities.length === 0 && l.velocities.push({ position: c[e.isHorizontal() ? "startX" : "startY"], time: l.touchStartTime }), l.velocities.push({ position: c[e.isHorizontal() ? "currentX" : "currentY"], time: Rt() }) } function o(l) { let { currentPos: c } = l; if (e.params.cssMode) return; const { params: d, wrapperEl: u, rtlTranslate: f, snapGrid: p, touchEventsData: g } = e, m = Rt() - g.touchStartTime; if (c < -e.minTranslate()) { e.slideTo(e.activeIndex); return } if (c > -e.maxTranslate()) { e.slides.length < p.length ? e.slideTo(p.length - 1) : e.slideTo(e.slides.length - 1); return } if (d.freeMode.momentum) { if (g.velocities.length > 1) { const A = g.velocities.pop(), M = g.velocities.pop(), E = A.position - M.position, O = A.time - M.time; e.velocity = E / O, e.velocity /= 2, Math.abs(e.velocity) < d.freeMode.minimumVelocity && (e.velocity = 0), (O > 150 || Rt() - A.time > 300) && (e.velocity = 0) } else e.velocity = 0; e.velocity *= d.freeMode.momentumVelocityRatio, g.velocities.length = 0; let y = 1e3 * d.freeMode.momentumRatio; const _ = e.velocity * y; let v = e.translate + _; f && (v = -v); let w = !1, x; const S = Math.abs(e.velocity) * 20 * d.freeMode.momentumBounceRatio; let P; if (v < e.maxTranslate()) d.freeMode.momentumBounce ? (v + e.maxTranslate() < -S && (v = e.maxTranslate() - S), x = e.maxTranslate(), w = !0, g.allowMomentumBounce = !0) : v = e.maxTranslate(), d.loop && d.centeredSlides && (P = !0); else if (v > e.minTranslate()) d.freeMode.momentumBounce ? (v - e.minTranslate() > S && (v = e.minTranslate() + S), x = e.minTranslate(), w = !0, g.allowMomentumBounce = !0) : v = e.minTranslate(), d.loop && d.centeredSlides && (P = !0); else if (d.freeMode.sticky) { let A; for (let M = 0; M < p.length; M += 1)if (p[M] > -v) { A = M; break } Math.abs(p[A] - v) < Math.abs(p[A - 1] - v) || e.swipeDirection === "next" ? v = p[A] : v = p[A - 1], v = -v } if (P && r("transitionEnd", () => { e.loopFix() }), e.velocity !== 0) { if (f ? y = Math.abs((-v - e.translate) / e.velocity) : y = Math.abs((v - e.translate) / e.velocity), d.freeMode.sticky) { const A = Math.abs((f ? -v : v) - e.translate), M = e.slidesSizesGrid[e.activeIndex]; A < M ? y = d.speed : A < 2 * M ? y = d.speed * 1.5 : y = d.speed * 2.5 } } else if (d.freeMode.sticky) { e.slideToClosest(); return } d.freeMode.momentumBounce && w ? (e.updateProgress(x), e.setTransition(y), e.setTranslate(v), e.transitionStart(!0, e.swipeDirection), e.animating = !0, ms(u, () => { !e || e.destroyed || !g.allowMomentumBounce || (i("momentumBounce"), e.setTransition(d.speed), setTimeout(() => { e.setTranslate(x), ms(u, () => { !e || e.destroyed || e.transitionEnd() }) }, 0)) })) : e.velocity ? (i("_freeModeNoMomentumRelease"), e.updateProgress(v), e.setTransition(y), e.setTranslate(v), e.transitionStart(!0, e.swipeDirection), e.animating || (e.animating = !0, ms(u, () => { !e || e.destroyed || e.transitionEnd() }))) : e.updateProgress(v), e.updateActiveIndex(), e.updateSlidesClasses() } else if (d.freeMode.sticky) { e.slideToClosest(); return } else d.freeMode && i("_freeModeNoMomentumRelease"); (!d.freeMode.momentum || m >= d.longSwipesMs) && (i("_freeModeStaticRelease"), e.updateProgress(), e.updateActiveIndex(), e.updateSlidesClasses()) } Object.assign(e, { freeMode: { onTouchStart: s, onTouchMove: a, onTouchEnd: o } }) } function $f(n) { let { swiper: e, extendParams: t, on: i } = n; t({ grid: { rows: 1, fill: "column" } }); let r, s, a, o; const l = () => { let h = e.params.spaceBetween; return typeof h == "string" && h.indexOf("%") >= 0 ? h = parseFloat(h.replace("%", "")) / 100 * e.size : typeof h == "string" && (h = parseFloat(h)), h }, c = h => { const { slidesPerView: m } = e.params, { rows: y, fill: _ } = e.params.grid, v = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : h.length; a = Math.floor(v / y), Math.floor(v / y) === v / y ? r = v : r = Math.ceil(v / y) * y, m !== "auto" && _ === "row" && (r = Math.max(r, m * y)), s = r / y }, d = () => { e.slides && e.slides.forEach(h => { h.swiperSlideGridSet && (h.style.height = "", h.style[e.getDirectionLabel("margin-top")] = "") }) }, u = (h, m, y) => { const { slidesPerGroup: _ } = e.params, v = l(), { rows: w, fill: x } = e.params.grid, S = e.virtual && e.params.virtual.enabled ? e.virtual.slides.length : y.length; let P, A, M; if (x === "row" && _ > 1) { const E = Math.floor(h / (_ * w)), O = h - w * _ * E, C = E === 0 ? _ : Math.min(Math.ceil((S - E * w * _) / w), _); M = Math.floor(O / C), A = O - M * C + E * _, P = A + M * r / w, m.style.order = P } else x === "column" ? (A = Math.floor(h / w), M = h - A * w, (A > a || A === a && M === w - 1) && (M += 1, M >= w && (M = 0, A += 1))) : (M = Math.floor(h / s), A = h - M * s); m.row = M, m.column = A, m.style.height = `calc((100% - ${(w - 1) * v}px) / ${w})`, m.style[e.getDirectionLabel("margin-top")] = M !== 0 ? v && `${v}px` : "", m.swiperSlideGridSet = !0 }, f = (h, m) => { const { centeredSlides: y, roundLengths: _ } = e.params, v = l(), { rows: w } = e.params.grid; if (e.virtualSize = (h + v) * r, e.virtualSize = Math.ceil(e.virtualSize / w) - v, e.params.cssMode || (e.wrapperEl.style[e.getDirectionLabel("width")] = `${e.virtualSize + v}px`), y) { const x = []; for (let S = 0; S < m.length; S += 1) { let P = m[S]; _ && (P = Math.floor(P)), m[S] < e.virtualSize + m[0] && x.push(P) } m.splice(0, m.length), m.push(...x) } }, p = () => { o = e.params.grid && e.params.grid.rows > 1 }, g = () => { const { params: h, el: m } = e, y = h.grid && h.grid.rows > 1; o && !y ? (m.classList.remove(`${h.containerModifierClass}grid`, `${h.containerModifierClass}grid-column`), a = 1, e.emitContainerClasses()) : !o && y && (m.classList.add(`${h.containerModifierClass}grid`), h.grid.fill === "column" && m.classList.add(`${h.containerModifierClass}grid-column`), e.emitContainerClasses()), o = y }; i("init", p), i("update", g), e.grid = { initSlides: c, unsetSlides: d, updateSlide: u, updateWrapperSize: f } } function Bf(n) { const e = this, { params: t, slidesEl: i } = e; t.loop && e.loopDestroy(); const r = s => { if (typeof s == "string") { const a = document.createElement("div"); a.innerHTML = s, i.append(a.children[0]), a.innerHTML = "" } else i.append(s) }; if (typeof n == "object" && "length" in n) for (let s = 0; s < n.length; s += 1)n[s] && r(n[s]); else r(n); e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update() } function Ff(n) { const e = this, { params: t, activeIndex: i, slidesEl: r } = e; t.loop && e.loopDestroy(); let s = i + 1; const a = o => { if (typeof o == "string") { const l = document.createElement("div"); l.innerHTML = o, r.prepend(l.children[0]), l.innerHTML = "" } else r.prepend(o) }; if (typeof n == "object" && "length" in n) { for (let o = 0; o < n.length; o += 1)n[o] && a(n[o]); s = i + n.length } else a(n); e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update(), e.slideTo(s, 0, !1) } function Nf(n, e) { const t = this, { params: i, activeIndex: r, slidesEl: s } = t; let a = r; i.loop && (a -= t.loopedSlides, t.loopDestroy(), t.recalcSlides()); const o = t.slides.length; if (n <= 0) { t.prependSlide(e); return } if (n >= o) { t.appendSlide(e); return } let l = a > n ? a + 1 : a; const c = []; for (let d = o - 1; d >= n; d -= 1) { const u = t.slides[d]; u.remove(), c.unshift(u) } if (typeof e == "object" && "length" in e) { for (let d = 0; d < e.length; d += 1)e[d] && s.append(e[d]); l = a > n ? a + e.length : a } else s.append(e); for (let d = 0; d < c.length; d += 1)s.append(c[d]); t.recalcSlides(), i.loop && t.loopCreate(), (!i.observer || t.isElement) && t.update(), i.loop ? t.slideTo(l + t.loopedSlides, 0, !1) : t.slideTo(l, 0, !1) } function qf(n) { const e = this, { params: t, activeIndex: i } = e; let r = i; t.loop && (r -= e.loopedSlides, e.loopDestroy()); let s = r, a; if (typeof n == "object" && "length" in n) { for (let o = 0; o < n.length; o += 1)a = n[o], e.slides[a] && e.slides[a].remove(), a < s && (s -= 1); s = Math.max(s, 0) } else a = n, e.slides[a] && e.slides[a].remove(), a < s && (s -= 1), s = Math.max(s, 0); e.recalcSlides(), t.loop && e.loopCreate(), (!t.observer || e.isElement) && e.update(), t.loop ? e.slideTo(s + e.loopedSlides, 0, !1) : e.slideTo(s, 0, !1) } function Yf() { const n = this, e = []; for (let t = 0; t < n.slides.length; t += 1)e.push(t); n.removeSlide(e) } function Hf(n) { let { swiper: e } = n; Object.assign(e, { appendSlide: Bf.bind(e), prependSlide: Ff.bind(e), addSlide: Nf.bind(e), removeSlide: qf.bind(e), removeAllSlides: Yf.bind(e) }) } function qr(n) { const { effect: e, swiper: t, on: i, setTranslate: r, setTransition: s, overwriteParams: a, perspective: o, recreateShadows: l, getEffectParams: c } = n; i("beforeInit", () => { if (t.params.effect !== e) return; t.classNames.push(`${t.params.containerModifierClass}${e}`), o && o() && t.classNames.push(`${t.params.containerModifierClass}3d`); const u = a ? a() : {}; Object.assign(t.params, u), Object.assign(t.originalParams, u) }), i("setTranslate", () => { t.params.effect === e && r() }), i("setTransition", (u, f) => { t.params.effect === e && s(f) }), i("transitionEnd", () => { if (t.params.effect === e && l) { if (!c || !c().slideShadows) return; t.slides.forEach(u => { u.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(f => f.remove()) }), l() } }); let d; i("virtualUpdate", () => { t.params.effect === e && (t.slides.length || (d = !0), requestAnimationFrame(() => { d && t.slides && t.slides.length && (r(), d = !1) })) }) } function Ls(n, e) { const t = mr(e); return t !== e && (t.style.backfaceVisibility = "hidden", t.style["-webkit-backface-visibility"] = "hidden"), t } function Cn(n) { let { swiper: e, duration: t, transformElements: i, allSlides: r } = n; const { activeIndex: s } = e, a = o => o.parentElement ? o.parentElement : e.slides.filter(c => c.shadowRoot && c.shadowRoot === o.parentNode)[0]; if (e.params.virtualTranslate && t !== 0) { let o = !1, l; r ? l = i : l = i.filter(c => { const d = c.classList.contains("swiper-slide-transform") ? a(c) : c; return e.getSlideIndex(d) === s }), l.forEach(c => { ms(c, () => { if (o || !e || e.destroyed) return; o = !0, e.animating = !1; const d = new window.CustomEvent("transitionend", { bubbles: !0, cancelable: !0 }); e.wrapperEl.dispatchEvent(d) }) }) } } function Vf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ fadeEffect: { crossFade: !1 } }), qr({ effect: "fade", swiper: e, on: i, setTranslate: () => { const { slides: a } = e, o = e.params.fadeEffect; for (let l = 0; l < a.length; l += 1) { const c = e.slides[l]; let u = -c.swiperSlideOffset; e.params.virtualTranslate || (u -= e.translate); let f = 0; e.isHorizontal() || (f = u, u = 0); const p = e.params.fadeEffect.crossFade ? Math.max(1 - Math.abs(c.progress), 0) : 1 + Math.min(Math.max(c.progress, -1), 0), g = Ls(o, c); g.style.opacity = p, g.style.transform = `translate3d(${u}px, ${f}px, 0px)` } }, setTransition: a => { const o = e.slides.map(l => mr(l)); o.forEach(l => { l.style.transitionDuration = `${a}ms` }), Cn({ swiper: e, duration: a, transformElements: o, allSlides: !0 }) }, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) } function Gf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ cubeEffect: { slideShadows: !0, shadow: !0, shadowOffset: 20, shadowScale: .94 } }); const r = (l, c, d) => { let u = d ? l.querySelector(".swiper-slide-shadow-left") : l.querySelector(".swiper-slide-shadow-top"), f = d ? l.querySelector(".swiper-slide-shadow-right") : l.querySelector(".swiper-slide-shadow-bottom"); u || (u = Lt("div", `swiper-slide-shadow-cube swiper-slide-shadow-${d ? "left" : "top"}`.split(" ")), l.append(u)), f || (f = Lt("div", `swiper-slide-shadow-cube swiper-slide-shadow-${d ? "right" : "bottom"}`.split(" ")), l.append(f)), u && (u.style.opacity = Math.max(-c, 0)), f && (f.style.opacity = Math.max(c, 0)) }; qr({ effect: "cube", swiper: e, on: i, setTranslate: () => { const { el: l, wrapperEl: c, slides: d, width: u, height: f, rtlTranslate: p, size: g, browser: h } = e, m = e.params.cubeEffect, y = e.isHorizontal(), _ = e.virtual && e.params.virtual.enabled; let v = 0, w; m.shadow && (y ? (w = e.wrapperEl.querySelector(".swiper-cube-shadow"), w || (w = Lt("div", "swiper-cube-shadow"), e.wrapperEl.append(w)), w.style.height = `${u}px`) : (w = l.querySelector(".swiper-cube-shadow"), w || (w = Lt("div", "swiper-cube-shadow"), l.append(w)))); for (let S = 0; S < d.length; S += 1) { const P = d[S]; let A = S; _ && (A = parseInt(P.getAttribute("data-swiper-slide-index"), 10)); let M = A * 90, E = Math.floor(M / 360); p && (M = -M, E = Math.floor(-M / 360)); const O = Math.max(Math.min(P.progress, 1), -1); let C = 0, k = 0, b = 0; A % 4 === 0 ? (C = -E * 4 * g, b = 0) : (A - 1) % 4 === 0 ? (C = 0, b = -E * 4 * g) : (A - 2) % 4 === 0 ? (C = g + E * 4 * g, b = g) : (A - 3) % 4 === 0 && (C = -g, b = 3 * g + g * 4 * E), p && (C = -C), y || (k = C, C = 0); const L = `rotateX(${y ? 0 : -M}deg) rotateY(${y ? M : 0}deg) translate3d(${C}px, ${k}px, ${b}px)`; O <= 1 && O > -1 && (v = A * 90 + O * 90, p && (v = -A * 90 - O * 90), e.browser && e.browser.isSafari && Math.abs(v) / 90 % 2 === 1 && (v += .001)), P.style.transform = L, m.slideShadows && r(P, O, y) } if (c.style.transformOrigin = `50% 50% -${g / 2}px`, c.style["-webkit-transform-origin"] = `50% 50% -${g / 2}px`, m.shadow) if (y) w.style.transform = `translate3d(0px, ${u / 2 + m.shadowOffset}px, ${-u / 2}px) rotateX(89.99deg) rotateZ(0deg) scale(${m.shadowScale})`; else { const S = Math.abs(v) - Math.floor(Math.abs(v) / 90) * 90, P = 1.5 - (Math.sin(S * 2 * Math.PI / 360) / 2 + Math.cos(S * 2 * Math.PI / 360) / 2), A = m.shadowScale, M = m.shadowScale / P, E = m.shadowOffset; w.style.transform = `scale3d(${A}, 1, ${M}) translate3d(0px, ${f / 2 + E}px, ${-f / 2 / M}px) rotateX(-89.99deg)` } const x = (h.isSafari || h.isWebView) && h.needPerspectiveFix ? -g / 2 : 0; c.style.transform = `translate3d(0px,0,${x}px) rotateX(${e.isHorizontal() ? 0 : v}deg) rotateY(${e.isHorizontal() ? -v : 0}deg)`, c.style.setProperty("--swiper-cube-translate-z", `${x}px`) }, setTransition: l => { const { el: c, slides: d } = e; if (d.forEach(u => { u.style.transitionDuration = `${l}ms`, u.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(f => { f.style.transitionDuration = `${l}ms` }) }), e.params.cubeEffect.shadow && !e.isHorizontal()) { const u = c.querySelector(".swiper-cube-shadow"); u && (u.style.transitionDuration = `${l}ms`) } }, recreateShadows: () => { const l = e.isHorizontal(); e.slides.forEach(c => { const d = Math.max(Math.min(c.progress, 1), -1); r(c, d, l) }) }, getEffectParams: () => e.params.cubeEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, resistanceRatio: 0, spaceBetween: 0, centeredSlides: !1, virtualTranslate: !0 }) }) } function Nr(n, e, t) { const i = `swiper-slide-shadow${t ? `-${t}` : ""}${n ? ` swiper-slide-shadow-${n}` : ""}`, r = mr(e); let s = r.querySelector(`.${i.split(" ").join(".")}`); return s || (s = Lt("div", i.split(" ")), r.append(s)), s } function Xf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ flipEffect: { slideShadows: !0, limitRotation: !0 } }); const r = (l, c) => { let d = e.isHorizontal() ? l.querySelector(".swiper-slide-shadow-left") : l.querySelector(".swiper-slide-shadow-top"), u = e.isHorizontal() ? l.querySelector(".swiper-slide-shadow-right") : l.querySelector(".swiper-slide-shadow-bottom"); d || (d = Nr("flip", l, e.isHorizontal() ? "left" : "top")), u || (u = Nr("flip", l, e.isHorizontal() ? "right" : "bottom")), d && (d.style.opacity = Math.max(-c, 0)), u && (u.style.opacity = Math.max(c, 0)) }; qr({ effect: "flip", swiper: e, on: i, setTranslate: () => { const { slides: l, rtlTranslate: c } = e, d = e.params.flipEffect; for (let u = 0; u < l.length; u += 1) { const f = l[u]; let p = f.progress; e.params.flipEffect.limitRotation && (p = Math.max(Math.min(f.progress, 1), -1)); const g = f.swiperSlideOffset; let m = -180 * p, y = 0, _ = e.params.cssMode ? -g - e.translate : -g, v = 0; e.isHorizontal() ? c && (m = -m) : (v = _, _ = 0, y = -m, m = 0), e.browser && e.browser.isSafari && (Math.abs(m) / 90 % 2 === 1 && (m += .001), Math.abs(y) / 90 % 2 === 1 && (y += .001)), f.style.zIndex = -Math.abs(Math.round(p)) + l.length, d.slideShadows && r(f, p); const w = `translate3d(${_}px, ${v}px, 0px) rotateX(${y}deg) rotateY(${m}deg)`, x = Ls(d, f); x.style.transform = w } }, setTransition: l => { const c = e.slides.map(d => mr(d)); c.forEach(d => { d.style.transitionDuration = `${l}ms`, d.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(u => { u.style.transitionDuration = `${l}ms` }) }), Cn({ swiper: e, duration: l, transformElements: c }) }, recreateShadows: () => { e.params.flipEffect, e.slides.forEach(l => { let c = l.progress; e.params.flipEffect.limitRotation && (c = Math.max(Math.min(l.progress, 1), -1)), r(l, c) }) }, getEffectParams: () => e.params.flipEffect, perspective: () => !0, overwriteParams: () => ({ slidesPerView: 1, slidesPerGroup: 1, watchSlidesProgress: !0, spaceBetween: 0, virtualTranslate: !e.params.cssMode }) }) } function Wf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ coverflowEffect: { rotate: 50, stretch: 0, depth: 100, scale: 1, modifier: 1, slideShadows: !0 } }), qr({ effect: "coverflow", swiper: e, on: i, setTranslate: () => { const { width: a, height: o, slides: l, slidesSizesGrid: c } = e, d = e.params.coverflowEffect, u = e.isHorizontal(), f = e.translate, p = u ? -f + a / 2 : -f + o / 2, g = u ? d.rotate : -d.rotate, h = d.depth; for (let m = 0, y = l.length; m < y; m += 1) { const _ = l[m], v = c[m], w = _.swiperSlideOffset, x = (p - w - v / 2) / v, S = typeof d.modifier == "function" ? d.modifier(x) : x * d.modifier; let P = u ? g * S : 0, A = u ? 0 : g * S, M = -h * Math.abs(S), E = d.stretch; typeof E == "string" && E.indexOf("%") !== -1 && (E = parseFloat(d.stretch) / 100 * v); let O = u ? 0 : E * S, C = u ? E * S : 0, k = 1 - (1 - d.scale) * Math.abs(S); Math.abs(C) < .001 && (C = 0), Math.abs(O) < .001 && (O = 0), Math.abs(M) < .001 && (M = 0), Math.abs(P) < .001 && (P = 0), Math.abs(A) < .001 && (A = 0), Math.abs(k) < .001 && (k = 0), e.browser && e.browser.isSafari && (Math.abs(P) / 90 % 2 === 1 && (P += .001), Math.abs(A) / 90 % 2 === 1 && (A += .001)); const b = `translate3d(${C}px,${O}px,${M}px)  rotateX(${A}deg) rotateY(${P}deg) scale(${k})`, L = Ls(d, _); if (L.style.transform = b, _.style.zIndex = -Math.abs(Math.round(S)) + 1, d.slideShadows) { let z = u ? _.querySelector(".swiper-slide-shadow-left") : _.querySelector(".swiper-slide-shadow-top"), D = u ? _.querySelector(".swiper-slide-shadow-right") : _.querySelector(".swiper-slide-shadow-bottom"); z || (z = Nr("coverflow", _, u ? "left" : "top")), D || (D = Nr("coverflow", _, u ? "right" : "bottom")), z && (z.style.opacity = S > 0 ? S : 0), D && (D.style.opacity = -S > 0 ? -S : 0) } } }, setTransition: a => { e.slides.map(l => mr(l)).forEach(l => { l.style.transitionDuration = `${a}ms`, l.querySelectorAll(".swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left").forEach(c => { c.style.transitionDuration = `${a}ms` }) }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0 }) }) } function jf(n) { let { swiper: e, extendParams: t, on: i } = n; t({ creativeEffect: { limitProgress: 1, shadowPerProgress: !1, progressMultiplier: 1, perspective: !0, prev: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 }, next: { translate: [0, 0, 0], rotate: [0, 0, 0], opacity: 1, scale: 1 } } }); const r = o => typeof o == "string" ? o : `${o}px`; qr({ effect: "creative", swiper: e, on: i, setTranslate: () => { const { slides: o, wrapperEl: l, slidesSizesGrid: c } = e, d = e.params.creativeEffect, { progressMultiplier: u } = d, f = e.params.centeredSlides; if (f) { const p = c[0] / 2 - e.params.slidesOffsetBefore || 0; l.style.transform = `translateX(calc(50% - ${p}px))` } for (let p = 0; p < o.length; p += 1) { const g = o[p], h = g.progress, m = Math.min(Math.max(g.progress, -d.limitProgress), d.limitProgress); let y = m; f || (y = Math.min(Math.max(g.originalProgress, -d.limitProgress), d.limitProgress)); const _ = g.swiperSlideOffset, v = [e.params.cssMode ? -_ - e.translate : -_, 0, 0], w = [0, 0, 0]; let x = !1; e.isHorizontal() || (v[1] = v[0], v[0] = 0); let S = { translate: [0, 0, 0], rotate: [0, 0, 0], scale: 1, opacity: 1 }; m < 0 ? (S = d.next, x = !0) : m > 0 && (S = d.prev, x = !0), v.forEach((k, b) => { v[b] = `calc(${k}px + (${r(S.translate[b])} * ${Math.abs(m * u)}))` }), w.forEach((k, b) => { let L = S.rotate[b] * Math.abs(m * u); e.browser && e.browser.isSafari && Math.abs(L) / 90 % 2 === 1 && (L += .001), w[b] = L }), g.style.zIndex = -Math.abs(Math.round(h)) + o.length; const P = v.join(", "), A = `rotateX(${w[0]}deg) rotateY(${w[1]}deg) rotateZ(${w[2]}deg)`, M = y < 0 ? `scale(${1 + (1 - S.scale) * y * u})` : `scale(${1 - (1 - S.scale) * y * u})`, E = y < 0 ? 1 + (1 - S.opacity) * y * u : 1 - (1 - S.opacity) * y * u, O = `translate3d(${P}) ${A} ${M}`; if (x && S.shadow || !x) { let k = g.querySelector(".swiper-slide-shadow"); if (!k && S.shadow && (k = Nr("creative", g)), k) { const b = d.shadowPerProgress ? m * (1 / d.limitProgress) : m; k.style.opacity = Math.min(Math.max(Math.abs(b), 0), 1) } } const C = Ls(d, g); C.style.transform = O, C.style.opacity = E, S.origin && (C.style.transformOrigin = S.origin) } }, setTransition: o => { const l = e.slides.map(c => mr(c)); l.forEach(c => { c.style.transitionDuration = `${o}ms`, c.querySelectorAll(".swiper-slide-shadow").forEach(d => { d.style.transitionDuration = `${o}ms` }) }), Cn({ swiper: e, duration: o, transformElements: l, allSlides: !0 }) }, perspective: () => e.params.creativeEffect.perspective, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode }) }) } function Uf(n) {
	let { swiper: e, extendParams: t, on: i } = n; t({ cardsEffect: { slideShadows: !0, rotate: !0, perSlideRotate: 2, perSlideOffset: 8 } }), qr({
		effect: "cards", swiper: e, on: i, setTranslate: () => {
			const { slides: a, activeIndex: o, rtlTranslate: l } = e, c = e.params.cardsEffect, { startTranslate: d, isTouched: u } = e.touchEventsData, f = l ? -e.translate : e.translate; for (let p = 0; p < a.length; p += 1) {
				const g = a[p], h = g.progress, m = Math.min(Math.max(h, -4), 4); let y = g.swiperSlideOffset; e.params.centeredSlides && !e.params.cssMode && (e.wrapperEl.style.transform = `translateX(${e.minTranslate()}px)`), e.params.centeredSlides && e.params.cssMode && (y -= a[0].swiperSlideOffset); let _ = e.params.cssMode ? -y - e.translate : -y, v = 0; const w = -100 * Math.abs(m); let x = 1, S = -c.perSlideRotate * m, P = c.perSlideOffset - Math.abs(m) * .75; const A = e.virtual && e.params.virtual.enabled ? e.virtual.from + p : p, M = (A === o || A === o - 1) && m > 0 && m < 1 && (u || e.params.cssMode) && f < d, E = (A === o || A === o + 1) && m < 0 && m > -1 && (u || e.params.cssMode) && f > d; if (M || E) { const b = (1 - Math.abs((Math.abs(m) - .5) / .5)) ** .5; S += -28 * m * b, x += -.5 * b, P += 96 * b, v = `${-25 * b * Math.abs(m)}%` } if (m < 0 ? _ = `calc(${_}px ${l ? "-" : "+"} (${P * Math.abs(m)}%))` : m > 0 ? _ = `calc(${_}px ${l ? "-" : "+"} (-${P * Math.abs(m)}%))` : _ = `${_}px`, !e.isHorizontal()) { const b = v; v = _, _ = b } const O = m < 0 ? `${1 + (1 - x) * m}` : `${1 - (1 - x) * m}`, C = `
        translate3d(${_}, ${v}, ${w}px)
        rotateZ(${c.rotate ? l ? -S : S : 0}deg)
        scale(${O})
      `; if (c.slideShadows) { let b = g.querySelector(".swiper-slide-shadow"); b || (b = Nr("cards", g)), b && (b.style.opacity = Math.min(Math.max((Math.abs(m) - .5) / .5, 0), 1)) } g.style.zIndex = -Math.abs(Math.round(h)) + a.length; const k = Ls(c, g); k.style.transform = C
			}
		}, setTransition: a => { const o = e.slides.map(l => mr(l)); o.forEach(l => { l.style.transitionDuration = `${a}ms`, l.querySelectorAll(".swiper-slide-shadow").forEach(c => { c.style.transitionDuration = `${a}ms` }) }), Cn({ swiper: e, duration: a, transformElements: o }) }, perspective: () => !0, overwriteParams: () => ({ watchSlidesProgress: !0, virtualTranslate: !e.params.cssMode })
	})
} const Kf = [xf, Sf, Tf, Ef, Mf, Cf, Pf, Lf, Af, kf, Of, Df, If, zf, Rf, $f, Hf, Vf, Gf, Xf, Wf, jf, Uf]; qe.use(Kf); let is, rs, bi; document.querySelector(".house-slider__swiper-galery") && (bi = new qe(".house-slider__swiper-galery", { direction: vd(), spaceBetween: 7, slidesPerView: _d(), freeMode: !1, watchSlidesProgress: !0, navigation: { nextEl: ".house-slider__swiper-button-next", prevEl: ".house-slider__swiper-button-prev" } }), new qe(".house-slider__swiper-thumbnail", { watchOverflow: !0, watchSlidesVisibility: !0, watchSlidesProgress: !0, preventInteractionOnTransition: !0, direction: "horizontal", spaceBetween: 10, navigation: { nextEl: ".house-slider__button-next", prevEl: ".house-slider__button-prev" }, thumbs: { swiper: bi } })); document.querySelectorAll(".MyResultsPreviewSwiper") && new qe(".MyResultsPreviewSwiper", { direction: "horizontal", loop: !0, preventClicks: !1, grabCursor: !0, preventClicksPropagation: !1, pagination: { clickable: !0, el: ".swiper-pagination" } }); document.querySelector(".myOfferSwiper") && new qe(".myOfferSwiper", { direction: "horizontal", loop: !0, preventClicks: !1, preventClicksPropagation: !1, navigation: { nextEl: ".offer__swiper-button-next", prevEl: ".offer__swiper-button-prev" } }); document.querySelector(".myProjectsSwiper") && (is = new qe(".myProjectsSwiper", { direction: "horizontal", loop: !0, slidesPerView: yd(), spaceBetween: bd(), navigation: { nextEl: ".projects__swiper-button-next", prevEl: ".projects__swiper-button-prev" } })); document.querySelector(".myHeroSwiper") && (rs = new qe(".myHeroSwiper", { direction: "horizontal", loop: !0, slidesPerView: wd(), autoplay: { delay: 3e3 }, spaceBetween: 5 })); window.addEventListener("resize", () => { rs && (rs.params.slidesPerView = wd(), rs.params.autoplay = { delay: 3e3 }, rs.update()), is && (is.params.slidesPerView = yd(), is.params.spaceBetween = bd(), is.update()), bi && (bi.params.direction = vd(), bi.params.slidesPerView = _d(), bi.params.thumbs = { swiper: bi }, bi.update()) }); function vd() { return window.innerWidth <= 1500 ? "horizontal" : "vertical" } function _d() { return window.innerWidth <= 739 && window.innerWidth > 539 ? 3 : window.innerWidth <= 539 ? 2 : 4 } function yd() { return window.innerWidth <= 739 ? 1 : window.innerWidth <= 920 ? 2 : window.innerWidth <= 1300 ? 3 : 4 } function wd() { return window.innerWidth <= 920 && window.innerWidth > 650 ? 3 : window.innerWidth <= 650 ? 2 : 4 } function bd() { return window.innerWidth <= 1e3 ? 20 : window.innerWidth > 1e3 ? 40 : 0 } function Zf(n) { if (Array.isArray(n)) { for (var e = 0, t = Array(n.length); e < n.length; e++)t[e] = n[e]; return t } else return Array.from(n) } var Za = !1; if (typeof window < "u") { var No = { get passive() { Za = !0 } }; window.addEventListener("testPassive", null, No), window.removeEventListener("testPassive", null, No) } var _n = typeof window < "u" && window.navigator && window.navigator.platform && (/iP(ad|hone|od)/.test(window.navigator.platform) || window.navigator.platform === "MacIntel" && window.navigator.maxTouchPoints > 1), or = [], yn = !1, xd = -1, gs = void 0, Ki = void 0, vs = void 0, Sd = function (e) { return or.some(function (t) { return !!(t.options.allowTouchMove && t.options.allowTouchMove(e)) }) }, wn = function (e) { var t = e || window.event; return Sd(t.target) || t.touches.length > 1 ? !0 : (t.preventDefault && t.preventDefault(), !1) }, Qf = function (e) { if (vs === void 0) { var t = !!e && e.reserveScrollBarGap === !0, i = window.innerWidth - document.documentElement.clientWidth; if (t && i > 0) { var r = parseInt(window.getComputedStyle(document.body).getPropertyValue("padding-right"), 10); vs = document.body.style.paddingRight, document.body.style.paddingRight = r + i + "px" } } gs === void 0 && (gs = document.body.style.overflow, document.body.style.overflow = "hidden") }, Jf = function () { vs !== void 0 && (document.body.style.paddingRight = vs, vs = void 0), gs !== void 0 && (document.body.style.overflow = gs, gs = void 0) }, ep = function () { return window.requestAnimationFrame(function () { if (Ki === void 0) { Ki = { position: document.body.style.position, top: document.body.style.top, left: document.body.style.left }; var e = window, t = e.scrollY, i = e.scrollX, r = e.innerHeight; document.body.style.position = "fixed", document.body.style.top = -t, document.body.style.left = -i, setTimeout(function () { return window.requestAnimationFrame(function () { var s = r - window.innerHeight; s && t >= r && (document.body.style.top = -(t + s)) }) }, 300) } }) }, tp = function () { if (Ki !== void 0) { var e = -parseInt(document.body.style.top, 10), t = -parseInt(document.body.style.left, 10); document.body.style.position = Ki.position, document.body.style.top = Ki.top, document.body.style.left = Ki.left, window.scrollTo(t, e), Ki = void 0 } }, ip = function (e) { return e ? e.scrollHeight - e.scrollTop <= e.clientHeight : !1 }, rp = function (e, t) { var i = e.targetTouches[0].clientY - xd; return Sd(e.target) ? !1 : t && t.scrollTop === 0 && i > 0 || ip(t) && i < 0 ? wn(e) : (e.stopPropagation(), !0) }, Td = function (e, t) { if (!e) { console.error("disableBodyScroll unsuccessful - targetElement must be provided when calling disableBodyScroll on IOS devices."); return } if (!or.some(function (r) { return r.targetElement === e })) { var i = { targetElement: e, options: t || {} }; or = [].concat(Zf(or), [i]), _n ? ep() : Qf(t), _n && (e.ontouchstart = function (r) { r.targetTouches.length === 1 && (xd = r.targetTouches[0].clientY) }, e.ontouchmove = function (r) { r.targetTouches.length === 1 && rp(r, e) }, yn || (document.addEventListener("touchmove", wn, Za ? { passive: !1 } : void 0), yn = !0)) } }, bn = function (e) { if (!e) { console.error("enableBodyScroll unsuccessful - targetElement must be provided when calling enableBodyScroll on IOS devices."); return } or = or.filter(function (t) { return t.targetElement !== e }), _n && (e.ontouchstart = null, e.ontouchmove = null, yn && or.length === 0 && (document.removeEventListener("touchmove", wn, Za ? { passive: !1 } : void 0), yn = !1)), _n ? tp() : Jf() }; if (document.querySelector("[data-menu]")) {
	let r = function () {
		n && n.getAttribute("data-menu") === "open" ? (n.dataset.menu = "close", bn(n), e.innerHTML = `
				<svg class="header__img-icon" >
					<use xlink: href = "../Images/sprite.svg#menu" />
				</svg>`) : n && (n.dataset.menu = "open", Td(n), e.innerHTML = `
				<svg class="header__img-icon">
					<use xlink:href="../Images/sprite.svg#close" />
				</svg>`)
	}; var op = r; const n = document.querySelector("[data-menu]"), e = document.querySelector("[data-menu-open]"), t = document.querySelector("[data-menu-close]"); document.querySelectorAll(".header__item").forEach(s => {
		s.addEventListener("click", () => {
			n && (n.dataset.menu = "close", bn(n), e.innerHTML = `
					<svg width="32px" height="32px">
						<use xlink:href="../Images/sprite.svg#close" />
					</svg>`)
		})
	}), e.addEventListener("click", r), t.addEventListener("click", r)
} function Ed(n) { const e = n.querySelector(".filter__dropdown-box"); if (!e) return; const t = e.getBoundingClientRect(), i = window.innerWidth - t.right, r = t.left; i < 0 && r >= t.width ? (e.style.right = "0", e.style.left = "auto") : (e.style.left = "0", e.style.right = "auto") } function Md() { document.querySelectorAll("[data-dropdown]").forEach(e => { e.classList.contains("active") && Ed(e) }) } window.addEventListener("resize", Md); document.addEventListener("click", n => { const e = n.target.matches("[data-dropdown-button]"); if (!e && n.target.closest("[data-dropdown]") != null) return; let t; e && (t = n.target.closest("[data-dropdown]"), t.classList.toggle("active"), t.classList.contains("active") && Ed(t)), document.querySelectorAll("[data-dropdown].active").forEach(i => { if (i !== t) return i.classList.remove("active") }), Md() }); document.addEventListener("click", n => { n.target.matches("[data-dropdown-button]") && n.target.closest("[data-dropdown-card]") && n.target.closest("[data-dropdown-card]").classList.toggle("active") }); if (document.querySelector(".filter__dropdown-inputs-size")) { const n = document.querySelectorAll(".filter__dropdown-inputs-size input"), e = document.querySelectorAll(".filter__dropdown-range-size input"), t = document.querySelector(".filter__dropdown-slider-size .filter__dropdown-slider-progress-size"), i = document.querySelectorAll(".filter__dropdown-inputs-price input"), r = document.querySelectorAll(".filter__dropdown-range-price input"), s = document.querySelector(".filter__dropdown-slider-price .filter__dropdown-slider-progress-price"); let a = 2, o = 1e3; e.forEach(l => { l.addEventListener("input", c => { let d = parseInt(e[0].value), u = parseInt(e[1].value); u - d >= a && u <= 400 && d >= 35 && (c.target.className === "filter__dropdown-range-number filter__dropdown-number-min range-number-size-min" ? (n[0].value = d, t.style.left = d / n[0].max * 100 + "%") : (n[1].value = u, t.style.right = 100 - u / n[1].max * 100 + "%")) }) }), n.forEach(l => { l.addEventListener("input", c => { let d = parseInt(n[0].value), u = parseInt(n[1].value); u - d < a ? c.target.className === "filter__dropdown-range-input-min range-size-min" ? n[0].value = u - a : n[1].value = d + a : (e[0].value = d, e[1].value = u, console.log(100 - u / n[1].max * 100 + 3 + "%"), t.style.left = d / n[0].max * 100 - 7 + "%", t.style.right = 100 - u / n[1].max * 100 + 2 + "%") }) }), r.forEach(l => { l.addEventListener("input", c => { let d = parseInt(r[0].value), u = parseInt(r[1].value); u - d >= o && u <= 2269e4 && d >= 147e4 && (c.target.className === "filter__dropdown-range-number filter__dropdown-number-min range-number-price-min" ? (i[0].value = d, s.style.left = d / i[0].max * 100 + "%") : (i[1].value = u, s.style.right = 100 - u / i[1].max * 100 + "%")) }) }), i.forEach(l => { l.addEventListener("input", c => { let d = parseInt(i[0].value), u = parseInt(i[1].value); u - d < o ? c.target.className === "filter__dropdown-range-input-min range-price-min" ? i[0].value = u - o : i[1].value = d + o : (r[0].value = d, r[1].value = u, s.style.left = d / i[0].max * 100 + "%", s.style.right = 100 - u / i[1].max * 100 + "%") }) }) } document.querySelector(".filter__dropdown") && (document.addEventListener("click", n => { const e = n.target.matches("[data-reset-button]"); if (!e && n.target.closest(".filter__dropdown-label") != null) return; let t; e && (t = n.target.closest("[data-dropdown]"), t.querySelector(".filter__option-name span").innerHTML = "", t.querySelectorAll("input").forEach(s => { s.checked = !1 })); const i = n.target.matches("[data-dropdown-button]"); if (!(!i && n.target.closest(".filter__dropdown-label") != null) && i) { let o = function () { const l = document.querySelectorAll(".filter__dropdown-input:checked"); a.innerHTML = `${l.length > 0 ? `<strong>:</strong> ${l.length}` : ""}` }; var r = o; let s = n.target.closest("[data-dropdown]"), a = s.querySelector(".filter__option-name span"); s.querySelectorAll("input").forEach(l => { l.addEventListener("change", o) }) } }), document.addEventListener("DOMContentLoaded", () => { const n = document.querySelector(".filter__dropdown-item"), e = Array.from(n.children), t = document.createElement("button"); t.setAttribute("type", "button"), t.classList.add("filter__show-button"); const i = 6; let r = !1; e.forEach((s, a) => { a >= i && (s.style.display = "none") }), e.length > i && (t.textContent = "Показать все", n.parentNode.insertBefore(t, n.nextSibling), t.addEventListener("click", () => { e.forEach((s, a) => { a >= i && (s.style.display = r ? "none" : "") }), t.textContent = r ? "Показать все" : "Скрыть", r = !r })) })); if (document.querySelector(".filter__options-item")) { let r = function () { n && n.getAttribute("data-search") === "open" ? (n.dataset.search = "close", bn(n)) : n && (n.dataset.search = "open", Td(n)) }; var lp = r; const n = document.querySelector("[data-search]"), e = document.querySelector("[data-search-open]"), t = document.querySelector("[data-search-close]"); document.querySelectorAll(".filter__options-item").forEach(s => { s.addEventListener("click", () => { n && (n.dataset.menu = "close", bn(n)) }) }), e.addEventListener("click", r), t.addEventListener("click", r) } document.addEventListener("click", n => { n.target.matches("[data-dropdown-table-button='1']") && (n.target.classList.add("active"), document.querySelector("[data-dropdown-table-button='2']").classList.remove("active"), document.querySelector("[data-dropdown-table='1']").style.display = "block", document.querySelector("[data-dropdown-table='2']").style.display = "none"), n.target.matches("[data-dropdown-table-button='2']") && (n.target.classList.add("active"), document.querySelector("[data-dropdown-table-button='1']").classList.remove("active"), document.querySelector("[data-dropdown-table='2']").style.display = "block", document.querySelector("[data-dropdown-table='1']").style.display = "none") }); class sp { constructor(e) { document.querySelectorAll(e).forEach(i => { if (i.querySelectorAll("img").length > 1) { const r = document.createElement("div"); r.classList.add("hvr"); const s = document.createElement("div"); s.classList.add("hvr__images"), r.appendChild(s); const a = document.createElement("div"); a.classList.add("hvr__sectors"), s.appendChild(a); const o = document.createElement("div"); o.classList.add("hvr__dots"), r.appendChild(o), i.parentNode.insertBefore(r, i), s.prepend(i); const l = r.querySelectorAll("img"); l.forEach(() => { a.insertAdjacentHTML("afterbegin", '<div class="hvr__sector"></div>'), o.insertAdjacentHTML("afterbegin", '<div class="hvr__dot"></div>') }), o.firstChild.classList.add("hvr__dot--active"); const c = function (d) { const u = [...a.children].indexOf(d); l.forEach((f, p) => { u == p ? f.style.display = "block" : f.style.display = "none" }), r.querySelectorAll(".hvr__dot").forEach((f, p) => { u == p ? f.classList.add("hvr__dot--active") : f.classList.remove("hvr__dot--active") }) }; a.addEventListener("mouseover", function (d) { d.target.matches(".hvr__sector") && c(d.target) }), a.addEventListener("touchmove", function (d) { const u = d.changedTouches[0], f = document.elementFromPoint(u.clientX, u.clientY); f.matches(".hvr__sector") && c(f) }) } }) } } new sp(".images"); const Gs = document.querySelector(".navigation"); let np = 199; window.addEventListener("scroll", () => { (window.pageYOffset || document.documentElement.scrollTop) > np ? (Gs.classList.add("navigation__move"), Gs.style.transform = "translateY(0px)") : (Gs.classList.remove("navigation__move"), Gs.style.transform = "translateY(0px)") }); const ap = document.querySelectorAll(".overlay__close-button"), Ii = document.querySelector(".overlay-box"); Ii.style.display = "none"; if (document.querySelector("[consultation-overlay]")) { const n = document.querySelector("[consultation-overlay]"), e = document.getElementById("consultation-overlay"); n.addEventListener("click", () => { e.style.display = "flex", Ii.style.display = "unset", document.body.style.overflow = "hidden", document.querySelector(".header").style.filter = "blur(4px)", document.querySelector(".main").style.filter = "blur(4px)", document.querySelector(".footer").style.filter = "blur(4px)", document.querySelector(".navigation").style.filter = "blur(4px)" }), e.addEventListener("click", t => { t.target === e && (e.style.display = "none", Ii.style.display = "none", document.body.style.overflow = "unset", document.querySelector(".header").style.filter = "unset", document.querySelector(".main").style.filter = "unset", document.querySelector(".footer").style.filter = "unset", document.querySelector(".navigation").style.filter = "unset") }) } if (document.querySelector("[project-overlay]")) { const n = document.querySelector("[project-overlay]"), e = document.getElementById("project-overlay"); n.addEventListener("click", () => { e.style.display = "flex", Ii.style.display = "unset", document.body.style.overflow = "hidden", document.querySelector(".header").style.filter = "blur(4px)", document.querySelector(".main").style.filter = "blur(4px)", document.querySelector(".footer").style.filter = "blur(4px)", document.querySelector(".navigation").style.filter = "blur(4px)" }), e.addEventListener("click", t => { t.target === e && (e.style.display = "none", Ii.style.display = "none", document.body.style.overflow = "unset", document.querySelector(".header").style.filter = "unset", document.querySelector(".main").style.filter = "unset", document.querySelector(".footer").style.filter = "unset", document.querySelector(".navigation").style.filter = "unset") }) } if (document.querySelector("[header-overlay]")) { const n = document.querySelector("[header-overlay]"), e = document.getElementById("header-overlay"); n.addEventListener("click", () => { e.style.display = "flex", Ii.style.display = "unset", document.body.style.overflow = "hidden", document.querySelector(".header").style.filter = "blur(4px)", document.querySelector(".main").style.filter = "blur(4px)", document.querySelector(".footer").style.filter = "blur(4px)", document.querySelector(".navigation").style.filter = "blur(4px)" }), e.addEventListener("click", t => { t.target === e && (e.style.display = "none", Ii.style.display = "none", document.body.style.overflow = "unset", document.querySelector(".header").style.filter = "unset", document.querySelector(".main").style.filter = "unset", document.querySelector(".footer").style.filter = "unset", document.querySelector(".navigation").style.filter = "unset") }) } ap.forEach(n => { n.addEventListener("click", e => { document.querySelectorAll(".overlay").forEach(t => { t.style.display = "none" }), Ii.style.display = "none", document.body.style.overflow = "unset", document.querySelector(".header").style.filter = "unset", document.querySelector(".main").style.filter = "unset", document.querySelector(".footer").style.filter = "unset", document.querySelector(".navigation").style.filter = "unset" }) }); if (document.querySelector(".header__items nav")) { let i = function (s, a) { if (s && a) a.appendChild(s); else return }, r = function (s, a) { if (s && a) a.appendChild(s); else return }; var dp = i, cp = r; const n = document.querySelectorAll(".header__item")[3], e = document.querySelector(".header__items nav"), t = document.querySelector(".header__button"); window.innerWidth < 740 && i(t, e), window.addEventListener("resize", () => { window.innerWidth < 740 ? i(t, e) : r(t, n) }) }
